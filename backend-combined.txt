BACKEND REPOSITORY CODE COMBINATION
Generated: 2025-08-31T19:12:23.394Z
Total Files: 32
================================================================================


============================================================
DIRECTORY: .
============================================================

// === combine-backend.js ===
#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Configuration
const OUTPUT_FILE = 'backend-combined.txt';
const ROOT_DIR = process.cwd();

// File extensions to include
const INCLUDE_EXTENSIONS = [
  '.js', '.ts', '.tsx', '.jsx', '.json', '.md', '.env.example', 
  '.sql', '.html', '.css', '.scss', '.yaml', '.yml', '.txt',
  '.gitignore', '.eslintrc', '.babelrc', '.prettierrc'
];

// Directories to exclude
const EXCLUDE_DIRS = [
  'node_modules', '.git', '.next', 'dist', 'build', 'coverage',
  '.nyc_output', 'logs', 'tmp', 'temp', '.cache', '.vscode',
  '.idea', 'bower_components'
];

// Files to exclude
const EXCLUDE_FILES = [
  '.env', '.env.local', '.env.production', '.env.development',
  'package-lock.json', 'yarn.lock', '.DS_Store', 'Thumbs.db',
  'npm-debug.log*', 'yarn-debug.log*', 'yarn-error.log*'
];

// Check if file should be included
function shouldIncludeFile(filePath, fileName) {
  // Check if file is in exclude list
  if (EXCLUDE_FILES.includes(fileName)) return false;
  
  // Check if any part of the path contains excluded directories
  const pathParts = filePath.split(path.sep);
  if (pathParts.some(part => EXCLUDE_DIRS.includes(part))) return false;
  
  // Check file extension
  const ext = path.extname(fileName);
  return INCLUDE_EXTENSIONS.includes(ext) || fileName.startsWith('.') && !fileName.includes('.');
}

// Get all files recursively
function getAllFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);
  
  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      if (!EXCLUDE_DIRS.includes(file)) {
        getAllFiles(filePath, fileList);
      }
    } else {
      if (shouldIncludeFile(filePath, file)) {
        fileList.push(filePath);
      }
    }
  });
  
  return fileList;
}

// Get relative path from root
function getRelativePath(filePath) {
  return path.relative(ROOT_DIR, filePath);
}

// Group files by directory
function groupFilesByDirectory(files) {
  const grouped = {};
  
  files.forEach(file => {
    const relativePath = getRelativePath(file);
    const dir = path.dirname(relativePath);
    
    if (!grouped[dir]) {
      grouped[dir] = [];
    }
    
    grouped[dir].push({
      fullPath: file,
      relativePath: relativePath,
      fileName: path.basename(file)
    });
  });
  
  return grouped;
}

// Read file content safely
function readFileContent(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    return content;
  } catch (error) {
    return `// Error reading file: ${error.message}`;
  }
}

// Main function
function combineFiles() {
  console.log('🔍 Scanning backend repository...');
  
  const allFiles = getAllFiles(ROOT_DIR);
  const groupedFiles = groupFilesByDirectory(allFiles);
  
  console.log(`📁 Found ${allFiles.length} files to combine`);
  
  let output = '';
  output += `BACKEND REPOSITORY CODE COMBINATION\n`;
  output += `Generated: ${new Date().toISOString()}\n`;
  output += `Total Files: ${allFiles.length}\n`;
  output += `${'='.repeat(80)}\n\n`;
  
  // Sort directories for consistent output
  const sortedDirs = Object.keys(groupedFiles).sort();
  
  sortedDirs.forEach(dir => {
    const files = groupedFiles[dir];
    
    output += `\n${'='.repeat(60)}\n`;
    output += `DIRECTORY: ${dir}\n`;
    output += `${'='.repeat(60)}\n\n`;
    
    // Sort files within directory
    files.sort((a, b) => a.fileName.localeCompare(b.fileName));
    
    files.forEach(file => {
      output += `// === ${file.relativePath} ===\n`;
      
      const content = readFileContent(file.fullPath);
      output += content;
      
      if (!content.endsWith('\n')) {
        output += '\n';
      }
      
      output += `\n// === END ${file.relativePath} ===\n\n`;
    });
  });
  
  // Write output file
  fs.writeFileSync(OUTPUT_FILE, output);
  
  console.log(`✅ Backend code combined successfully!`);
  console.log(`📄 Output file: ${OUTPUT_FILE}`);
  console.log(`📊 File size: ${(fs.statSync(OUTPUT_FILE).size / 1024).toFixed(2)} KB`);
  console.log('\n🚀 Ready to copy and paste into a gist!');
}

// Run the script
if (require.main === module) {
  try {
    combineFiles();
  } catch (error) {
    console.error('❌ Error combining files:', error.message);
    process.exit(1);
  }
}

// === END combine-backend.js ===

// === package.json ===
{
  "name": "galway-backend",
  "version": "1.0.0",
  "description": "Galway Research Institute - Digital Collectibles Platform Backend",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix",
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate dev",
    "db:seed": "node prisma/seed.js",
    "db:studio": "prisma studio",
    "build": "echo 'No build step required'",
    "production": "NODE_ENV=production node src/server.js"
  },
  "keywords": [
    "nodejs",
    "express",
    "prisma",
    "postgresql",
    "api",
    "trading",
    "collectibles",
    "authentication"
  ],
  "author": "Galway Research Institute",
  "license": "MIT",
  "dependencies": {
    "@prisma/client": "^6.14.0",
    "bcrypt": "^5.1.1",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.18.2",
    "express-rate-limit": "^7.5.1",
    "express-validator": "^7.2.1",
    "helmet": "^7.2.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "nodemailer": "^6.9.8",
    "stripe": "^14.25.0",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "eslint": "^8.56.0",
    "eslint-config-standard": "^17.1.0",
    "jest": "^29.7.0",
    "nodemon": "^3.0.3",
    "prisma": "^6.14.0",
    "supertest": "^6.3.4"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=8.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/galway-research/backend.git"
  },
  "bugs": {
    "url": "https://github.com/galway-research/backend/issues"
  },
  "homepage": "https://github.com/galway-research/backend#readme"
}

// === END package.json ===

// === prisma-diagnostic.js ===
// prisma-diagnostic.js
// Run this script to diagnose Prisma connection issues
// Usage: node prisma-diagnostic.js

const { PrismaClient } = require('@prisma/client');
require('dotenv').config();

const main = async () => {
  console.log('🔍 Prisma Connection Diagnostic Tool');
  console.log('=====================================');
  
  // Check environment variables
  console.log('\n📋 Environment Check:');
  console.log('DATABASE_URL exists:', !!process.env.DATABASE_URL);
  console.log('JWT_SECRET exists:', !!process.env.JWT_SECRET);
  console.log('BCRYPT_ROUNDS:', process.env.BCRYPT_ROUNDS || 'not set (will default to 12)');
  
  if (!process.env.DATABASE_URL) {
    console.error('❌ DATABASE_URL is not set in environment');
    return;
  }
  
  // Initialize Prisma client
  console.log('\n🔌 Initializing Prisma Client...');
  const prisma = new PrismaClient({
    log: ['query', 'info', 'warn', 'error'],
  });
  
  try {
    // Test database connection
    console.log('🔗 Testing database connection...');
    await prisma.$connect();
    console.log('✅ Database connection successful');
    
    // Test Prisma client models
    console.log('🔍 Inspecting Prisma client models...');
    console.log('Available models:', Object.keys(prisma));
    console.log('Has user model:', 'user' in prisma);
    console.log('Has User model:', 'User' in prisma);
    
    // Test basic query with proper model name
    console.log('📊 Testing basic query...');
    if ('user' in prisma) {
      const userCount = await prisma.user.count();
      console.log(`✅ User count query successful: ${userCount} users found`);
    } else if ('User' in prisma) {
      const userCount = await prisma.User.count();
      console.log(`✅ User count query successful: ${userCount} users found`);
    } else {
      console.log('❌ No user/User model found in Prisma client');
      return;
    }
    
    // Test schema introspection
    console.log('🔍 Testing schema introspection...');
    const tableInfo = await prisma.$queryRaw`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_type = 'BASE TABLE'
      ORDER BY table_name;
    `;
    console.log('✅ Schema introspection successful');
    console.log('📋 Available tables:', tableInfo.map(t => t.table_name).join(', '));
    
    // Test user table structure
    console.log('👤 Testing user table structure...');
    const columnInfo = await prisma.$queryRaw`
      SELECT column_name, data_type, is_nullable, column_default
      FROM information_schema.columns 
      WHERE table_name = 'User' 
      ORDER BY ordinal_position;
    `;
    console.log('✅ User table structure:');
    columnInfo.forEach(col => {
      console.log(`   - ${col.column_name}: ${col.data_type} (${col.is_nullable === 'YES' ? 'nullable' : 'not null'})`);
    });
    
    // Test finding a user (should not error even if no users exist)
    console.log('🔍 Testing user findFirst...');
    const firstUser = await prisma.user.findFirst({
      select: { id: true, username: true, email: true, idNo: true, createdAt: true }
    });
    console.log('✅ User findFirst successful');
    if (firstUser) {
      console.log('👤 Sample user found:', firstUser);
    } else {
      console.log('👤 No users found (this is normal for a new database)');
    }
    
    // Test ID generation logic
    console.log('🔢 Testing ID generation...');
    const testId = Math.floor(100000 + Math.random() * 900000).toString();
    const existingWithId = await prisma.user.findUnique({
      where: { idNo: testId }
    });
    console.log(`✅ ID check successful: ${testId} is ${existingWithId ? 'taken' : 'available'}`);
    
    console.log('\n🎉 All diagnostic tests passed!');
    console.log('✅ Your Prisma setup is working correctly');
    console.log('\n💡 If you\'re still getting errors, try:');
    console.log('   1. Restart your server: npm run dev');
    console.log('   2. Clear node_modules and reinstall: rm -rf node_modules && npm install');
    console.log('   3. Regenerate Prisma client: npx prisma generate');
    
  } catch (error) {
    console.error('\n❌ Diagnostic failed:');
    console.error('Error:', error.message);
    console.error('Code:', error.code);
    console.error('Meta:', error.meta);
    
    console.log('\n🔧 Troubleshooting suggestions:');
    
    if (error.code === 'P1001') {
      console.log('   - Database server unreachable. Check your DATABASE_URL');
      console.log('   - Verify DigitalOcean database is running');
      console.log('   - Check firewall/network settings');
    } else if (error.code === 'P1003') {
      console.log('   - Database does not exist. Create the database first');
    } else if (error.code === 'P1008') {
      console.log('   - Connection timeout. Check network connectivity');
    } else if (error.code === 'P2021') {
      console.log('   - Table does not exist. Run: npx prisma db push');
    } else if (error.message.includes('findFirst')) {
      console.log('   - Prisma client not properly initialized');
      console.log('   - Run: npx prisma generate');
      console.log('   - Restart your application');
    } else {
      console.log('   - Run: npx prisma db push');
      console.log('   - Run: npx prisma generate');
      console.log('   - Check your DATABASE_URL format');
    }
    
  } finally {
    await prisma.$disconnect();
    console.log('\n🔌 Prisma client disconnected');
  }
};

main().catch((error) => {
  console.error('💥 Unexpected error:', error);
  process.exit(1);
});

// === END prisma-diagnostic.js ===

// === raw-schema.sql ===
-- Galway Research Institute - Complete Database Schema
-- Optimized for performance, security, and scalability

-- Core user authentication and profiles
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(20) UNIQUE NOT NULL,
    email VARCHAR(254) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    role user_role NOT NULL DEFAULT 'operative',
    
    -- Profile data
    bio TEXT CHECK (LENGTH(bio) <= 120),
    onset_date DATE NOT NULL DEFAULT CURRENT_DATE,
    id_no VARCHAR(6) UNIQUE NOT NULL, -- Auto-generated 6-digit ID
    
    -- Optional personal info
    birthday DATE,
    country VARCHAR(100),
    city VARCHAR(100),
    
    -- Verification status
    email_verified BOOLEAN DEFAULT FALSE,
    phone_verified BOOLEAN DEFAULT FALSE,
    email_verification_token VARCHAR(32),
    phone_verification_code VARCHAR(6),
    verification_expires_at TIMESTAMP,
    
    -- Security
    last_username_change TIMESTAMP,
    failed_login_attempts INTEGER DEFAULT 0,
    locked_until TIMESTAMP,
    
    -- Active olive branch reference
    active_olive_branch_id INTEGER,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP,
    
    -- Constraints
    CONSTRAINT valid_username CHECK (username ~ '^[a-z0-9._]+$' AND LENGTH(username) >= 3),
    CONSTRAINT valid_email CHECK (email ~ '^[^@\s]+@[^@\s]+\.[^@\s]+$'),
    CONSTRAINT username_no_consecutive_periods CHECK (username !~ '\.\.')
);

-- User roles enum
CREATE TYPE user_role AS ENUM ('guest', 'operative', 'contributor', 'beta-tester', 'moderator', 'admin');

-- Olive branch botanical signatures (unique generated art)
CREATE TABLE olive_branches (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Generation data (store minimal data, regenerate SVG on demand)
    seed_value VARCHAR(32) NOT NULL, -- For deterministic regeneration
    olive_count INTEGER NOT NULL CHECK (olive_count BETWEEN 1 AND 5),
    olive_type VARCHAR(20) NOT NULL,
    
    -- Color data (hex values)
    olive_color VARCHAR(7) NOT NULL,
    branch_color VARCHAR(7) NOT NULL,
    leaf_color VARCHAR(7) NOT NULL,
    
    -- Rarity metadata
    count_rarity VARCHAR(20) NOT NULL,
    type_rarity VARCHAR(20) NOT NULL,
    count_rarity_percentage INTEGER NOT NULL,
    type_rarity_percentage INTEGER NOT NULL,
    
    -- SVG cache (optional - can regenerate from seed_value)
    svg_cache TEXT,
    
    -- Metadata
    botanical_id VARCHAR(12) UNIQUE NOT NULL, -- Human-readable ID like "OLV-ABC123"
    is_active BOOLEAN DEFAULT FALSE, -- Currently displayed on user profile
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User inventory system (seeds, branches, physical items)
CREATE TABLE inventory_items (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Item classification
    item_type item_type_enum NOT NULL,
    item_id INTEGER, -- References olive_branches.id for branches, NULL for seeds
    
    -- Stackable items (seeds, consumables)
    quantity INTEGER DEFAULT 1 CHECK (quantity > 0),
    
    -- Item source tracking
    source_type VARCHAR(20) NOT NULL, -- 'generated', 'purchased', 'traded', 'earned'
    source_reference VARCHAR(50), -- Order ID, trade ID, etc.
    
    -- Position in inventory grid
    grid_position INTEGER CHECK (grid_position BETWEEN 0 AND 79), -- 80 total slots
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Ensure branches aren't stacked
    CONSTRAINT branch_quantity_one CHECK (
        item_type != 'branch' OR quantity = 1
    ),
    -- Ensure branches have valid references
    CONSTRAINT branch_has_reference CHECK (
        item_type != 'branch' OR item_id IS NOT NULL
    ),
    -- Unique position per user
    UNIQUE(user_id, grid_position)
);

CREATE TYPE item_type_enum AS ENUM ('seed', 'branch', 'physical');

-- Trading system with escrow
CREATE TABLE trades (
    id SERIAL PRIMARY KEY,
    
    -- Parties
    seller_id INTEGER NOT NULL REFERENCES users(id),
    buyer_id INTEGER NOT NULL REFERENCES users(id),
    
    -- Item being traded
    inventory_item_id INTEGER NOT NULL REFERENCES inventory_items(id),
    
    -- Trade terms
    price_cents INTEGER NOT NULL CHECK (price_cents > 0), -- Store in cents to avoid float issues
    currency VARCHAR(3) DEFAULT 'USD',
    
    -- Trade status
    status trade_status DEFAULT 'pending',
    
    -- Escrow details
    escrow_payment_id VARCHAR(100), -- Stripe payment intent ID
    escrow_expires_at TIMESTAMP NOT NULL,
    auto_release_at TIMESTAMP, -- Auto-confirm after X days
    
    -- Dispute resolution
    dispute_reason TEXT,
    dispute_evidence JSONB, -- File URLs, messages, etc.
    admin_notes TEXT,
    resolved_by INTEGER REFERENCES users(id),
    
    -- Important timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    confirmed_at TIMESTAMP,
    completed_at TIMESTAMP,
    cancelled_at TIMESTAMP,
    
    CONSTRAINT no_self_trade CHECK (seller_id != buyer_id)
);

CREATE TYPE trade_status AS ENUM (
    'pending',      -- Waiting for buyer confirmation
    'confirmed',    -- Both parties agreed, payment in escrow
    'shipping',     -- Physical item being shipped (if applicable)
    'disputed',     -- Dispute raised, admin review needed
    'completed',    -- Trade successful, item transferred
    'cancelled',    -- Trade cancelled before completion
    'refunded'      -- Dispute resolved in buyer favor
);

-- Payment system integration
CREATE TABLE payments (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    
    -- Payment details
    stripe_payment_intent_id VARCHAR(100) UNIQUE,
    amount_cents INTEGER NOT NULL CHECK (amount_cents > 0),
    currency VARCHAR(3) DEFAULT 'USD',
    
    -- Payment purpose
    payment_type payment_type_enum NOT NULL,
    reference_id INTEGER, -- Order ID, trade ID, subscription ID
    
    -- Status tracking
    status payment_status DEFAULT 'pending',
    
    -- Metadata
    stripe_metadata JSONB,
    failure_reason TEXT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    
    -- Ensure reference exists for trades
    CONSTRAINT trade_payment_reference CHECK (
        payment_type != 'trade_escrow' OR reference_id IS NOT NULL
    )
);

CREATE TYPE payment_type_enum AS ENUM ('seed_purchase', 'subscription', 'trade_escrow', 'physical_item');
CREATE TYPE payment_status AS ENUM ('pending', 'succeeded', 'failed', 'cancelled', 'refunded');

-- Forum system
CREATE TABLE forum_categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    sort_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    
    -- Permissions
    min_role_to_view user_role DEFAULT 'operative',
    min_role_to_post user_role DEFAULT 'operative',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE forum_threads (
    id SERIAL PRIMARY KEY,
    category_id INTEGER NOT NULL REFERENCES forum_categories(id),
    
    -- Thread details
    title VARCHAR(200) NOT NULL,
    slug VARCHAR(250) UNIQUE NOT NULL, -- URL-friendly version
    
    -- Author
    author_id INTEGER NOT NULL REFERENCES users(id),
    
    -- Status
    is_pinned BOOLEAN DEFAULT FALSE,
    is_locked BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    
    -- Stats (cached for performance)
    reply_count INTEGER DEFAULT 0,
    last_activity_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_reply_by INTEGER REFERENCES users(id),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE forum_posts (
    id SERIAL PRIMARY KEY,
    thread_id INTEGER NOT NULL REFERENCES forum_threads(id) ON DELETE CASCADE,
    
    -- Post details
    content TEXT NOT NULL CHECK (LENGTH(content) > 0),
    author_id INTEGER NOT NULL REFERENCES users(id),
    
    -- Post metadata
    is_first_post BOOLEAN DEFAULT FALSE, -- Original thread post
    is_deleted BOOLEAN DEFAULT FALSE,
    edited_at TIMESTAMP,
    edited_by INTEGER REFERENCES users(id),
    
    -- Moderation
    is_reported BOOLEAN DEFAULT FALSE,
    report_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Private messaging system
CREATE TABLE private_messages (
    id SERIAL PRIMARY KEY,
    
    -- Participants
    sender_id INTEGER NOT NULL REFERENCES users(id),
    recipient_id INTEGER NOT NULL REFERENCES users(id),
    
    -- Message content
    subject VARCHAR(200),
    content TEXT NOT NULL CHECK (LENGTH(content) > 0),
    
    -- Status
    is_read BOOLEAN DEFAULT FALSE,
    is_deleted_by_sender BOOLEAN DEFAULT FALSE,
    is_deleted_by_recipient BOOLEAN DEFAULT FALSE,
    
    -- Threading
    reply_to_id INTEGER REFERENCES private_messages(id),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    read_at TIMESTAMP,
    
    CONSTRAINT no_self_message CHECK (sender_id != recipient_id)
);

-- Notification system
CREATE TABLE notifications (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Notification details
    type notification_type NOT NULL,
    title VARCHAR(200) NOT NULL,
    message TEXT,
    
    -- Action/link
    action_url VARCHAR(500),
    
    -- Status
    is_read BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    
    -- Reference data (for trade notifications, etc.)
    reference_type VARCHAR(50), -- 'trade', 'message', 'forum_reply'
    reference_id INTEGER,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    read_at TIMESTAMP
);

CREATE TYPE notification_type AS ENUM (
    'trade_offer', 'trade_confirmed', 'trade_completed', 'trade_disputed',
    'payment_received', 'payment_failed',
    'message_received', 'forum_reply', 'forum_mention',
    'account_verification', 'security_alert',
    'admin_announcement'
);

-- User sessions for authentication
CREATE TABLE user_sessions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Session data
    token_hash VARCHAR(255) UNIQUE NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    
    -- Device/browser info
    user_agent TEXT,
    ip_address INET,
    
    -- Session metadata
    is_active BOOLEAN DEFAULT TRUE,
    last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Admin activity logs
CREATE TABLE admin_logs (
    id SERIAL PRIMARY KEY,
    admin_id INTEGER NOT NULL REFERENCES users(id),
    
    -- Action details
    action VARCHAR(100) NOT NULL,
    target_type VARCHAR(50), -- 'user', 'trade', 'post', etc.
    target_id INTEGER,
    
    -- Change details
    old_values JSONB,
    new_values JSONB,
    notes TEXT,
    
    -- Context
    ip_address INET,
    user_agent TEXT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Collection achievements and goals system
CREATE TABLE achievements (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT NOT NULL,
    badge_icon VARCHAR(100), -- Icon/emoji for the badge
    category achievement_category NOT NULL,
    
    -- Achievement criteria (JSON for flexibility)
    criteria JSONB NOT NULL, -- e.g., {"olive_count": 10, "rarity": "rare"}
    reward_type reward_type_enum,
    reward_value INTEGER, -- Seeds, points, etc.
    
    -- Visibility and ordering
    is_active BOOLEAN DEFAULT TRUE,
    is_hidden BOOLEAN DEFAULT FALSE, -- Secret achievements
    sort_order INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TYPE achievement_category AS ENUM ('collector', 'trader', 'social', 'seasonal', 'special');
CREATE TYPE reward_type_enum AS ENUM ('seeds', 'points', 'badge_only', 'early_access');

-- User achievement progress tracking
CREATE TABLE user_achievements (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    achievement_id INTEGER NOT NULL REFERENCES achievements(id),
    
    -- Progress tracking
    progress_current INTEGER DEFAULT 0,
    progress_required INTEGER NOT NULL,
    is_completed BOOLEAN DEFAULT FALSE,
    
    -- Completion data
    completed_at TIMESTAMP,
    claimed_at TIMESTAMP,
    
    -- Progress metadata (for complex achievements)
    progress_data JSONB,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id, achievement_id)
);

-- User following/friends system
CREATE TABLE user_follows (
    id SERIAL PRIMARY KEY,
    follower_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    following_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Follow metadata
    is_mutual BOOLEAN DEFAULT FALSE, -- Auto-calculated
    notification_enabled BOOLEAN DEFAULT TRUE,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT no_self_follow CHECK (follower_id != following_id),
    UNIQUE(follower_id, following_id)
);

-- Activity feed system
CREATE TABLE activity_feed (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Activity details
    activity_type activity_type_enum NOT NULL,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    
    -- Referenced objects
    reference_type VARCHAR(50), -- 'olive_branch', 'trade', 'achievement'
    reference_id INTEGER,
    reference_data JSONB, -- Store snapshot of referenced object
    
    -- Visibility and engagement
    is_public BOOLEAN DEFAULT TRUE,
    like_count INTEGER DEFAULT 0,
    comment_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TYPE activity_type_enum AS ENUM (
    'branch_generated', 'rare_branch_found', 'trade_completed',
    'achievement_unlocked', 'milestone_reached', 'level_up',
    'collection_goal_completed', 'seasonal_event_participated',
    'referred_friend', 'forum_post_featured'
);

-- Activity feed likes and comments
CREATE TABLE activity_likes (
    id SERIAL PRIMARY KEY,
    activity_id INTEGER NOT NULL REFERENCES activity_feed(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(activity_id, user_id)
);

CREATE TABLE activity_comments (
    id SERIAL PRIMARY KEY,
    activity_id INTEGER NOT NULL REFERENCES activity_feed(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL CHECK (LENGTH(content) > 0),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User reviews and ratings system
CREATE TABLE user_reviews (
    id SERIAL PRIMARY KEY,
    reviewer_id INTEGER NOT NULL REFERENCES users(id),
    reviewed_id INTEGER NOT NULL REFERENCES users(id),
    
    -- Review details
    rating INTEGER NOT NULL CHECK (rating BETWEEN 1 AND 5),
    title VARCHAR(100),
    comment TEXT,
    
    -- Context (what transaction prompted this review)
    trade_id INTEGER REFERENCES trades(id),
    transaction_type VARCHAR(50), -- 'trade', 'forum_interaction', etc.
    
    -- Status
    is_public BOOLEAN DEFAULT TRUE,
    is_verified BOOLEAN DEFAULT FALSE, -- Verified transaction
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT no_self_review CHECK (reviewer_id != reviewed_id),
    UNIQUE(reviewer_id, reviewed_id, trade_id)
);

-- Daily login rewards system
CREATE TABLE daily_rewards (
    id SERIAL PRIMARY KEY,
    day_number INTEGER NOT NULL, -- Day 1, 2, 3, etc.
    reward_type reward_type_enum NOT NULL,
    reward_amount INTEGER NOT NULL,
    
    -- Special rewards
    is_bonus_day BOOLEAN DEFAULT FALSE, -- Weekend/special multipliers
    bonus_multiplier DECIMAL(3,2) DEFAULT 1.0,
    
    -- Streak requirements
    requires_consecutive BOOLEAN DEFAULT TRUE,
    
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User daily login tracking
CREATE TABLE user_daily_logins (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Streak tracking
    login_date DATE NOT NULL,
    current_streak INTEGER DEFAULT 1,
    longest_streak INTEGER DEFAULT 1,
    
    -- Reward tracking
    reward_claimed BOOLEAN DEFAULT FALSE,
    reward_type reward_type_enum,
    reward_amount INTEGER,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id, login_date)
);

-- Leaderboards system
CREATE TABLE leaderboards (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    category leaderboard_category NOT NULL,
    
    -- Leaderboard configuration
    scoring_method VARCHAR(50) NOT NULL, -- 'collection_value', 'trade_volume', etc.
    time_period leaderboard_period NOT NULL,
    max_entries INTEGER DEFAULT 100,
    
    -- Status
    is_active BOOLEAN DEFAULT TRUE,
    is_featured BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TYPE leaderboard_category AS ENUM ('collector', 'trader', 'social', 'forum', 'seasonal');
CREATE TYPE leaderboard_period AS ENUM ('daily', 'weekly', 'monthly', 'all_time', 'seasonal');

-- Leaderboard entries (current standings)
CREATE TABLE leaderboard_entries (
    id SERIAL PRIMARY KEY,
    leaderboard_id INTEGER NOT NULL REFERENCES leaderboards(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Ranking data
    rank_position INTEGER NOT NULL,
    score DECIMAL(12,2) NOT NULL,
    score_data JSONB, -- Breakdown of how score was calculated
    
    -- Metadata
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(leaderboard_id, user_id, period_start)
);

-- Seasonal events system
CREATE TABLE seasonal_events (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT NOT NULL,
    
    -- Event timing
    start_date TIMESTAMP NOT NULL,
    end_date TIMESTAMP NOT NULL,
    timezone VARCHAR(50) DEFAULT 'UTC',
    
    -- Event configuration
    event_type seasonal_event_type NOT NULL,
    special_mechanics JSONB, -- Event-specific rules
    
    -- Rewards and goals
    participation_reward_type reward_type_enum,
    participation_reward_amount INTEGER,
    completion_rewards JSONB, -- Tiered rewards
    
    -- Visual customization
    theme_colors JSONB,
    banner_image VARCHAR(200),
    
    -- Status
    is_active BOOLEAN DEFAULT TRUE,
    is_featured BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TYPE seasonal_event_type AS ENUM ('breeding_bonus', 'rare_boost', 'trading_festival', 'community_challenge');

-- User participation in seasonal events
CREATE TABLE user_event_participation (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    event_id INTEGER NOT NULL REFERENCES seasonal_events(id),
    
    -- Participation data
    progress_current INTEGER DEFAULT 0,
    progress_target INTEGER NOT NULL,
    is_completed BOOLEAN DEFAULT FALSE,
    
    -- Rewards tracking
    rewards_claimed JSONB DEFAULT '[]',
    total_rewards_value INTEGER DEFAULT 0,
    
    -- Participation metadata
    participation_data JSONB,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    
    UNIQUE(user_id, event_id)
);

-- Referral program system
CREATE TABLE referral_codes (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Code details
    code VARCHAR(20) UNIQUE NOT NULL,
    max_uses INTEGER DEFAULT NULL, -- NULL = unlimited
    current_uses INTEGER DEFAULT 0,
    
    -- Rewards
    referrer_reward_type reward_type_enum NOT NULL,
    referrer_reward_amount INTEGER NOT NULL,
    referee_reward_type reward_type_enum NOT NULL,
    referee_reward_amount INTEGER NOT NULL,
    
    -- Status and timing
    is_active BOOLEAN DEFAULT TRUE,
    expires_at TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Referral tracking
CREATE TABLE referrals (
    id SERIAL PRIMARY KEY,
    referrer_id INTEGER NOT NULL REFERENCES users(id),
    referee_id INTEGER NOT NULL REFERENCES users(id),
    referral_code_id INTEGER NOT NULL REFERENCES referral_codes(id),
    
    -- Conversion tracking
    signup_completed BOOLEAN DEFAULT FALSE,
    first_purchase_completed BOOLEAN DEFAULT FALSE,
    
    -- Reward tracking
    referrer_rewarded BOOLEAN DEFAULT FALSE,
    referee_rewarded BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    converted_at TIMESTAMP,
    
    CONSTRAINT no_self_referral CHECK (referrer_id != referee_id)
);

-- Two-factor authentication system
CREATE TABLE user_2fa (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- 2FA methods
    totp_secret VARCHAR(32), -- Time-based OTP secret
    sms_enabled BOOLEAN DEFAULT FALSE,
    app_enabled BOOLEAN DEFAULT FALSE,
    
    -- Backup codes
    backup_codes JSONB, -- Array of hashed backup codes
    backup_codes_used INTEGER DEFAULT 0,
    
    -- Recovery
    recovery_codes JSONB, -- Long-term recovery codes
    
    -- Status
    is_enabled BOOLEAN DEFAULT FALSE,
    last_used TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id)
);

-- Account recovery system
CREATE TABLE account_recovery (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Recovery method
    recovery_type recovery_method_type NOT NULL,
    recovery_token VARCHAR(255) NOT NULL,
    
    -- Recovery data
    recovery_data JSONB, -- Questions/answers, contact info, etc.
    
    -- Status and timing
    is_used BOOLEAN DEFAULT FALSE,
    expires_at TIMESTAMP NOT NULL,
    used_at TIMESTAMP,
    
    -- Security
    ip_address INET,
    user_agent TEXT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TYPE recovery_method_type AS ENUM ('email', 'sms', 'security_questions', 'admin_review');

-- IP blocking and rate limiting
CREATE TABLE ip_blocks (
    id SERIAL PRIMARY KEY,
    ip_address INET NOT NULL,
    
    -- Block details
    block_type block_type_enum NOT NULL,
    reason TEXT NOT NULL,
    
    -- Timing
    blocked_until TIMESTAMP, -- NULL = permanent
    
    -- Metadata
    blocked_by INTEGER REFERENCES users(id),
    auto_generated BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TYPE block_type_enum AS ENUM ('temporary', 'permanent', 'rate_limit', 'suspicious_activity');

-- Rate limiting tracking
CREATE TABLE rate_limits (
    id SERIAL PRIMARY KEY,
    identifier VARCHAR(100) NOT NULL, -- IP address or user ID
    identifier_type VARCHAR(20) NOT NULL, -- 'ip' or 'user'
    
    -- Rate limit details
    action VARCHAR(50) NOT NULL, -- 'login', 'api_call', 'trade_request'
    attempts INTEGER DEFAULT 1,
    window_start TIMESTAMP NOT NULL,
    window_duration INTERVAL NOT NULL,
    
    -- Status
    is_blocked BOOLEAN DEFAULT FALSE,
    blocked_until TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(identifier, identifier_type, action, window_start)
);

-- Content moderation system
CREATE TABLE moderation_rules (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    
    -- Rule configuration
    rule_type moderation_rule_type NOT NULL,
    severity moderation_severity NOT NULL,
    auto_action moderation_action,
    
    -- Rule criteria (regex, keywords, ML model, etc.)
    criteria JSONB NOT NULL,
    
    -- Status
    is_active BOOLEAN DEFAULT TRUE,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER REFERENCES users(id)
);

CREATE TYPE moderation_rule_type AS ENUM ('keyword_filter', 'regex_pattern', 'ml_classifier', 'user_report_threshold');
CREATE TYPE moderation_severity AS ENUM ('low', 'medium', 'high', 'critical');
CREATE TYPE moderation_action AS ENUM ('flag', 'hide', 'delete', 'warn_user', 'suspend_user', 'ban_user');

-- Content moderation queue
CREATE TABLE moderation_queue (
    id SERIAL PRIMARY KEY,
    
    -- Content details
    content_type VARCHAR(50) NOT NULL, -- 'forum_post', 'message', 'user_bio', etc.
    content_id INTEGER NOT NULL,
    content_text TEXT,
    
    -- User and context
    user_id INTEGER NOT NULL REFERENCES users(id),
    
    -- Moderation details
    triggered_rule_id INTEGER REFERENCES moderation_rules(id),
    severity moderation_severity NOT NULL,
    auto_flagged BOOLEAN DEFAULT FALSE,
    
    -- Status
    status moderation_status DEFAULT 'pending',
    reviewed_by INTEGER REFERENCES users(id),
    review_notes TEXT,
    action_taken moderation_action,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reviewed_at TIMESTAMP
);

CREATE TYPE moderation_status AS ENUM ('pending', 'approved', 'rejected', 'escalated');

-- Analytics tracking system
CREATE TABLE analytics_events (
    id SERIAL PRIMARY KEY,
    
    -- Event details
    event_type VARCHAR(100) NOT NULL,
    event_category VARCHAR(50) NOT NULL,
    event_data JSONB,
    
    -- User context
    user_id INTEGER REFERENCES users(id),
    session_id VARCHAR(100),
    
    -- Technical context
    ip_address INET,
    user_agent TEXT,
    referrer TEXT,
    
    -- Timing
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Subscription tiers system
CREATE TABLE subscription_tiers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    description TEXT NOT NULL,
    
    -- Pricing
    price_monthly_cents INTEGER NOT NULL,
    price_yearly_cents INTEGER, -- Annual discount
    
    -- Benefits (JSON for flexibility)
    benefits JSONB NOT NULL,
    
    -- Limits and features
    max_inventory_slots INTEGER DEFAULT 80,
    max_trade_offers INTEGER DEFAULT 10,
    api_rate_limit INTEGER DEFAULT 1000, -- Requests per hour
    
    -- Feature flags
    early_access BOOLEAN DEFAULT FALSE,
    custom_themes BOOLEAN DEFAULT FALSE,
    advanced_analytics BOOLEAN DEFAULT FALSE,
    priority_support BOOLEAN DEFAULT FALSE,
    
    -- Status
    is_active BOOLEAN DEFAULT TRUE,
    sort_order INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User subscriptions
CREATE TABLE user_subscriptions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    tier_id INTEGER NOT NULL REFERENCES subscription_tiers(id),
    
    -- Subscription details
    stripe_subscription_id VARCHAR(100) UNIQUE,
    status subscription_status NOT NULL,
    
    -- Billing cycle
    billing_cycle subscription_cycle NOT NULL,
    current_period_start TIMESTAMP NOT NULL,
    current_period_end TIMESTAMP NOT NULL,
    
    -- Payment tracking
    last_payment_date TIMESTAMP,
    next_payment_date TIMESTAMP,
    
    -- Status changes
    cancelled_at TIMESTAMP,
    cancel_at_period_end BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TYPE subscription_status AS ENUM ('active', 'past_due', 'cancelled', 'unpaid', 'incomplete');
CREATE TYPE subscription_cycle AS ENUM ('monthly', 'yearly');

-- Custom themes system
CREATE TABLE user_themes (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Theme details
    name VARCHAR(50) NOT NULL,
    theme_data JSONB NOT NULL, -- Colors, fonts, layout preferences
    
    -- Status
    is_active BOOLEAN DEFAULT FALSE,
    is_public BOOLEAN DEFAULT FALSE, -- Can other users use this theme?
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Early access features tracking
CREATE TABLE early_access_features (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    
    -- Access control
    min_tier_required INTEGER REFERENCES subscription_tiers(id),
    invited_users_only BOOLEAN DEFAULT FALSE,
    
    -- Feature status
    is_active BOOLEAN DEFAULT TRUE,
    rollout_percentage INTEGER DEFAULT 0, -- Gradual rollout
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    launched_at TIMESTAMP -- When feature became generally available
);

-- User early access permissions
CREATE TABLE user_early_access (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    feature_id INTEGER NOT NULL REFERENCES early_access_features(id),
    
    -- Access details
    granted_by INTEGER REFERENCES users(id), -- Admin who granted access
    access_reason TEXT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id, feature_id)
);

-- Advanced analytics data warehouse tables
CREATE TABLE analytics_user_metrics (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Time period
    metric_date DATE NOT NULL,
    metric_type VARCHAR(50) NOT NULL, -- 'daily', 'weekly', 'monthly'
    
    -- Engagement metrics
    session_count INTEGER DEFAULT 0,
    session_duration_minutes INTEGER DEFAULT 0,
    page_views INTEGER DEFAULT 0,
    
    -- Trading metrics
    trades_initiated INTEGER DEFAULT 0,
    trades_completed INTEGER DEFAULT 0,
    trade_volume_cents INTEGER DEFAULT 0,
    
    -- Collection metrics
    branches_generated INTEGER DEFAULT 0,
    seeds_planted INTEGER DEFAULT 0,
    achievements_unlocked INTEGER DEFAULT 0,
    
    -- Social metrics
    forum_posts INTEGER DEFAULT 0,
    messages_sent INTEGER DEFAULT 0,
    follows_gained INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id, metric_date, metric_type)
);

-- Global platform metrics
CREATE TABLE platform_metrics (
    id SERIAL PRIMARY KEY,
    
    -- Time period
    metric_date DATE NOT NULL,
    metric_type VARCHAR(50) NOT NULL,
    
    -- User metrics
    total_users INTEGER DEFAULT 0,
    active_users INTEGER DEFAULT 0,
    new_signups INTEGER DEFAULT 0,
    
    -- Trading metrics
    total_trades INTEGER DEFAULT 0,
    trade_volume_cents INTEGER DEFAULT 0,
    
    -- Revenue metrics
    subscription_revenue_cents INTEGER DEFAULT 0,
    marketplace_fees_cents INTEGER DEFAULT 0,
    
    -- Content metrics
    forum_posts INTEGER DEFAULT 0,
    olive_branches_generated INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(metric_date, metric_type)
);

-- Site configuration (settings, feature flags, etc.)
CREATE TABLE site_config (
    key VARCHAR(100) PRIMARY KEY,
    value JSONB NOT NULL,
    description TEXT,
    updated_by INTEGER REFERENCES users(id),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for performance (updated with new tables)
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_created_at ON users(created_at);

CREATE INDEX idx_olive_branches_user_id ON olive_branches(user_id);
CREATE INDEX idx_olive_branches_botanical_id ON olive_branches(botanical_id);
CREATE INDEX idx_olive_branches_rarity ON olive_branches(count_rarity, type_rarity);

CREATE INDEX idx_inventory_user_id ON inventory_items(user_id);
CREATE INDEX idx_inventory_type ON inventory_items(item_type);
CREATE INDEX idx_inventory_position ON inventory_items(user_id, grid_position);

CREATE INDEX idx_trades_seller ON trades(seller_id);
CREATE INDEX idx_trades_buyer ON trades(buyer_id);
CREATE INDEX idx_trades_status ON trades(status);
CREATE INDEX idx_trades_created_at ON trades(created_at);

CREATE INDEX idx_payments_user_id ON payments(user_id);
CREATE INDEX idx_payments_stripe_id ON payments(stripe_payment_intent_id);
CREATE INDEX idx_payments_status ON payments(status);

CREATE INDEX idx_forum_posts_thread_id ON forum_posts(thread_id);
CREATE INDEX idx_forum_posts_author ON forum_posts(author_id);
CREATE INDEX idx_forum_threads_category ON forum_threads(category_id);
CREATE INDEX idx_forum_threads_activity ON forum_threads(last_activity_at);

CREATE INDEX idx_messages_participants ON private_messages(sender_id, recipient_id);
CREATE INDEX idx_messages_recipient_unread ON private_messages(recipient_id, is_read);

CREATE INDEX idx_notifications_user_unread ON notifications(user_id, is_read);
CREATE INDEX idx_notifications_created_at ON notifications(created_at);

CREATE INDEX idx_sessions_token ON user_sessions(token_hash);
CREATE INDEX idx_sessions_user_id ON user_sessions(user_id);
CREATE INDEX idx_sessions_expires ON user_sessions(expires_at);

-- New feature indexes
CREATE INDEX idx_user_achievements_user_id ON user_achievements(user_id);
CREATE INDEX idx_user_achievements_completed ON user_achievements(user_id, is_completed);
CREATE INDEX idx_user_follows_follower ON user_follows(follower_id);
CREATE INDEX idx_user_follows_following ON user_follows(following_id);
CREATE INDEX idx_activity_feed_user_id ON activity_feed(user_id);
CREATE INDEX idx_activity_feed_public ON activity_feed(is_public, created_at);
CREATE INDEX idx_activity_feed_type ON activity_feed(activity_type, created_at);
CREATE INDEX idx_user_reviews_reviewed ON user_reviews(reviewed_id);
CREATE INDEX idx_user_reviews_rating ON user_reviews(rating, is_public);
CREATE INDEX idx_daily_logins_user_date ON user_daily_logins(user_id, login_date);
CREATE INDEX idx_leaderboard_entries_rank ON leaderboard_entries(leaderboard_id, rank_position);
CREATE INDEX idx_seasonal_events_active ON seasonal_events(is_active, start_date, end_date);
CREATE INDEX idx_referrals_referrer ON referrals(referrer_id);
CREATE INDEX idx_rate_limits_identifier ON rate_limits(identifier, identifier_type, action);
CREATE INDEX idx_moderation_queue_status ON moderation_queue(status, created_at);
CREATE INDEX idx_analytics_events_type ON analytics_events(event_type, created_at);
CREATE INDEX idx_analytics_events_user ON analytics_events(user_id, created_at);
CREATE INDEX idx_user_subscriptions_status ON user_subscriptions(user_id, status);
CREATE INDEX idx_user_metrics_date ON analytics_user_metrics(user_id, metric_date);
CREATE INDEX idx_platform_metrics_date ON platform_metrics(metric_date, metric_type);

-- Foreign key constraint for active olive branch
ALTER TABLE users ADD CONSTRAINT fk_users_active_branch 
    FOREIGN KEY (active_olive_branch_id) REFERENCES olive_branches(id);

-- Sample data for development (updated with new features)
INSERT INTO site_config (key, value, description) VALUES
('site_name', '"Galway Research Institute"', 'Site display name'),
('registration_enabled', 'true', 'Allow new user registrations'),
('trading_enabled', 'true', 'Enable trading system'),
('forum_enabled', 'true', 'Enable forum features'),
('seed_price_cents', '300', 'Price per seed in cents ($3.00)'),
('max_inventory_slots', '80', 'Maximum inventory slots per user'),
('escrow_auto_release_days', '14', 'Days until escrow auto-releases'),
('email_verification_required', 'true', 'Require email verification for new accounts'),
('daily_rewards_enabled', 'true', 'Enable daily login rewards system'),
('seasonal_events_enabled', 'true', 'Enable seasonal events'),
('leaderboards_enabled', 'true', 'Enable leaderboard system'),
('referral_program_enabled', 'true', 'Enable referral program'),
('two_factor_required', 'false', 'Require 2FA for all users'),
('content_moderation_enabled', 'true', 'Enable automated content moderation'),
('analytics_tracking_enabled', 'true', 'Enable user analytics tracking'),
('subscription_tiers_enabled', 'true', 'Enable subscription system'),
('early_access_enabled', 'true', 'Enable early access features'),
('custom_themes_enabled', 'true', 'Enable custom user themes');

-- Initial forum categories
INSERT INTO forum_categories (name, description, sort_order) VALUES
('General Discussion', 'General community discussions', 1),
('Research & Development', 'Technical discussions about our research', 2),
('Trading Post', 'Buy, sell, and trade olive branches and seeds', 3),
('Achievements & Leaderboards', 'Share your accomplishments and compete', 4),
('Seasonal Events', 'Discussion about current and upcoming events', 5),
('Bug Reports', 'Report technical issues', 6),
('Feature Requests', 'Suggest new features and improvements', 7),
('Announcements', 'Official announcements from the Institute', 8);

-- Sample achievements
INSERT INTO achievements (name, description, badge_icon, category, criteria, reward_type, reward_value) VALUES
('First Steps', 'Generate your first olive branch', '🌱', 'collector', '{"branches_generated": 1}', 'seeds', 1),
('Green Thumb', 'Generate 10 olive branches', '🌿', 'collector', '{"branches_generated": 10}', 'seeds', 5),
('Rare Find', 'Generate a rare olive branch', '💎', 'collector', '{"rare_branch_found": true}', 'seeds', 3),
('Social Butterfly', 'Follow 10 other users', '🦋', 'social', '{"follows_made": 10}', 'seeds', 2),
('Trade Master', 'Complete 25 successful trades', '🤝', 'trader', '{"trades_completed": 25}', 'seeds', 10),
('Daily Dedication', 'Login for 30 consecutive days', '📅', 'collector', '{"login_streak": 30}', 'seeds', 15),
('Forum Regular', 'Make 100 forum posts', '💬', 'social', '{"forum_posts": 100}', 'badge_only', 0),
('Collector Supreme', 'Own 50 olive branches', '👑', 'collector', '{"total_branches": 50}', 'early_access', 0);

-- Sample subscription tiers
INSERT INTO subscription_tiers (name, description, price_monthly_cents, price_yearly_cents, benefits, max_inventory_slots, max_trade_offers, early_access, custom_themes, advanced_analytics, priority_support) VALUES
('Basic', 'Essential features for casual collectors', 0, 0, '["Basic inventory", "Standard trading", "Forum access"]', 80, 5, false, false, false, false),
('Premium', 'Enhanced features for serious collectors', 999, 9999, '["Expanded inventory", "Priority trading", "Custom themes", "Advanced analytics"]', 160, 20, false, true, true, false),
('Elite', 'Full access for professional traders', 1999, 19999, '["Maximum inventory", "Unlimited trading", "Early access", "Priority support", "Exclusive events"]', 320, 50, true, true, true, true);

-- Sample daily rewards
INSERT INTO daily_rewards (day_number, reward_type, reward_amount, is_bonus_day, bonus_multiplier) VALUES
(1, 'seeds', 1, false, 1.0),
(2, 'seeds', 1, false, 1.0),
(3, 'seeds', 2, false, 1.0),
(4, 'seeds', 2, false, 1.0),
(5, 'seeds', 3, false, 1.0),
(6, 'seeds', 3, false, 1.0),
(7, 'seeds', 5, true, 2.0), -- Bonus Sunday
(8, 'seeds', 2, false, 1.0),
(9, 'seeds', 2, false, 1.0),
(10, 'seeds', 3, false, 1.0),
(14, 'seeds', 10, true, 2.0), -- Two week bonus
(21, 'seeds', 15, true, 2.0), -- Three week bonus
(30, 'seeds', 25, true, 3.0); -- Monthly bonus

-- Sample leaderboards
INSERT INTO leaderboards (name, description, category, scoring_method, time_period, is_featured) VALUES
('Top Collectors', 'Users with the most olive branches', 'collector', 'total_branches', 'all_time', true),
('Weekly Traders', 'Most active traders this week', 'trader', 'trades_completed', 'weekly', true),
('Monthly Points', 'Highest point earners this month', 'collector', 'total_points', 'monthly', false),
('Seasonal Champions', 'Current seasonal event leaders', 'seasonal', 'event_points', 'seasonal', true),
('Forum Contributors', 'Most helpful forum members', 'forum', 'helpful_posts', 'monthly', false);

-- Sample moderation rules
INSERT INTO moderation_rules (name, description, rule_type, severity, auto_action, criteria) VALUES
('Spam Filter', 'Detect spam and promotional content', 'keyword_filter', 'medium', 'flag', '{"keywords": ["buy now", "click here", "limited time", "free money"]}'),
('Profanity Filter', 'Filter inappropriate language', 'keyword_filter', 'high', 'hide', '{"keywords": ["censored", "words", "list"]}'),
('Scam Detection', 'Detect potential scam attempts', 'ml_classifier', 'critical', 'delete', '{"model": "scam_detection_v1", "threshold": 0.8}'),
('Report Threshold', 'Auto-hide content with multiple reports', 'user_report_threshold', 'high', 'hide', '{"report_count": 3, "time_window": "24h"}');

-- Sample early access features
INSERT INTO early_access_features (name, description, min_tier_required, rollout_percentage) VALUES
('Advanced Trading Dashboard', 'Enhanced trading interface with analytics', 2, 50),
('AI Branch Recommendations', 'Machine learning powered collection suggestions', 3, 25),
('Custom Rarity Filters', 'Advanced filtering options for rare items', 2, 75),
('Social Trading Groups', 'Create and join trading communities', 2, 10);

// === END raw-schema.sql ===

// === README.md ===
# galway-backend
Backend API for Galway Research - Handles data processing, authentication, and database operations

// === END README.md ===

// === test-db-connection.js ===
// test-db-connection.js
// Run this to verify your Digital Ocean database connection

require('dotenv').config();
const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient({
  log: ['info', 'warn', 'error'],
});

async function testConnection() {
  try {
    console.log('🔄 Testing database connection...');
    console.log('📍 Connecting to Digital Ocean PostgreSQL...');
    
    // Test basic connection
    await prisma.$connect();
    console.log('✅ Successfully connected to Digital Ocean PostgreSQL');
    
    // Test a simple query
    const result = await prisma.$queryRaw`SELECT version()`;
    console.log('📊 Database version:', result[0].version);
    
    // Check current database name
    const dbInfo = await prisma.$queryRaw`SELECT current_database()`;
    console.log('🗄️  Connected to database:', dbInfo[0].current_database);
    
    // Check if we can introspect the database
    const tables = await prisma.$queryRaw`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public'
    `;
    
    if (tables.length === 0) {
      console.log('⚠️  No tables found - ready for initial migration');
    } else {
      console.log('📋 Existing tables:', tables.map(t => t.table_name).join(', '));
    }
    
    console.log('✅ Database connection test completed successfully!');
    console.log('🚀 Ready to run: npx prisma db push');
    
  } catch (error) {
    console.error('❌ Database connection failed:');
    console.error('Error:', error.message);
    
    if (error.message.includes('ENOTFOUND')) {
      console.error('💡 Check your host URL and internet connection');
    } else if (error.message.includes('authentication')) {
      console.error('💡 Check your username and password in .env file');
    } else if (error.message.includes('SSL') || error.message.includes('ssl')) {
      console.error('💡 SSL connection issue - ensure sslmode=require in connection string');
    } else if (error.message.includes('timeout')) {
      console.error('💡 Connection timeout - check firewall/trusted sources in Digital Ocean');
    }
    
    console.error('\n🔧 Your DATABASE_URL should look like:');
    console.error('DATABASE_URL="postgresql://doadmin:PASSWORD@HOST:25060/defaultdb?sslmode=require"');
    
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

// Run the test
testConnection();

// === END test-db-connection.js ===


============================================================
DIRECTORY: prisma
============================================================

// === prisma/seed-ecommerce.js ===
// prisma/seed-ecommerce.js
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

async function main() {
  console.log('🌱 Seeding e-commerce data...');

  // Create store categories
  const physicalCategory = await prisma.store_categories.upsert({
    where: { slug: 'merchandise' },
    update: {},
    create: {
      name: 'Merchandise',
      slug: 'merchandise',
      description: 'Physical merchandise and branded items',
      item_type: 'physical',
      display_order: 1,
      is_active: true
    }
  });

  const digitalCategory = await prisma.store_categories.upsert({
    where: { slug: 'digital-content' },
    update: {},
    create: {
      name: 'Digital Content',
      slug: 'digital-content',
      description: 'Digital downloads and virtual items',
      item_type: 'digital',
      display_order: 2,
      is_active: true
    }
  });

  const accessoriesCategory = await prisma.store_categories.upsert({
    where: { slug: 'accessories' },
    update: {},
    create: {
      name: 'Accessories',
      slug: 'accessories',
      description: 'Small accessories and add-ons',
      item_type: 'physical',
      display_order: 3,
      is_active: true,
      parent_id: physicalCategory.id
    }
  });

  console.log('✅ Categories created');

  // Create sample physical products
  const tshirt = await prisma.store_items.upsert({
    where: { slug: 'galway-institute-t-shirt' },
    update: {},
    create: {
      name: 'Galway Institute T-Shirt',
      slug: 'galway-institute-t-shirt',
      description: 'High-quality cotton t-shirt with the Galway Research Institute logo. Perfect for showing your support!',
      short_description: 'Official GRI cotton t-shirt with logo',
      category_id: physicalCategory.id,
      item_type: 'physical',
      price_cents: 2999, // $29.99 CAD
      compare_at_price_cents: 3999, // Show as on sale from $39.99
      weight_grams: 200,
      requires_shipping: true,
      manage_inventory: true,
      stock_quantity: 100,
      low_stock_threshold: 10,
      allow_backorder: false,
      meta_title: 'Official Galway Institute T-Shirt - Premium Cotton',
      meta_description: 'Show your support with our official GRI t-shirt. Made from premium cotton.',
      images: [
        'https://example.com/images/tshirt-front.jpg',
        'https://example.com/images/tshirt-back.jpg'
      ],
      featured_image: 'https://example.com/images/tshirt-front.jpg',
      is_active: true,
      is_featured: true,
      published_at: new Date()
    }
  });

  // Create variants for t-shirt (sizes and colors)
  const tshirtVariants = [
    { name: 'Small Black', options: { size: 'S', color: 'Black' }, stock_quantity: 25 },
    { name: 'Medium Black', options: { size: 'M', color: 'Black' }, stock_quantity: 30 },
    { name: 'Large Black', options: { size: 'L', color: 'Black' }, stock_quantity: 25 },
    { name: 'XL Black', options: { size: 'XL', color: 'Black' }, stock_quantity: 15 },
    { name: 'Small Navy', options: { size: 'S', color: 'Navy' }, stock_quantity: 20 },
    { name: 'Medium Navy', options: { size: 'M', color: 'Navy' }, stock_quantity: 25 },
    { name: 'Large Navy', options: { size: 'L', color: 'Navy' }, stock_quantity: 20 },
    { name: 'XL Navy', options: { size: 'XL', color: 'Navy' }, stock_quantity: 10 }
  ];

  for (const variant of tshirtVariants) {
    await prisma.store_item_variants.upsert({
      where: {
        item_id_name: {
          item_id: tshirt.id,
          name: variant.name
        }
      },
      update: {},
      create: {
        item_id: tshirt.id,
        name: variant.name,
        sku: `TSHIRT-${variant.options.size}-${variant.options.color.toUpperCase()}`,
        options: variant.options,
        stock_quantity: variant.stock_quantity,
        weight_grams: 200,
        is_active: true
      }
    });
  }

  // Create sample stickers
  const stickers = await prisma.store_items.upsert({
    where: { slug: 'galway-institute-sticker-pack' },
    update: {},
    create: {
      name: 'Galway Institute Sticker Pack',
      slug: 'galway-institute-sticker-pack',
      description: 'A pack of 5 high-quality vinyl stickers featuring various Galway Research Institute designs. Weather-resistant and perfect for laptops, water bottles, and more!',
      short_description: 'Pack of 5 weather-resistant vinyl stickers',
      category_id: accessoriesCategory.id,
      item_type: 'physical',
      price_cents: 899, // $8.99 CAD
      weight_grams: 50,
      requires_shipping: true,
      manage_inventory: true,
      stock_quantity: 500,
      low_stock_threshold: 50,
      allow_backorder: true,
      featured_image: 'https://example.com/images/sticker-pack.jpg',
      is_active: true,
      published_at: new Date()
    }
  });

  // Create sample digital products
  const digitalGuide = await prisma.store_items.upsert({
    where: { slug: 'olive-branch-cultivation-guide' },
    update: {},
    create: {
      name: 'Olive Branch Cultivation Guide',
      slug: 'olive-branch-cultivation-guide',
      description: 'A comprehensive digital guide covering everything you need to know about cultivating and caring for olive branches. Includes exclusive tips from our research team and detailed illustrations.',
      short_description: 'Complete digital guide to olive branch cultivation',
      category_id: digitalCategory.id,
      item_type: 'digital',
      price_cents: 1999, // $19.99 CAD
      requires_shipping: false,
      download_url: '/downloads/olive-guide.pdf',
      download_limit: 5,
      access_duration_days: 365, // Access for 1 year
      manage_inventory: false,
      featured_image: 'https://example.com/images/olive-guide-cover.jpg',
      is_active: true,
      is_featured: true,
      published_at: new Date()
    }
  });

  const researchPaper = await prisma.store_items.upsert({
    where: { slug: 'advanced-botanical-research-collection' },
    update: {},
    create: {
      name: 'Advanced Botanical Research Collection',
      slug: 'advanced-botanical-research-collection',
      description: 'Access to our exclusive collection of advanced botanical research papers. Includes 50+ research documents, case studies, and experimental data from the Galway Research Institute.',
      short_description: 'Exclusive collection of 50+ research papers',
      category_id: digitalCategory.id,
      item_type: 'digital',
      price_cents: 4999, // $49.99 CAD
      requires_shipping: false,
      download_limit: 10,
      access_duration_days: null, // Lifetime access
      manage_inventory: false,
      featured_image: 'https://example.com/images/research-collection.jpg',
      is_active: true,
      published_at: new Date()
    }
  });

  console.log('✅ Store items created');

  // Create sample coupons
  const welcomeCoupon = await prisma.coupons.upsert({
    where: { code: 'WELCOME10' },
    update: {},
    create: {
      code: 'WELCOME10',
      name: 'Welcome 10% Off',
      description: 'Welcome discount for new customers',
      discount_type: 'percentage',
      discount_value: 10,
      usage_limit: 1000,
      usage_limit_per_customer: 1,
      minimum_amount_cents: 1000, // Minimum $10.00 order
      maximum_discount_cents: 2000, // Max $20.00 discount
      starts_at: new Date(),
      expires_at: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days from now
      is_active: true,
      created_by: 1 // Assuming admin user ID 1 exists
    }
  });

  const freeShippingCoupon = await prisma.coupons.upsert({
    where: { code: 'FREESHIP' },
    update: {},
    create: {
      code: 'FREESHIP',
      name: 'Free Shipping',
      description: 'Free shipping on orders over $25',
      discount_type: 'free_shipping',
      discount_value: 0,
      usage_limit: null, // Unlimited usage
      usage_limit_per_customer: null,
      minimum_amount_cents: 2500, // Minimum $25.00 order
      is_active: true,
      created_by: 1
    }
  });

  const holidayCoupon = await prisma.coupons.upsert({
    where: { code: 'HOLIDAY2025' },
    update: {},
    create: {
      code: 'HOLIDAY2025',
      name: 'Holiday Special 2025',
      description: 'Special holiday discount - $15 off orders over $50',
      discount_type: 'fixed_amount',
      discount_value: 1500, // $15.00 off
      usage_limit: 500,
      usage_limit_per_customer: 2,
      minimum_amount_cents: 5000, // Minimum $50.00 order
      starts_at: new Date('2025-12-01'),
      expires_at: new Date('2025-12-31'),
      is_active: true,
      created_by: 1
    }
  });

  console.log('✅ Coupons created');

  // Create coupon restrictions (holiday coupon only applies to physical items)
  await prisma.coupon_items.createMany({
    data: [
      { coupon_id: holidayCoupon.id, item_id: tshirt.id },
      { coupon_id: holidayCoupon.id, item_id: stickers.id }
    ],
    skipDuplicates: true
  });

  console.log('✅ Coupon restrictions created');

  // Update existing PaymentType enum in the database if needed
  // This would typically be done through a migration, but for seed data:
  try {
    await prisma.$executeRaw`
      DO $ 
      BEGIN
        -- Add new payment types if they don't exist
        IF NOT EXISTS (SELECT 1 FROM unnest(enum_range(NULL::PaymentType)) AS val WHERE val = 'store_purchase') THEN
          ALTER TYPE PaymentType ADD VALUE 'store_purchase';
        END IF;
        
        IF NOT EXISTS (SELECT 1 FROM unnest(enum_range(NULL::PaymentType)) AS val WHERE val = 'subscription_donation') THEN
          ALTER TYPE PaymentType ADD VALUE 'subscription_donation';
        END IF;
      END $;
    `;
    console.log('✅ PaymentType enum updated');
  } catch (error) {
    console.log('ℹ️ PaymentType enum values already exist or update not needed');
  }

  console.log('🎉 E-commerce seed data created successfully!');
  console.log('\n📊 Summary:');
  console.log(`• ${await prisma.store_categories.count()} categories created`);
  console.log(`• ${await prisma.store_items.count()} items created`);
  console.log(`• ${await prisma.store_item_variants.count()} variants created`);
  console.log(`• ${await prisma.coupons.count()} coupons created`);
  
  console.log('\n🛍️ Sample products available:');
  console.log('• Galway Institute T-Shirt ($29.99) - with size/color variants');
  console.log('• Sticker Pack ($8.99) - physical item');
  console.log('• Olive Branch Guide ($19.99) - digital download');
  console.log('• Research Collection ($49.99) - digital download');
  
  console.log('\n🎫 Coupons available:');
  console.log('• WELCOME10 - 10% off for new customers');
  console.log('• FREESHIP - Free shipping on orders over $25');
  console.log('• HOLIDAY2025 - $15 off orders over $50 (physical items only)');

  console.log('\n🚀 Ready to test the store!');
  console.log('Test endpoints:');
  console.log('• GET /api/store/categories');
  console.log('• GET /api/store/items');
  console.log('• GET /api/store/items/galway-institute-t-shirt');
  console.log('• POST /api/store/cart/add (authenticated)');
}

main()
  .catch((e) => {
    console.error('❌ Error seeding data:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

// === END prisma/seed-ecommerce.js ===

// === prisma/seed.js ===
// prisma/seed.js
// Initial data for Galway Research Institute

const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

async function main() {
  console.log('🌱 Seeding database...');

  // Site Configuration
  const siteConfigs = [
    { key: 'site_name', value: 'Galway Research Institute', description: 'Site display name' },
    { key: 'registration_enabled', value: true, description: 'Allow new user registrations' },
    { key: 'trading_enabled', value: true, description: 'Enable trading system' },
    { key: 'forum_enabled', value: true, description: 'Enable forum features' },
    { key: 'seed_price_cents', value: 300, description: 'Price per seed in cents ($3.00)' },
    { key: 'max_inventory_slots', value: 80, description: 'Maximum inventory slots per user' },
    { key: 'escrow_auto_release_days', value: 14, description: 'Days until escrow auto-releases' },
    { key: 'email_verification_required', value: true, description: 'Require email verification' },
    { key: 'daily_rewards_enabled', value: true, description: 'Enable daily login rewards' },
    { key: 'two_factor_required', value: false, description: 'Require 2FA for all users' },
  ];

  for (const config of siteConfigs) {
    await prisma.siteConfig.upsert({
      where: { key: config.key },
      update: { value: config.value },
      create: config,
    });
  }

  // Forum Categories - use createMany or individual creates since no unique name constraint
  const existingCategories = await prisma.forumCategory.findMany();
  if (existingCategories.length === 0) {
    await prisma.forumCategory.createMany({
      data: [
        { name: 'General Discussion', description: 'General community discussions', sortOrder: 1 },
        { name: 'Research & Development', description: 'Technical discussions about our research', sortOrder: 2 },
        { name: 'Trading Post', description: 'Buy, sell, and trade olive branches and seeds', sortOrder: 3 },
        { name: 'Achievements & Leaderboards', description: 'Share your accomplishments', sortOrder: 4 },
        { name: 'Seasonal Events', description: 'Discussion about current and upcoming events', sortOrder: 5 },
        { name: 'Bug Reports', description: 'Report technical issues', sortOrder: 6 },
        { name: 'Feature Requests', description: 'Suggest new features and improvements', sortOrder: 7 },
        { name: 'Announcements', description: 'Official announcements', sortOrder: 8, minRoleToPost: 'moderator' },
      ]
    });
  }

  // Subscription Tiers - use name for upsert since it should be unique
  const subscriptionTiers = [
    {
      name: 'Basic',
      description: 'Essential features for casual collectors',
      priceMonthlycents: 0,
      priceYearlyCents: 0,
      benefits: ['Basic inventory', 'Standard trading', 'Forum access'],
      maxInventorySlots: 80,
      maxTradeOffers: 5,
      earlyAccess: false,
      customThemes: false,
      advancedAnalytics: false,
      prioritySupport: false,
    },
    {
      name: 'Premium',
      description: 'Enhanced features for serious collectors',
      priceMonthlycents: 999,
      priceYearlyCents: 9999,
      benefits: ['Expanded inventory', 'Priority trading', 'Custom themes', 'Advanced analytics'],
      maxInventorySlots: 160,
      maxTradeOffers: 20,
      earlyAccess: false,
      customThemes: true,
      advancedAnalytics: true,
      prioritySupport: false,
    },
    {
      name: 'Elite',
      description: 'Full access for professional traders',
      priceMonthlycents: 1999,
      priceYearlyCents: 19999,
      benefits: ['Maximum inventory', 'Unlimited trading', 'Early access', 'Priority support'],
      maxInventorySlots: 320,
      maxTradeOffers: 50,
      earlyAccess: true,
      customThemes: true,
      advancedAnalytics: true,
      prioritySupport: true,
    },
  ];

  // Create subscription tiers individually to handle potential conflicts
  for (const tier of subscriptionTiers) {
    try {
      await prisma.subscriptionTier.create({
        data: tier,
      });
    } catch (error) {
      if (error.code === 'P2002') {
        console.log(`⚠️  Subscription tier "${tier.name}" already exists, skipping...`);
      } else {
        throw error;
      }
    }
  }

  // Sample Achievements - use name for upsert
  const achievements = [
    {
      name: 'First Steps',
      description: 'Generate your first olive branch',
      badgeIcon: '🌱',
      category: 'collector',
      criteria: { branches_generated: 1 },
      rewardType: 'seeds',
      rewardValue: 1,
    },
    {
      name: 'Green Thumb',
      description: 'Generate 10 olive branches',
      badgeIcon: '🌿',
      category: 'collector',
      criteria: { branches_generated: 10 },
      rewardType: 'seeds',
      rewardValue: 5,
    },
    {
      name: 'Rare Find',
      description: 'Generate a rare olive branch',
      badgeIcon: '💎',
      category: 'collector',
      criteria: { rare_branch_found: true },
      rewardType: 'seeds',
      rewardValue: 3,
    },
    {
      name: 'Social Butterfly',
      description: 'Follow 10 other users',
      badgeIcon: '🦋',
      category: 'social',
      criteria: { follows_made: 10 },
      rewardType: 'seeds',
      rewardValue: 2,
    },
    {
      name: 'Trade Master',
      description: 'Complete 25 successful trades',
      badgeIcon: '🤝',
      category: 'trader',
      criteria: { trades_completed: 25 },
      rewardType: 'seeds',
      rewardValue: 10,
    },
    {
      name: 'Daily Dedication',
      description: 'Login for 30 consecutive days',
      badgeIcon: '📅',
      category: 'collector',
      criteria: { login_streak: 30 },
      rewardType: 'seeds',
      rewardValue: 15,
    },
  ];

  // Create achievements individually
  for (const achievement of achievements) {
    try {
      await prisma.achievement.create({
        data: achievement,
      });
    } catch (error) {
      if (error.code === 'P2002') {
        console.log(`⚠️  Achievement "${achievement.name}" already exists, skipping...`);
      } else {
        throw error;
      }
    }
  }

  // Daily Rewards - create individually since dayNumber may not be unique
  const dailyRewards = [
    { dayNumber: 1, rewardType: 'seeds', rewardAmount: 1 },
    { dayNumber: 2, rewardType: 'seeds', rewardAmount: 1 },
    { dayNumber: 3, rewardType: 'seeds', rewardAmount: 2 },
    { dayNumber: 7, rewardType: 'seeds', rewardAmount: 5, isBonusDay: true, bonusMultiplier: 2.0 },
    { dayNumber: 14, rewardType: 'seeds', rewardAmount: 10, isBonusDay: true, bonusMultiplier: 2.0 },
    { dayNumber: 30, rewardType: 'seeds', rewardAmount: 25, isBonusDay: true, bonusMultiplier: 3.0 },
  ];

  const existingRewards = await prisma.dailyReward.findMany();
  if (existingRewards.length === 0) {
    await prisma.dailyReward.createMany({
      data: dailyRewards,
    });
  }

  // Sample Leaderboards
  const leaderboards = [
    {
      name: 'Top Collectors',
      description: 'Users with the most olive branches',
      category: 'collector',
      scoringMethod: 'total_branches',
      timePeriod: 'all_time',
      isFeatured: true,
    },
    {
      name: 'Weekly Traders',
      description: 'Most active traders this week',
      category: 'trader',
      scoringMethod: 'trades_completed',
      timePeriod: 'weekly',
      isFeatured: true,
    },
    {
      name: 'Monthly Points',
      description: 'Highest point earners this month',
      category: 'collector',
      scoringMethod: 'total_points',
      timePeriod: 'monthly',
      isFeatured: false,
    },
  ];

  // Create leaderboards individually
  for (const leaderboard of leaderboards) {
    try {
      await prisma.leaderboard.create({
        data: leaderboard,
      });
    } catch (error) {
      if (error.code === 'P2002') {
        console.log(`⚠️  Leaderboard "${leaderboard.name}" already exists, skipping...`);
      } else {
        throw error;
      }
    }
  }

  console.log('✅ Database seeded successfully!');
  console.log('📊 Created/Updated:');
  console.log(`   - ${siteConfigs.length} site configuration entries`);
  console.log(`   - 8 forum categories`);
  console.log(`   - ${subscriptionTiers.length} subscription tiers`);
  console.log(`   - ${achievements.length} achievements`);
  console.log(`   - ${dailyRewards.length} daily rewards`);
  console.log(`   - ${leaderboards.length} leaderboards`);
}

main()
  .catch((e) => {
    console.error('❌ Seeding failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

// === END prisma/seed.js ===


============================================================
DIRECTORY: src
============================================================

// === src/server.js ===
// server.js - Updated Integration with Phase 4: E-Commerce System + Forum System
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const compression = require('compression');
const morgan = require('morgan');

// Import enhanced middleware
const { errorHandler, requestIdMiddleware } = require('./middleware/errorHandler');
const AuthMiddleware = require('./middleware/auth');

// Import routes
const authRoutes = require('./routes/auth');
const oliveBranchRoutes = require('./routes/oliveBranches');
const registrationBranchRoutes = require('./routes/registrationBranches');
const idCardRoutes = require('./routes/idCards');
const userRoutes = require('./routes/users'); // Phase 2: Enhanced user management
const searchRoutes = require('./routes/search'); // Phase 2: Advanced search
const inventoryRoutes = require('./routes/inventory'); // Phase 2: Inventory system
const leaderboardRoutes = require('./routes/leaderboards'); // Phase 3: Leaderboards
const achievementRoutes = require('./routes/achievements'); // Phase 3: Achievements

// PHASE 4 ROUTES - E-COMMERCE SYSTEM
const storeRoutes = require('./routes/store'); // Main store routes
const webhookRoutes = require('./routes/webhooks'); // Stripe webhooks
const adminStoreRoutes = require('./routes/store'); // Admin store management

// PHASE 4 ROUTES - FORUM SYSTEM (NEW)
const forumRoutes = require('./routes/forum'); // Forum system

console.log('🔍 Registration routes loaded:', typeof registrationBranchRoutes);
console.log('🆔 ID Card routes loaded:', typeof idCardRoutes);
console.log('👥 Enhanced User routes loaded:', typeof userRoutes);
console.log('🔍 Advanced Search routes loaded:', typeof searchRoutes);
console.log('🎒 Inventory routes loaded:', typeof inventoryRoutes);
console.log('🏆 Leaderboards routes loaded:', typeof leaderboardRoutes);
console.log('🎯 Achievements routes loaded:', typeof achievementRoutes);
console.log('🛍️ Store routes loaded:', typeof storeRoutes);
console.log('🔗 Webhook routes loaded:', typeof webhookRoutes);
console.log('⚙️ Admin Store routes loaded:', typeof adminStoreRoutes);
console.log('💬 Forum routes loaded:', typeof forumRoutes); // NEW

const app = express();
const PORT = process.env.PORT || 3000;

// Request ID middleware (must be first)
app.use(requestIdMiddleware);

// Security middleware with enhanced CSP
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      scriptSrc: ["'self'", "https://js.stripe.com"], // Allow Stripe JS
      imgSrc: ["'self'", "data:", "https:"],
      fontSrc: ["'self'", "https://fonts.googleapis.com", "https://fonts.gstatic.com"],
      connectSrc: ["'self'", "https://api.stripe.com"], // Allow Stripe API
      frameSrc: ["https://js.stripe.com", "https://hooks.stripe.com"], // Allow Stripe frames
    },
  },
}));

// CORS configuration
app.use(cors({
  origin: process.env.CORS_ORIGIN || 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID'],
}));

// Enhanced rate limiting with different tiers
const createRateLimit = (windowMs, max, message) => rateLimit({
  windowMs,
  max,
  message: { error: message, code: 'RATE_LIMIT_EXCEEDED' },
  standardHeaders: true,
  legacyHeaders: false,
});

// Different rate limits for different endpoint types
const generalRateLimit = createRateLimit(15 * 60 * 1000, 100, 'Too many requests from this IP');
const authRateLimit = createRateLimit(15 * 60 * 1000, 20, 'Too many authentication attempts');
const searchRateLimit = createRateLimit(60 * 1000, 30, 'Too many search requests');
const leaderboardRateLimit = createRateLimit(60 * 1000, 60, 'Too many leaderboard requests');
const storeRateLimit = createRateLimit(60 * 1000, 100, 'Too many store requests');
const checkoutRateLimit = createRateLimit(15 * 60 * 1000, 10, 'Too many checkout attempts');
const forumRateLimit = createRateLimit(60 * 1000, 50, 'Too many forum requests'); // NEW

// Apply rate limits to specific routes
app.use('/api/auth', authRateLimit);
app.use('/api/search', searchRateLimit);
app.use('/api/leaderboards', leaderboardRateLimit);
app.use('/api/achievements', searchRateLimit);
app.use('/api/store', storeRateLimit);
app.use('/api/store/checkout', checkoutRateLimit); // Stricter rate limit for checkout
app.use('/api/forum', forumRateLimit); // NEW

// Webhook routes BEFORE body parsing middleware (Stripe needs raw body)
app.use('/api/webhooks', webhookRoutes);

app.use(generalRateLimit); // General rate limit for all other routes

// Body parsing middleware (after webhooks to allow raw body for Stripe)
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Compression and logging
app.use(compression());
if (process.env.NODE_ENV === 'production') {
  app.use(morgan('combined'));
} else {
  app.use(morgan('dev'));
}

// Serve static files for forum uploads
app.use('/uploads', express.static('uploads'));

// Health check endpoint with enhanced system status
app.get('/health', async (req, res) => {
  const { PrismaClient } = require('@prisma/client');
  const prisma = new PrismaClient();

  let dbStatus = 'unknown';
  let dbLatency = null;
  let stripeStatus = 'unknown';

  try {
    const start = Date.now();
    await prisma.users.findFirst({ select: { id: true } });
    dbLatency = Date.now() - start;
    dbStatus = 'healthy';
  } catch (error) {
    dbStatus = 'unhealthy';
  } finally {
    await prisma.$disconnect();
  }

  // Check Stripe connection
  try {
    const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
    await stripe.accounts.retrieve();
    stripeStatus = 'healthy';
  } catch (error) {
    stripeStatus = 'unhealthy';
  }

  const healthData = {
    status: dbStatus === 'healthy' && stripeStatus === 'healthy' ? 'healthy' : 'degraded',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV,
    version: process.env.npm_package_version || '4.0.0', // Updated version
    services: {
      database: {
        status: dbStatus,
        latency: dbLatency ? `${dbLatency}ms` : null
      },
      stripe: {
        status: stripeStatus
      },
      api: {
        status: 'healthy',
        features: {
          authentication: 'operational',
          userManagement: 'operational',
          searchSystem: 'operational',
          inventorySystem: 'operational',
          leaderboards: 'operational',
          achievements: 'operational',
          ecommerce: 'operational',
          paymentProcessing: stripeStatus,
          forumSystem: 'operational', // NEW
          oliveBranches: 'operational',
          idCardGeneration: 'operational'
        }
      }
    }
  };

  res.status(dbStatus === 'healthy' && stripeStatus === 'healthy' ? 200 : 503).json(healthData);
});

// API version endpoint with comprehensive feature list
app.get('/api', (req, res) => {
  res.json({
    message: 'Galway Research Institute API',
    version: '4.0.0', // Updated to reflect Phase 4 completion
    documentation: '/api/docs',
    status: 'operational',
    features: {
      authentication: {
        jwt: true,
        refreshTokens: true,
        roleBasedAccess: true,
        permissions: true
      },
      userManagement: {
        profiles: true,
        statusTracking: true,
        activityMonitoring: true,
        bulkOperations: true
      },
      searchSystem: {
        advancedFiltering: true,
        realTimeSuggestions: true,
        multiCriteria: true,
        performantIndexing: true
      },
      inventorySystem: {
        dragAndDropReorder: true,
        autoOrganization: true,
        valueCalculation: true,
        typeSpecificHandling: true
      },
      leaderboards: {
        multiCategory: true,
        timePeriods: true,
        userRankings: true,
        realTimeUpdates: true
      },
      achievements: {
        progressTracking: true,
        rewardSystem: true,
        badgeSystem: true,
        categorization: true
      },
      ecommerce: {
        storeManagement: true,
        shoppingCart: true,
        orderProcessing: true,
        paymentIntegration: true,
        inventoryTracking: true,
        couponSystem: true,
        digitalDelivery: true,
        adminDashboard: true
      },
      forumSystem: { // NEW
        categories: true,
        threadManagement: true,
        postReplies: true,
        contentModeration: true,
        fileAttachments: true,
        studyVerification: true,
        upvoteSystem: true,
        moderationTools: true
      },
      oliveBranches: {
        generation: true,
        tradingSupport: true,
        raritySystem: true,
        svgRendering: true
      }
    },
    endpoints: {
      authentication: '/api/auth',
      users: '/api/users',
      search: '/api/search',
      inventory: '/api/inventory',
      leaderboards: '/api/leaderboards',
      achievements: '/api/achievements',
      store: '/api/store',
      admin: '/api/admin/store',
      webhooks: '/api/webhooks',
      forum: '/api/forum', // NEW
      oliveBranches: '/api/olive-branches',
      registration: '/api/registration',
      idCards: '/api/id-cards'
    }
  });
});

// API Routes with version prefix
const API_BASE = '/api/v1';

// Core system routes
app.use('/api/auth', authRoutes);
app.use(`${API_BASE}/users`, userRoutes);
app.use(`${API_BASE}/search`, searchRoutes);
app.use(`${API_BASE}/inventory`, inventoryRoutes);

// Phase 3 routes
app.use('/api/leaderboards', leaderboardRoutes);
app.use('/api/achievements', achievementRoutes);
app.use(`${API_BASE}/leaderboards`, leaderboardRoutes);
app.use(`${API_BASE}/achievements`, achievementRoutes);

// PHASE 4 ROUTES - E-COMMERCE SYSTEM
app.use('/api/store', storeRoutes); // Public store routes
app.use(`${API_BASE}/store`, storeRoutes); // Versioned store routes
app.use('/api/admin/store', adminStoreRoutes); // Admin store management
app.use(`${API_BASE}/admin/store`, adminStoreRoutes); // Versioned admin store management

// PHASE 4 ROUTES - FORUM SYSTEM (NEW)
app.use('/api/forum', forumRoutes); // Main forum routes
app.use(`${API_BASE}/forum`, forumRoutes); // Versioned forum routes

// Existing routes (maintained for compatibility)
app.use('/api/olive-branches', oliveBranchRoutes);
app.use('/api/registration', registrationBranchRoutes);
app.use('/api/id-cards', idCardRoutes);

// Legacy route aliases for backward compatibility
app.use('/api/users', userRoutes);
app.use('/api/search', searchRoutes);
app.use('/api/inventory', inventoryRoutes);

console.log('🔍 Registration routes mounted at /api/registration');
console.log('🆔 ID Card routes mounted at /api/id-cards');
console.log('👥 User routes mounted at /api/v1/users and /api/users');
console.log('🔍 Search routes mounted at /api/v1/search and /api/search');
console.log('🎒 Inventory routes mounted at /api/v1/inventory and /api/inventory');
console.log('🏆 Leaderboards routes mounted at /api/leaderboards and /api/v1/leaderboards');
console.log('🎯 Achievements routes mounted at /api/achievements and /api/v1/achievements');
console.log('🛍️ Store routes mounted at /api/store and /api/v1/store');
console.log('⚙️ Admin Store routes mounted at /api/admin/store and /api/v1/admin/store');
console.log('🔗 Webhook routes mounted at /api/webhooks');
console.log('💬 Forum routes mounted at /api/forum and /api/v1/forum'); // NEW

// Enhanced system status endpoint
app.get('/api/status/features', AuthMiddleware.optionalAuth, async (req, res) => {
  const isAdmin = req.user?.role === 'admin';

  const publicStatus = {
    phase: 'Phase 1-4: Complete E-Commerce Platform + Forum System', // Updated
    status: 'operational',
    lastUpdated: '2025-08-28T23:30:00Z', // Updated timestamp
    features: {
      jwtAuthentication: {
        status: 'operational',
        description: 'JWT-based authentication with refresh tokens',
        endpoints: ['/api/auth/login', '/api/auth/refresh', '/api/auth/logout']
      },
      enhancedUserSystem: {
        status: 'operational',
        description: 'User profiles with status tracking and activity monitoring',
        endpoints: ['/api/v1/users', '/api/v1/users/:username', '/api/v1/users/stats/overview']
      },
      advancedSearch: {
        status: 'operational',
        description: 'Real-time search with filtering and suggestions',
        endpoints: ['/api/v1/search/users', '/api/v1/search/branches', '/api/v1/search/suggestions']
      },
      inventoryManagement: {
        status: 'operational',
        description: 'Complete inventory system with drag-and-drop support',
        endpoints: ['/api/v1/inventory/me', '/api/v1/inventory/display', '/api/v1/inventory/organize']
      },
      leaderboards: {
        status: 'operational',
        description: 'Multi-category leaderboard system with time periods and rankings',
        endpoints: ['/api/leaderboards', '/api/leaderboards/:id', '/api/leaderboards/user/:userId']
      },
      achievements: {
        status: 'operational',
        description: 'Achievement system with progress tracking and rewards',
        endpoints: ['/api/achievements', '/api/achievements/user/:id', '/api/achievements/:id/claim']
      },
      ecommerceStore: {
        status: 'operational',
        description: 'Complete e-commerce system with Stripe integration',
        endpoints: ['/api/store/items', '/api/store/cart', '/api/store/checkout', '/api/store/orders']
      },
      paymentProcessing: {
        status: 'operational',
        description: 'Secure payment processing with Stripe',
        endpoints: ['/api/store/checkout', '/api/webhooks/stripe']
      },
      adminDashboard: {
        status: 'operational',
        description: 'Admin interface for store and order management',
        endpoints: ['/api/admin/store/dashboard', '/api/admin/store/orders', '/api/admin/store/items']
      },
      forumSystem: { // NEW
        status: 'operational',
        description: 'Complete forum system with categories, threads, moderation, and study verification',
        endpoints: ['/api/forum/categories', '/api/forum/categories/:id/threads', '/api/forum/thread/:slug', '/api/forum/thread/:slug/reply']
      },
      oliveBranchSystem: {
        status: 'operational',
        description: 'Original olive branch generation and management',
        endpoints: ['/api/olive-branches/generate', '/api/olive-branches/:id']
      }
    }
  };

  // Add admin-only information
  if (isAdmin) {
    const { PrismaClient } = require('@prisma/client');
    const prisma = new PrismaClient();

    try {
      const [
        userCount,
        branchCount,
        inventoryItemCount,
        leaderboardCount,
        achievementCount,
        storeItemCount,
        orderCount,
        totalRevenue,
        forumThreadCount, // NEW
        forumPostCount, // NEW
        forumCategoryCount // NEW
      ] = await Promise.all([
        prisma.users.count(),
        prisma.olive_branches.count({ where: { is_active: true } }),
        prisma.inventory_items.count(),
        prisma.leaderboards.count({ where: { is_active: true } }),
        prisma.achievements.count({ where: { is_active: true } }),
        prisma.store_items.count({ where: { is_active: true } }),
        prisma.orders.count(),
        prisma.orders.aggregate({
          _sum: { total_cents: true },
          where: { payment_status: 'succeeded' }
        }),
        prisma.forum_threads.count({ where: { is_deleted: false } }), // NEW
        prisma.forum_posts.count({ where: { is_deleted: false } }), // NEW
        prisma.forum_categories.count({ where: { is_active: true } }) // NEW
      ]);

      publicStatus.adminStats = {
        totalUsers: userCount,
        totalBranches: branchCount,
        totalInventoryItems: inventoryItemCount,
        totalLeaderboards: leaderboardCount,
        totalAchievements: achievementCount,
        totalStoreItems: storeItemCount,
        totalOrders: orderCount,
        totalRevenueCents: totalRevenue._sum.total_cents || 0,
        totalRevenueFormatted: `$${((totalRevenue._sum.total_cents || 0) / 100).toFixed(2)}`,
        totalForumThreads: forumThreadCount, // NEW
        totalForumPosts: forumPostCount, // NEW
        totalForumCategories: forumCategoryCount, // NEW
        systemLoad: process.memoryUsage(),
        uptime: process.uptime()
      };

      await prisma.$disconnect();
    } catch (error) {
      console.error('Error fetching admin stats:', error);
    }
  }

  res.json(publicStatus);
});

// Enhanced 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    success: false,
    error: {
      code: 'ROUTE_NOT_FOUND',
      message: `The endpoint ${req.method} ${req.originalUrl} does not exist`,
    },
    availableEndpoints: {
      core: [
        '/api/auth',
        '/api/v1/users',
        '/api/v1/search',
        '/api/v1/inventory'
      ],
      phase3: [
        '/api/leaderboards',
        '/api/achievements',
        '/api/v1/leaderboards',
        '/api/v1/achievements'
      ],
      phase4: [
        '/api/store',
        '/api/v1/store',
        '/api/admin/store',
        '/api/webhooks',
        '/api/forum', // NEW
        '/api/v1/forum' // NEW
      ],
      legacy: [
        '/api/olive-branches',
        '/api/registration',
        '/api/id-cards'
      ],
      system: [
        '/health',
        '/api',
        '/api/status/features'
      ]
    },
    timestamp: new Date().toISOString(),
    requestId: res.locals.requestId
  });
});

// Enhanced error handler (must be last middleware)
app.use(errorHandler);

// Graceful shutdown handling
const gracefulShutdown = (signal) => {
  console.log(`${signal} received, shutting down gracefully`);
  server.close(() => {
    console.log('HTTP server closed');
    process.exit(0);
  });
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Start server
const server = app.listen(PORT, () => {
  console.log(`
🌿 Galway Research Institute API Server Started
📍 Environment: ${process.env.NODE_ENV || 'development'}
🌐 Server running on port ${PORT}
🔗 Health check: http://localhost:${PORT}/health
📚 API documentation: http://localhost:${PORT}/api
🎯 Feature status: http://localhost:${PORT}/api/status/features
⏰ Started at: ${new Date().toISOString()}

✅ Phase 1-4 Implementation Complete:
🔐 JWT Authentication with refresh tokens
👥 Enhanced user management with status tracking
🔍 Advanced search with real-time suggestions
🎒 Complete inventory management system
🏆 Multi-category leaderboard system
🎯 Achievement system with progress tracking & rewards
🛍️ Complete E-Commerce Store with Stripe integration
💳 Secure payment processing (CAD currency)
📦 Order management and fulfillment tracking
🏷️ Coupon and discount system
📱 Digital item delivery system
📊 Admin dashboard with sales analytics
🔗 Webhook handling for payment events
💬 Complete Forum System with content moderation
📝 Thread creation, replies, and upvote system
⭐ Study verification and role promotion system
🛡️ Auto-moderation with manual review queue
📎 File attachment support (images, documents, archives)
🌿 Original olive branch system (maintained)
🆔 ID card generation system (maintained)

🚀 Ready for Phase 5: Advanced Features & Scaling

📋 Quick Test Commands:
curl http://localhost:${PORT}/api/store/categories
curl http://localhost:${PORT}/api/store/items
curl http://localhost:${PORT}/api/forum/categories
curl -H "Authorization: Bearer YOUR_TOKEN" http://localhost:${PORT}/api/store/cart
curl -H "Authorization: Bearer YOUR_TOKEN" http://localhost:${PORT}/api/forum/categories

🛍️ E-Commerce Features Available:
• Store categories and items (physical & digital)
• Shopping cart management
• Stripe checkout integration
• Order tracking and history
• Inventory management with variants
• Coupon system with usage limits
• Admin dashboard for store management
• Digital item delivery system
• Webhook processing for payments
• Sales analytics and reporting

💬 Forum Features Available:
• Forum categories (General, Study, Trading, Support)
• Thread creation with URL-friendly slugs
• Post replies with character limits (5000/1200)
• Content moderation and auto-flagging
• File attachments (images, documents, archives)
• Study verification with star system
• Role-based permissions and post limits
• Auto-lock threads after 15 days inactivity
• Upvote system and user reputation
• Moderation tools for admins/moderators
`);
});

module.exports = app;

// === END src/server.js ===


============================================================
DIRECTORY: src/middleware
============================================================

// === src/middleware/auth.js ===
// middleware/auth.js - Fixed Authentication Middleware
const { PrismaClient } = require('@prisma/client');
const JWTService = require('../utils/jwt');
const { UnauthorizedError, ForbiddenError } = require('./errorHandler');

const prisma = new PrismaClient();

class AuthMiddleware {
  // Basic authentication - requires valid JWT
  static async requireAuth(req, res, next) {
    try {
      const authHeader = req.headers.authorization;
      const token = JWTService.extractTokenFromHeader(authHeader);
      
      if (!token) {
        throw new UnauthorizedError('Access token required');
      }

      // Verify and decode token
      const decoded = JWTService.verifyAccessToken(token);
      
      // Get fresh user data from database (FIXED: users not user)
      const user = await prisma.users.findUnique({
        where: { id: decoded.userId },
        select: {
          id: true,
          username: true,
          role: true,
          // Only select fields that exist in your schema
          created_at: true,
          updated_at: true,
          email: true
        }
      });

      if (!user) {
        throw new UnauthorizedError('User not found');
      }

      // Try to update last seen (optional - only if fields exist)
      try {
        await prisma.users.update({
          where: { id: user.id },
          data: {
            updated_at: new Date()
            // Only update fields that exist in your schema
          }
        });
      } catch (updateError) {
        // Gracefully handle if fields don't exist
        console.warn('Could not update timestamp - field may not exist in schema');
      }

      // Add user data to request
      req.user = {
        id: user.id,
        username: user.username,
        role: user.role,
        email: user.email,
        permissions: JWTService.getUserPermissions(user.role),
        token: decoded
      };

      next();
    } catch (error) {
      if (error.name === 'JsonWebTokenError') {
        return next(new UnauthorizedError('Invalid access token'));
      }
      if (error.name === 'TokenExpiredError') {
        return next(new UnauthorizedError('Access token expired'));
      }
      next(error);
    }
  }

  // Optional authentication - doesn't fail if no token
  static async optionalAuth(req, res, next) {
    try {
      const authHeader = req.headers.authorization;
      const token = JWTService.extractTokenFromHeader(authHeader);
      
      if (!token) {
        req.user = null;
        return next();
      }

      const decoded = JWTService.verifyAccessToken(token);
      const user = await prisma.users.findUnique({
        where: { id: decoded.userId },
        select: {
          id: true,
          username: true,
          role: true,
          created_at: true,
          email: true
        }
      });

      if (user) {
        req.user = {
          id: user.id,
          username: user.username,
          role: user.role,
          email: user.email,
          permissions: JWTService.getUserPermissions(user.role),
          token: decoded
        };
      } else {
        req.user = null;
      }

      next();
    } catch (error) {
      // Silently fail for optional auth
      req.user = null;
      next();
    }
  }

  // Require specific roles
  static requireRole(roles = []) {
    return (req, res, next) => {
      if (!req.user) {
        return next(new UnauthorizedError('Authentication required'));
      }

      const userRoles = Array.isArray(roles) ? roles : [roles];
      if (!userRoles.includes(req.user.role)) {
        return next(new ForbiddenError(`Access denied. Required role: ${userRoles.join(' or ')}`));
      }

      next();
    };
  }

  // Require specific permissions
  static requirePermission(permissions = []) {
    return (req, res, next) => {
      if (!req.user) {
        return next(new UnauthorizedError('Authentication required'));
      }

      const requiredPermissions = Array.isArray(permissions) ? permissions : [permissions];
      const userPermissions = req.user.permissions || [];

      // Admin has all permissions
      if (userPermissions.includes('*')) {
        return next();
      }

      // Check if user has required permissions
      const hasPermission = requiredPermissions.every(permission =>
        userPermissions.includes(permission)
      );

      if (!hasPermission) {
        return next(new ForbiddenError(`Missing required permissions: ${requiredPermissions.join(', ')}`));
      }

      next();
    };
  }

  // Enhanced admin middleware with audit logging
  static requireAdmin(req, res, next) {
    if (!req.user) {
      return next(new UnauthorizedError('Authentication required'));
    }

    if (req.user.role !== 'admin') {
      console.warn(`Unauthorized admin access attempt by ${req.user.username} (${req.user.id}) to ${req.path}`);
      return next(new ForbiddenError('Administrator access required'));
    }

    next();
  }
}

// Exports
module.exports = AuthMiddleware;

// === END src/middleware/auth.js ===

// === src/middleware/contentModeration.js ===
// middleware/contentModeration.js - Forum Content Filtering System
const { PrismaClient } = require('@prisma/client');
const { ForbiddenError } = require('./errorHandler');

const prisma = new PrismaClient();

class ContentModerationService {
  constructor() {
    // Auto-flag these offensive terms (homophobic and racist slurs as specified)
    this.offensiveTerms = [
      // Note: In production, load this from a database for easy management
      'faggot', 'f4ggot', 'fag', 'f4g',
      'nigger', 'n1gger', 'nig', 'n1g',
      'retard', 'ret4rd', 'spic', 'sp1c',
      'kike', 'k1ke', 'chink', 'ch1nk',
      'gook', 'g00k', 'wetback', 'w3tback'
      // Add more as needed, consider regex patterns for variations
    ];

    // Common profanity that gets filtered but not auto-flagged
    this.profanityTerms = [
      'fuck', 'f*ck', 'f**k', 'shit', 'sh*t', 'sh**',
      'damn', 'd*mn', 'hell', 'h*ll', 'ass', 'a**',
      'bitch', 'b*tch', 'bastard', 'b*stard'
    ];

    // Compile regex patterns for better performance
    this.offensiveRegex = new RegExp(
      this.offensiveTerms.map(term => 
        term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') // Escape special chars
      ).join('|'),
      'gi'
    );

    this.profanityRegex = new RegExp(
      this.profanityTerms.map(term => 
        term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
      ).join('|'),
      'gi'
    );
  }

  // Check if content contains auto-flagged terms
  containsOffensiveContent(text) {
    const matches = text.match(this.offensiveRegex);
    return {
      hasOffensive: !!matches,
      matches: matches || [],
      count: matches ? matches.length : 0
    };
  }

  // Filter out profanity by replacing with asterisks
  filterProfanity(text) {
    return text.replace(this.profanityRegex, (match) => {
      return match.charAt(0) + '*'.repeat(match.length - 1);
    });
  }

  // Main content filtering function
  async moderateContent(content, userId, contentType = 'post') {
    const result = {
      originalContent: content,
      filteredContent: content,
      autoFlagged: false,
      flagReason: null,
      requiresReview: false,
      blocked: false
    };

    try {
      // 1. Check for auto-flagged offensive content
      const offensiveCheck = this.containsOffensiveContent(content);
      
      if (offensiveCheck.hasOffensive) {
        result.autoFlagged = true;
        result.requiresReview = true;
        result.flagReason = `Contains offensive language: ${offensiveCheck.matches.join(', ')}`;
        
        // For extremely offensive content, block immediately
        if (offensiveCheck.count > 2) {
          result.blocked = true;
          
          // Log the incident
          await this.logModerationAction(userId, contentType, content, 'AUTO_BLOCKED', result.flagReason);
          
          throw new ForbiddenError('Content contains inappropriate language and has been blocked');
        }

        // Queue for moderation review
        await this.queueForReview(userId, contentType, content, 'offensive_language', result.flagReason);
      }

      // 2. Filter profanity (replace with asterisks)
      result.filteredContent = this.filterProfanity(content);

      // 3. Check content length and spam patterns
      const spamCheck = await this.checkForSpam(content, userId);
      if (spamCheck.isSpam) {
        result.autoFlagged = true;
        result.requiresReview = true;
        result.flagReason = spamCheck.reason;
        
        await this.queueForReview(userId, contentType, content, 'spam', spamCheck.reason);
      }

      // 4. Log successful moderation
      if (result.filteredContent !== result.originalContent) {
        await this.logModerationAction(userId, contentType, content, 'FILTERED', 'Profanity filtered');
      }

      return result;

    } catch (error) {
      console.error('Content moderation error:', error);
      
      if (error instanceof ForbiddenError) {
        throw error; // Re-throw blocked content errors
      }
      
      // For other errors, allow content through but log the error
      await this.logModerationAction(userId, contentType, content, 'ERROR', error.message);
      return result;
    }
  }

  // Simple spam detection
  async checkForSpam(content, userId) {
    // Check for excessive caps
    const capsRatio = (content.match(/[A-Z]/g) || []).length / content.length;
    if (capsRatio > 0.7 && content.length > 50) {
      return {
        isSpam: true,
        reason: 'Excessive use of capital letters'
      };
    }

    // Check for repeated characters
    const repeatedChars = content.match(/(.)\1{4,}/g);
    if (repeatedChars && repeatedChars.length > 2) {
      return {
        isSpam: true,
        reason: 'Excessive repeated characters'
      };
    }

    // Check for duplicate recent posts (last 5 minutes)
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
    
    try {
      const recentSimilarPosts = await prisma.forum_posts.count({
        where: {
          author_id: userId,
          created_at: { gte: fiveMinutesAgo },
          content: content,
          is_deleted: false
        }
      });

      if (recentSimilarPosts > 0) {
        return {
          isSpam: true,
          reason: 'Duplicate post detected'
        };
      }

      // Check for rapid posting (more than 5 posts in 2 minutes)
      const twoMinutesAgo = new Date(Date.now() - 2 * 60 * 1000);
      const rapidPosts = await prisma.forum_posts.count({
        where: {
          author_id: userId,
          created_at: { gte: twoMinutesAgo },
          is_deleted: false
        }
      });

      if (rapidPosts >= 5) {
        return {
          isSpam: true,
          reason: 'Rapid posting detected'
        };
      }

    } catch (error) {
      console.error('Spam check database error:', error);
      // Continue without spam check if DB error
    }

    return { isSpam: false };
  }

  // Queue content for manual review
  async queueForReview(userId, contentType, content, severity, reason) {
    try {
      await prisma.moderation_queue.create({
        data: {
          content_type: contentType,
          content_id: 0, // Will be updated after post is created
          content_text: content,
          user_id: userId,
          severity: severity === 'offensive_language' ? 'high' : 'medium',
          auto_flagged: true,
          status: 'pending',
          created_at: new Date()
        }
      });
    } catch (error) {
      console.error('Failed to queue for review:', error);
    }
  }

  // Log moderation actions
  async logModerationAction(userId, contentType, content, action, reason) {
    try {
      // In a real system, you'd want a dedicated moderation_logs table
      console.log('Moderation Log:', {
        userId,
        contentType,
        contentPreview: content.substring(0, 100),
        action,
        reason,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('Failed to log moderation action:', error);
    }
  }

  // Check if user email is verified (required for posting)
  async checkEmailVerification(userId) {
    try {
      const user = await prisma.users.findUnique({
        where: { id: userId },
        select: { email_verified: true }
      });

      return user?.email_verified || false;
    } catch (error) {
      console.error('Email verification check error:', error);
      return false; // Fail safe - assume not verified
    }
  }
}

// Initialize the service
const moderationService = new ContentModerationService();

// Middleware function to filter content
const filterContent = async (req, res, next) => {
  try {
    // Check if user's email is verified
    const isEmailVerified = await moderationService.checkEmailVerification(req.user.id);
    if (!isEmailVerified) {
      throw new ForbiddenError('Email verification required to post content');
    }

    // Skip moderation for admins and moderators
    if (['admin', 'moderator'].includes(req.user.role)) {
      return next();
    }

    const content = req.body.content;
    if (!content || typeof content !== 'string') {
      return next();
    }

    // Moderate the content
    const moderationResult = await moderationService.moderateContent(
      content, 
      req.user.id, 
      req.route.path.includes('thread') ? 'thread' : 'post'
    );

    // Attach results to request for use in route handlers
    req.filteredContent = moderationResult.filteredContent;
    req.autoFlagged = moderationResult.autoFlagged;
    req.moderationResult = moderationResult;

    // If content was blocked, this will throw an error
    if (moderationResult.blocked) {
      throw new ForbiddenError(moderationResult.flagReason);
    }

    next();
  } catch (error) {
    next(error);
  }
};

// Middleware to check if user can post based on recent activity
const rateLimitPosts = async (req, res, next) => {
  try {
    // Skip for mods/admins
    if (['admin', 'moderator'].includes(req.user.role)) {
      return next();
    }

    const oneMinuteAgo = new Date(Date.now() - 60 * 1000);
    
    const recentPosts = await prisma.forum_posts.count({
      where: {
        author_id: req.user.id,
        created_at: { gte: oneMinuteAgo }
      }
    });

    // Limit to 3 posts per minute for regular users
    if (recentPosts >= 3) {
      throw new ForbiddenError('Posting too quickly. Please wait before posting again.');
    }

    next();
  } catch (error) {
    next(error);
  }
};

// Export middleware functions
module.exports = {
  filterContent,
  rateLimitPosts,
  moderationService
};

// === END src/middleware/contentModeration.js ===

// === src/middleware/errorHandler.js ===
// middleware/errorHandler.js - Fixed version without database calls
const { v4: uuidv4 } = require('uuid');

// Response Wrapper Class
class ResponseWrapper {
  static success(res, data, message = 'Operation completed successfully', statusCode = 200) {
    const response = {
      success: true,
      data,
      message,
      timestamp: new Date().toISOString(),
      requestId: res.locals.requestId || uuidv4()
    };

    // Add pagination if present
    if (data && data.pagination) {
      response.pagination = data.pagination;
      response.data = data.data || data;
      delete response.data.pagination;
    }

    return res.status(statusCode).json(response);
  }

  static error(res, error, statusCode = 500, code = 'INTERNAL_SERVER_ERROR') {
    const response = {
      success: false,
      error: {
        code,
        message: error.message || error,
        details: error.details || {}
      },
      timestamp: new Date().toISOString(),
      requestId: res.locals.requestId || uuidv4()
    };

    // Add stack trace in development
    if (process.env.NODE_ENV === 'development' && error.stack) {
      response.error.stack = error.stack;
    }

    return res.status(statusCode).json(response);
  }

  static paginated(res, data, pagination, message = 'Data retrieved successfully') {
    return ResponseWrapper.success(res, {
      items: data,
      pagination: {
        page: pagination.page,
        limit: pagination.limit,
        total: pagination.total,
        totalPages: Math.ceil(pagination.total / pagination.limit),
        hasNext: pagination.page < Math.ceil(pagination.total / pagination.limit),
        hasPrev: pagination.page > 1
      }
    }, message);
  }

  static created(res, data, message = 'Resource created successfully') {
    return ResponseWrapper.success(res, data, message, 201);
  }

  static updated(res, data, message = 'Resource updated successfully') {
    return ResponseWrapper.success(res, data, message, 200);
  }

  static deleted(res, message = 'Resource deleted successfully') {
    return ResponseWrapper.success(res, null, message, 200);
  }

  static notFound(res, message = 'Resource not found') {
    return ResponseWrapper.error(res, new Error(message), 404, 'NOT_FOUND');
  }

  static forbidden(res, message = 'Access forbidden') {
    return ResponseWrapper.error(res, new Error(message), 403, 'FORBIDDEN');
  }

  static unauthorized(res, message = 'Authentication required') {
    return ResponseWrapper.error(res, new Error(message), 401, 'UNAUTHORIZED');
  }

  static badRequest(res, message = 'Invalid request', details = {}) {
    const error = new Error(message);
    error.details = details;
    return ResponseWrapper.error(res, error, 400, 'BAD_REQUEST');
  }

  static validationError(res, validationErrors) {
    const error = new Error('Validation failed');
    error.details = validationErrors;
    return ResponseWrapper.error(res, error, 422, 'VALIDATION_ERROR');
  }

  static rateLimit(res, message = 'Too many requests') {
    return ResponseWrapper.error(res, new Error(message), 429, 'RATE_LIMIT_EXCEEDED');
  }
}

// Custom error classes
class AppError extends Error {
  constructor(message, statusCode = 500, code = 'INTERNAL_SERVER_ERROR', details = {}) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.details = details;
    this.isOperational = true;
    Error.captureStackTrace(this, this.constructor);
  }
}

class ValidationError extends AppError {
  constructor(message, details = {}) {
    super(message, 422, 'VALIDATION_ERROR', details);
  }
}

class NotFoundError extends AppError {
  constructor(message = 'Resource not found') {
    super(message, 404, 'NOT_FOUND');
  }
}

class ForbiddenError extends AppError {
  constructor(message = 'Access forbidden') {
    super(message, 403, 'FORBIDDEN');
  }
}

class UnauthorizedError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 401, 'UNAUTHORIZED');
  }
}

class ConflictError extends AppError {
  constructor(message = 'Resource conflict') {
    super(message, 409, 'CONFLICT');
  }
}

// Error Handler Middleware - SIMPLIFIED without database calls
const errorHandler = (error, req, res, next) => {
  // Set request ID for tracking
  if (!res.locals.requestId) {
    res.locals.requestId = req.headers['x-request-id'] || uuidv4();
  }

  console.error(`[${res.locals.requestId}] Error:`, {
    message: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    user: req.user?.username || 'anonymous',
    timestamp: new Date().toISOString()
  });

  // Handle known operational errors
  if (error.isOperational) {
    return ResponseWrapper.error(res, error, error.statusCode, error.code);
  }

  // Handle JWT errors
  if (error.name === 'JsonWebTokenError') {
    return ResponseWrapper.unauthorized(res, 'Invalid token');
  }

  if (error.name === 'TokenExpiredError') {
    return ResponseWrapper.unauthorized(res, 'Token expired');
  }

  // Handle Prisma errors
  if (error.code === 'P2002') {
    return ResponseWrapper.error(res, 
      new Error('Duplicate entry - resource already exists'), 
      409, 
      'DUPLICATE_ENTRY'
    );
  }

  if (error.code === 'P2025') {
    return ResponseWrapper.notFound(res, 'Resource not found');
  }

  if (error.code && error.code.startsWith('P')) {
    return ResponseWrapper.error(res, 
      new Error('Database operation failed'), 
      500, 
      'DATABASE_ERROR'
    );
  }

  // Handle validation errors
  if (error.name === 'ValidationError') {
    const validationErrors = Object.values(error.errors).map(err => ({
      field: err.path,
      message: err.message,
      value: err.value
    }));
    return ResponseWrapper.validationError(res, validationErrors);
  }

  // Handle rate limiting
  if (error.code === 'RATE_LIMIT_EXCEEDED') {
    return ResponseWrapper.rateLimit(res, error.message);
  }

  // Handle unexpected errors
  return ResponseWrapper.error(res, 
    new Error(process.env.NODE_ENV === 'production' 
      ? 'An unexpected error occurred' 
      : error.message
    ), 
    500, 
    'INTERNAL_SERVER_ERROR'
  );
};

// Request ID middleware
const requestIdMiddleware = (req, res, next) => {
  const requestId = req.headers['x-request-id'] || uuidv4();
  res.locals.requestId = requestId;
  res.set('X-Request-ID', requestId);
  next();
};

module.exports = {
  ResponseWrapper,
  errorHandler,
  requestIdMiddleware,
  AppError,
  ValidationError,
  NotFoundError,
  ForbiddenError,
  UnauthorizedError,
  ConflictError
};

// === END src/middleware/errorHandler.js ===

// === src/middleware/fileUpload.js ===
// middleware/fileUpload.js - Forum File Upload Handler
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');
const { ValidationError } = require('./errorHandler');

class FileUploadService {
  constructor() {
    // Allowed file types for forum attachments
    this.allowedMimeTypes = {
      // Images
      'image/jpeg': { ext: '.jpg', category: 'image' },
      'image/png': { ext: '.png', category: 'image' },
      'image/gif': { ext: '.gif', category: 'image' },
      'image/webp': { ext: '.webp', category: 'image' },
      
      // Documents
      'application/pdf': { ext: '.pdf', category: 'document' },
      'text/plain': { ext: '.txt', category: 'document' },
      'text/markdown': { ext: '.md', category: 'document' },
      
      // Compressed files (for sharing research data)
      'application/zip': { ext: '.zip', category: 'archive' },
      'application/x-7z-compressed': { ext: '.7z', category: 'archive' }
    };

    // File size limits (in bytes)
    this.fileLimits = {
      image: 10 * 1024 * 1024,      // 10MB for images
      document: 25 * 1024 * 1024,   // 25MB for documents  
      archive: 50 * 1024 * 1024,    // 50MB for archives
      default: 10 * 1024 * 1024     // 10MB default
    };

    // Upload directory
    this.uploadDir = path.join(process.cwd(), 'uploads', 'forum');
    this.ensureUploadDirectory();
  }

  // Ensure upload directories exist
  ensureUploadDirectory() {
    const dirs = [
      this.uploadDir,
      path.join(this.uploadDir, 'images'),
      path.join(this.uploadDir, 'documents'),
      path.join(this.uploadDir, 'archives')
    ];

    dirs.forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        console.log(`📁 Created upload directory: ${dir}`);
      }
    });
  }

  // Generate secure filename
  generateSecureFilename(originalName, userId) {
    const timestamp = Date.now();
    const random = crypto.randomBytes(8).toString('hex');
    const ext = path.extname(originalName);
    const baseName = path.basename(originalName, ext)
      .replace(/[^a-zA-Z0-9\-_]/g, '') // Remove special chars
      .substring(0, 20); // Limit length
    
    return `${userId}_${timestamp}_${baseName}_${random}${ext}`;
  }

  // Get file category and validate
  validateFile(file) {
    const fileInfo = this.allowedMimeTypes[file.mimetype];
    
    if (!fileInfo) {
      throw new ValidationError(`File type ${file.mimetype} not allowed. Allowed types: images (JPG, PNG, GIF, WebP), documents (PDF, TXT, MD), archives (ZIP, 7Z)`);
    }

    const sizeLimit = this.fileLimits[fileInfo.category] || this.fileLimits.default;
    
    if (file.size > sizeLimit) {
      const sizeMB = Math.round(sizeLimit / (1024 * 1024));
      throw new ValidationError(`File too large. Maximum size for ${fileInfo.category} files: ${sizeMB}MB`);
    }

    return fileInfo;
  }

  // Get storage configuration
  getStorageConfig() {
    return multer.diskStorage({
      destination: (req, file, cb) => {
        try {
          const fileInfo = this.validateFile(file);
          const destDir = path.join(this.uploadDir, `${fileInfo.category}s`);
          cb(null, destDir);
        } catch (error) {
          cb(error);
        }
      },
      
      filename: (req, file, cb) => {
        try {
          const userId = req.user?.id || 'anonymous';
          const secureFilename = this.generateSecureFilename(file.originalname, userId);
          
          // Store file info for later use
          file.secureFilename = secureFilename;
          file.category = this.allowedMimeTypes[file.mimetype].category;
          
          cb(null, secureFilename);
        } catch (error) {
          cb(error);
        }
      }
    });
  }

  // File filter for additional validation
  fileFilter(req, file, cb) {
    try {
      // Check if user is authenticated
      if (!req.user) {
        return cb(new ValidationError('Authentication required for file uploads'));
      }

      // Validate file type and size
      const fileInfo = this.validateFile(file);
      
      // Additional security checks
      const originalName = file.originalname.toLowerCase();
      const dangerousExtensions = ['.exe', '.bat', '.cmd', '.scr', '.pif', '.com', '.js', '.vbs', '.jar'];
      
      const isDangerous = dangerousExtensions.some(ext => originalName.endsWith(ext));
      if (isDangerous) {
        return cb(new ValidationError('Executable files are not allowed'));
      }

      cb(null, true);
    } catch (error) {
      cb(error);
    }
  }
}

// Initialize the service
const uploadService = new FileUploadService();

// Create multer middleware with custom configuration
const uploadMiddleware = multer({
  storage: uploadService.getStorageConfig(),
  fileFilter: uploadService.fileFilter.bind(uploadService),
  limits: {
    fileSize: Math.max(...Object.values(uploadService.fileLimits)), // Use largest limit
    files: 5, // Maximum 5 files per request
    fieldSize: 1024 * 1024 // 1MB field size limit
  }
});

// Middleware to process uploaded files and add metadata
const processUploads = (req, res, next) => {
  if (!req.files || req.files.length === 0) {
    return next();
  }

  try {
    // Add metadata to each file
    req.files = req.files.map(file => {
      const fileUrl = `/uploads/forum/${file.category}s/${file.filename}`;
      
      return {
        fieldname: file.fieldname,
        originalname: file.originalname,
        encoding: file.encoding,
        mimetype: file.mimetype,
        filename: file.filename,
        path: file.path,
        size: file.size,
        category: file.category,
        url: fileUrl,
        secure: true, // Files are validated and safe
        uploadedAt: new Date(),
        uploadedBy: req.user.id
      };
    });

    // Log successful uploads
    console.log(`📎 ${req.files.length} file(s) uploaded by user ${req.user.username}:`, 
      req.files.map(f => ({ name: f.originalname, size: f.size, type: f.mimetype }))
    );

    next();
  } catch (error) {
    next(error);
  }
};

// Error handling middleware specifically for multer errors
const handleUploadError = (error, req, res, next) => {
  if (error instanceof multer.MulterError) {
    switch (error.code) {
      case 'LIMIT_FILE_SIZE':
        return next(new ValidationError('File too large'));
      case 'LIMIT_FILE_COUNT':
        return next(new ValidationError('Too many files. Maximum 5 files allowed'));
      case 'LIMIT_UNEXPECTED_FILE':
        return next(new ValidationError('Unexpected file field'));
      case 'LIMIT_FIELD_VALUE':
        return next(new ValidationError('Field value too large'));
      default:
        return next(new ValidationError(`Upload error: ${error.message}`));
    }
  }
  
  next(error);
};

// Helper function to delete uploaded files (for cleanup on error)
const cleanupFiles = (files) => {
  if (!files || !Array.isArray(files)) return;
  
  files.forEach(file => {
    try {
      if (fs.existsSync(file.path)) {
        fs.unlinkSync(file.path);
        console.log(`🗑️ Cleaned up file: ${file.filename}`);
      }
    } catch (error) {
      console.error(`Failed to cleanup file ${file.filename}:`, error);
    }
  });
};

// Combine middleware functions for easy use
const fileUploadChain = [
  uploadMiddleware,
  handleUploadError,
  processUploads
];

// Export individual functions and combined chain
module.exports = {
  // Main upload middleware (use this in routes)
  single: (fieldname) => [
    uploadMiddleware.single(fieldname),
    handleUploadError,
    processUploads
  ],
  
  array: (fieldname, maxCount = 3) => [
    uploadMiddleware.array(fieldname, maxCount),
    handleUploadError,
    processUploads
  ],
  
  fields: (fields) => [
    uploadMiddleware.fields(fields),
    handleUploadError,
    processUploads
  ],
  
  // Utility functions
  cleanupFiles,
  uploadService,
  
  // For backward compatibility
  ...fileUploadChain
};

// === END src/middleware/fileUpload.js ===


============================================================
DIRECTORY: src/routes
============================================================

// === src/routes/achievements.js ===
const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { requireAuth, optionalAuth } = require('../middleware/auth');
const { ResponseWrapper } = require('../middleware/errorHandler');

const router = express.Router();
const prisma = new PrismaClient();

// Test endpoint - keeping the working version
router.get('/test', (req, res) => {
  const testData = {
    system: 'Achievements API',
    version: '1.0.0',
    status: 'operational',
    features: [
      'Achievement tracking and progress',
      'Badge system for user profiles',
      'Reward claiming system',
      'Achievement categories',
      'Progress tracking with criteria',
      'Recent achievements feed'
    ],
    categories: ['collector', 'trader', 'social', 'seasonal', 'special'],
    reward_types: ['seeds', 'points', 'badge_only', 'early_access']
  };
  
  ResponseWrapper.success(res, testData, 'Achievements API fully operational');
});

// GET /api/achievements/categories - Get achievement categories
router.get('/categories', async (req, res, next) => {
  try {
    // Predefined categories with descriptions
    const categories = [
      {
        name: 'collector',
        count: 0,
        description: 'Achievements for collecting rare olive branches and building impressive collections'
      },
      {
        name: 'trader',
        count: 0,
        description: 'Achievements for trading activities, successful transactions, and market participation'
      },
      {
        name: 'social',
        count: 0,
        description: 'Achievements for community engagement, social interactions, and helping others'
      },
      {
        name: 'seasonal',
        count: 0,
        description: 'Limited-time seasonal achievements and special event participation'
      },
      {
        name: 'special',
        count: 0,
        description: 'Rare and unique achievements for extraordinary accomplishments'
      }
    ];

    // Try to get actual counts from database
    try {
      const dbCategories = await prisma.achievements.groupBy({
        by: ['category'],
        where: { is_active: true },
        _count: { category: true }
      });

      // Update counts if we have data
      dbCategories.forEach(dbCat => {
        const category = categories.find(c => c.name === dbCat.category);
        if (category) {
          category.count = dbCat._count.category;
        }
      });
    } catch (dbError) {
      console.log('Database not available for achievement categories, using defaults');
    }

    ResponseWrapper.success(res, categories);
  } catch (error) {
    next(error);
  }
});

// GET /api/achievements/recent - Get recent achievements
router.get('/recent', async (req, res, next) => {
  try {
    const { limit = 20, hours = 24 } = req.query;
    let recentAchievements = [];

    try {
      recentAchievements = await prisma.user_achievements.findMany({
        where: {
          is_completed: true,
          completed_at: {
            gte: new Date(Date.now() - (parseInt(hours) * 60 * 60 * 1000))
          }
        },
        select: {
          id: true,
          completed_at: true,
          users: {
            select: {
              id: true,
              username: true,
              role: true
            }
          },
          achievements: {
            select: {
              id: true,
              name: true,
              description: true,
              badge_icon: true,
              category: true,
              reward_type: true
            }
          }
        },
        orderBy: { completed_at: 'desc' },
        take: parseInt(limit)
      });
    } catch (dbError) {
      console.log('No recent achievements data available');
      // Return empty array if database not available
      recentAchievements = [];
    }

    const formatted = recentAchievements.map(ra => ({
      id: ra.id,
      user: {
        id: ra.users.id,
        username: ra.users.username,
        role: ra.users.role
      },
      achievement: {
        id: ra.achievements.id,
        name: ra.achievements.name,
        description: ra.achievements.description,
        badge_icon: ra.achievements.badge_icon,
        category: ra.achievements.category,
        reward_type: ra.achievements.reward_type
      },
      completed_at: ra.completed_at
    }));

    ResponseWrapper.success(res, formatted, 'Recent achievements retrieved');
  } catch (error) {
    next(error);
  }
});

// GET /api/achievements/leaderboard - Achievement leaderboard
router.get('/leaderboard', async (req, res, next) => {
  try {
    const { limit = 50 } = req.query;
    let formatted = [];

    try {
      const achievementLeaderboard = await prisma.user_achievements.groupBy({
        by: ['user_id'],
        where: { is_completed: true },
        _count: { user_id: true },
        orderBy: {
          _count: { user_id: 'desc' }
        },
        take: parseInt(limit)
      });

      // Get user details for the leaderboard
      const userIds = achievementLeaderboard.map(entry => entry.user_id);
      const users = await prisma.user.findMany({
        where: { id: { in: userIds } },
        select: {
          id: true,
          username: true,
          role: true,
          created_at: true
        }
      });

      // Create user lookup map
      const userMap = users.reduce((acc, user) => {
        acc[user.id] = user;
        return acc;
      }, {});

      // Format leaderboard with user details
      formatted = achievementLeaderboard.map((entry, index) => ({
        rank: index + 1,
        user: userMap[entry.user_id],
        achievements_earned: entry._count.user_id
      })).filter(entry => entry.user);

    } catch (dbError) {
      console.log('No achievement leaderboard data available');
      formatted = [];
    }

    ResponseWrapper.success(res, formatted, 'Achievement leaderboard retrieved');
  } catch (error) {
    next(error);
  }
});

// GET /api/achievements/user/:id - Get user's achievement progress
router.get('/user/:id', requireAuth, async (req, res, next) => {
  try {
    const { id } = req.params;
    const { include_incomplete = true, category } = req.query;

    // Check if user exists
    const user = await prisma.user.findUnique({
      where: { id: parseInt(id) },
      select: {
        id: true,
        username: true,
        role: true
      }
    });

    if (!user) {
      return ResponseWrapper.notFound(res, 'User not found');
    }

    // Authorization check
    if (req.user.id !== parseInt(id) && !['admin', 'moderator'].includes(req.user.role)) {
      return ResponseWrapper.forbidden(res, 'Access denied');
    }

    let allAchievements = [];

    try {
      // Get user's achievement progress
      const userAchievements = await prisma.user_achievements.findMany({
        where: {
          user_id: parseInt(id),
          ...(category && {
            achievements: { category }
          })
        },
        select: {
          id: true,
          progress_current: true,
          progress_required: true,
          is_completed: true,
          completed_at: true,
          claimed_at: true,
          progress_data: true,
          created_at: true,
          achievements: {
            select: {
              id: true,
              name: true,
              description: true,
              badge_icon: true,
              category: true,
              criteria: true,
              reward_type: true,
              reward_value: true,
              is_hidden: true
            }
          }
        },
        orderBy: [
          { is_completed: 'desc' },
          { progress_current: 'desc' },
          { achievements: { sort_order: 'asc' } }
        ]
      });

      // If include_incomplete is true, also get achievements user hasn't started
      if (include_incomplete === 'true') {
        const userAchievementIds = userAchievements.map(ua => ua.achievements.id);
        
        const incompleteAchievements = await prisma.achievements.findMany({
          where: {
            id: { notIn: userAchievementIds },
            is_active: true,
            is_hidden: false,
            ...(category && { category })
          },
          select: {
            id: true,
            name: true,
            description: true,
            badge_icon: true,
            category: true,
            criteria: true,
            reward_type: true,
            reward_value: true,
            is_hidden: true
          }
        });

        // Add incomplete achievements as user achievements with 0 progress
        const incompleteUserAchievements = incompleteAchievements.map(achievement => ({
          id: null,
          progress_current: 0,
          progress_required: achievement.criteria?.required || 1,
          is_completed: false,
          completed_at: null,
          claimed_at: null,
          progress_data: null,
          created_at: null,
          achievements: achievement
        }));

        allAchievements = [...userAchievements, ...incompleteUserAchievements];
      } else {
        allAchievements = userAchievements;
      }

    } catch (dbError) {
      console.log('No achievement data available for user');
      
      // Return sample achievements if no database data
      allAchievements = [
        {
          id: null,
          progress_current: 0,
          progress_required: 1,
          is_completed: false,
          completed_at: null,
          claimed_at: null,
          progress_data: null,
          created_at: null,
          achievements: {
            id: 1,
            name: 'First Branch',
            description: 'Generate your first olive branch',
            badge_icon: '🌿',
            category: 'collector',
            criteria: { required: 1 },
            reward_type: 'seeds',
            reward_value: 10,
            is_hidden: false
          }
        }
      ];
    }

    // Format the achievements
    const formattedAchievements = allAchievements.map(ua => {
      const progressPercentage = ua.progress_required > 0 ? 
        Math.min((ua.progress_current / ua.progress_required) * 100, 100) : 0;

      return {
        achievement: {
          id: ua.achievements.id,
          name: ua.achievements.name,
          description: ua.achievements.description,
          badge_icon: ua.achievements.badge_icon,
          category: ua.achievements.category,
          criteria: ua.achievements.criteria,
          reward: {
            type: ua.achievements.reward_type,
            value: ua.achievements.reward_value
          },
          is_hidden: ua.achievements.is_hidden
        },
        progress: {
          current: ua.progress_current,
          required: ua.progress_required,
          percentage: Math.round(progressPercentage),
          data: ua.progress_data
        },
        status: {
          is_completed: ua.is_completed,
          completed_at: ua.completed_at,
          is_claimed: !!ua.claimed_at,
          claimed_at: ua.claimed_at,
          can_claim: ua.is_completed && !ua.claimed_at
        },
        started_at: ua.created_at
      };
    });

    // Group by category
    const achievementsByCategory = formattedAchievements.reduce((acc, achievement) => {
      const category = achievement.achievement.category;
      if (!acc[category]) acc[category] = [];
      acc[category].push(achievement);
      return acc;
    }, {});

    // Calculate summary stats
    const completed = formattedAchievements.filter(a => a.status.is_completed).length;
    const claimed = formattedAchievements.filter(a => a.status.is_claimed).length;
    const unclaimed = completed - claimed;
    const inProgress = formattedAchievements.filter(a => 
      !a.status.is_completed && a.progress.current > 0
    ).length;

    ResponseWrapper.success(res, {
      user: {
        id: user.id,
        username: user.username,
        role: user.role
      },
      achievements: achievementsByCategory,
      summary: {
        total_achievements: formattedAchievements.length,
        completed,
        claimed,
        unclaimed_rewards: unclaimed,
        in_progress: inProgress,
        completion_rate: formattedAchievements.length > 0 ? 
          Math.round((completed / formattedAchievements.length) * 100) : 0
      }
    });
  } catch (error) {
    next(error);
  }
});

// GET /api/achievements - Get all achievements
router.get('/', async (req, res, next) => {
  try {
    const { 
      category, 
      active_only = true, 
      include_hidden = false,
      page = 1,
      limit = 50
    } = req.query;

    const offset = (parseInt(page) - 1) * parseInt(limit);
    let achievements = [];
    let total = 0;

    try {
      const where = {
        ...(active_only === 'true' && { is_active: true }),
        ...(include_hidden === 'false' && { is_hidden: false }),
        ...(category && { category })
      };

      [achievements, total] = await Promise.all([
        prisma.achievements.findMany({
          where,
          select: {
            id: true,
            name: true,
            description: true,
            badge_icon: true,
            category: true,
            criteria: true,
            reward_type: true,
            reward_value: true,
            is_hidden: true,
            sort_order: true,
            created_at: true,
            _count: {
              select: { user_achievements: true }
            }
          },
          orderBy: [
            { sort_order: 'asc' },
            { created_at: 'asc' }
          ],
          skip: offset,
          take: parseInt(limit)
        }),
        prisma.achievements.count({ where })
      ]);
    } catch (dbError) {
      console.log('Database not available, returning sample achievements');
      
      // Return sample achievements
      achievements = [
        {
          id: 1,
          name: 'First Branch',
          description: 'Generate your first olive branch',
          badge_icon: '🌿',
          category: 'collector',
          criteria: { required: 1 },
          reward_type: 'seeds',
          reward_value: 10,
          is_hidden: false,
          sort_order: 1,
          created_at: new Date(),
          _count: { user_achievements: 0 }
        },
        {
          id: 2,
          name: 'Dedicated Collector',
          description: 'Generate 10 olive branches',
          badge_icon: '🏆',
          category: 'collector',
          criteria: { required: 10 },
          reward_type: 'seeds',
          reward_value: 50,
          is_hidden: false,
          sort_order: 2,
          created_at: new Date(),
          _count: { user_achievements: 0 }
        }
      ];
      
      total = achievements.length;
    }

    const formattedAchievements = achievements.map(achievement => ({
      id: achievement.id,
      name: achievement.name,
      description: achievement.description,
      badge_icon: achievement.badge_icon,
      category: achievement.category,
      criteria: achievement.criteria,
      reward: {
        type: achievement.reward_type,
        value: achievement.reward_value
      },
      is_hidden: achievement.is_hidden,
      sort_order: achievement.sort_order,
      total_earned: achievement._count?.user_achievements || 0,
      created_at: achievement.created_at
    }));

    ResponseWrapper.paginated(res, formattedAchievements, {
      page: parseInt(page),
      limit: parseInt(limit),
      total
    });
  } catch (error) {
    next(error);
  }
});

// POST /api/achievements/:id/claim - Claim achievement rewards
router.post('/:id/claim', requireAuth, async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    try {
      // Get the user's achievement progress
      const userAchievement = await prisma.user_achievements.findUnique({
        where: {
          user_id_achievement_id: {
            user_id: userId,
            achievement_id: parseInt(id)
          }
        },
        include: {
          achievements: {
            select: {
              name: true,
              description: true,
              reward_type: true,
              reward_value: true
            }
          }
        }
      });

      if (!userAchievement) {
        return ResponseWrapper.notFound(res, 'Achievement not found or not unlocked');
      }

      if (!userAchievement.is_completed) {
        return ResponseWrapper.badRequest(res, 'Achievement not completed yet');
      }

      if (userAchievement.claimed_at) {
        return ResponseWrapper.badRequest(res, 'Achievement reward already claimed');
      }

      // Start transaction to claim reward
      const result = await prisma.$transaction(async (tx) => {
        // Mark achievement as claimed
        const claimedAchievement = await tx.user_achievements.update({
          where: {
            user_id_achievement_id: {
              user_id: userId,
              achievement_id: parseInt(id)
            }
          },
          data: {
            claimed_at: new Date()
          }
        });

        // Apply the reward based on type
        let rewardApplied = null;
        const achievement = userAchievement.achievements;

        if (achievement.reward_type === 'seeds' && achievement.reward_value > 0) {
          // TODO: Add seeds to user's inventory when seed system is implemented
          rewardApplied = {
            type: 'seeds',
            amount: achievement.reward_value
          };
        } else if (achievement.reward_type === 'points' && achievement.reward_value > 0) {
          // TODO: Add points to user when points system is implemented
          rewardApplied = {
            type: 'points',
            amount: achievement.reward_value
          };
        } else if (achievement.reward_type === 'badge_only') {
          rewardApplied = {
            type: 'badge',
            description: 'Badge unlocked for profile display'
          };
        } else if (achievement.reward_type === 'early_access') {
          rewardApplied = {
            type: 'early_access',
            description: 'Early access features unlocked'
          };
        }

        return {
          achievement: claimedAchievement,
          reward: rewardApplied
        };
      });

      ResponseWrapper.success(res, {
        achievement: {
          id: parseInt(id),
          name: userAchievement.achievements.name,
          description: userAchievement.achievements.description
        },
        reward_claimed: result.reward,
        claimed_at: result.achievement.claimed_at
      }, `Successfully claimed reward for "${userAchievement.achievements.name}"`);

    } catch (dbError) {
      return ResponseWrapper.notFound(res, 'Achievement system not available');
    }
  } catch (error) {
    next(error);
  }
});

module.exports = router;

// === END src/routes/achievements.js ===

// === src/routes/auth.js ===
// routes/auth.js - Fixed Enhanced Authentication with JWT
const express = require('express');
const bcrypt = require('bcrypt');
const { body, validationResult } = require('express-validator');
const { PrismaClient } = require('@prisma/client');
const JWTService = require('../utils/jwt');
const AuthMiddleware = require('../middleware/auth');
const { ResponseWrapper, ValidationError, UnauthorizedError, ConflictError } = require('../middleware/errorHandler');

const router = express.Router();
const prisma = new PrismaClient();

console.log('🔐 Enhanced Authentication routes loaded!');

// Store refresh tokens (in production, use Redis or database)
const refreshTokenStore = new Map();

// Helper function to generate ID number (from your existing system)
const generateIdNo = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

// POST /api/auth/register - User registration
router.post('/register',
  [
    body('username').isLength({ min: 3, max: 20 }).withMessage('Username must be 3-20 characters')
      .matches(/^[a-zA-Z0-9_]+$/).withMessage('Username can only contain letters, numbers, and underscores'),
    body('email').isEmail().withMessage('Valid email required'),
    body('password').isLength({ min: 8 }).withMessage('Password must be at least 8 characters')
      .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/).withMessage('Password must contain uppercase, lowercase, and number'),
    body('country').optional().isLength({ min: 1, max: 4 }).withMessage('Country must be 1-4 characters')
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Registration validation failed', errors.array());
      }

      const { username, email, password, country } = req.body;

      // FIXED: Check for existing user (users not user)
      const existingUser = await prisma.users.findFirst({
        where: {
          OR: [
            { username },
            { email }
          ]
        }
      });

      if (existingUser) {
        throw new ConflictError(
          existingUser.username === username ? 'Username already exists' : 'Email already registered'
        );
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(password, 12);

      // Generate unique ID number
      let idNo;
      let isUnique = false;
      while (!isUnique) {
        idNo = generateIdNo();
        const existingId = await prisma.users.findUnique({ where: { id_no: idNo } });
        isUnique = !existingId;
      }

      // FIXED: Create user (users not user, proper field names)
      const user = await prisma.users.create({
        data: {
          username,
          email,
          password_hash: hashedPassword,
          id_no: idNo,
          country: country || null,
          role: 'operative', // Default role
          created_at: new Date(),
          updated_at: new Date()
        },
        select: {
          id: true,
          username: true,
          email: true,
          role: true,
          id_no: true,
          created_at: true
        }
      });

      // FIXED: Generate initial inventory (inventory_items not inventoryItem)
      await prisma.inventory_items.create({
        data: {
          user_id: user.id,
          item_type: 'seed',
          quantity: 3,
          source_type: 'awarded',
          source_reference: 'new_user_bonus',
          grid_position: 0,
          created_at: new Date()
        }
      });

      // Generate tokens
      const tokens = JWTService.generateTokens(user);

      // Store refresh token
      refreshTokenStore.set(tokens.refreshToken, {
        userId: user.id,
        createdAt: new Date(),
        lastUsed: new Date()
      });

      return ResponseWrapper.created(res, {
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          role: user.role,
          idNo: user.id_no,
          joinedDate: user.created_at
        },
        tokens: {
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken,
          expiresIn: tokens.expiresIn
        },
        bonuses: {
          welcomeSeeds: 3,
          message: 'Welcome to Galway Research! You\'ve received 3 seeds to start growing olive branches.'
        }
      }, 'Registration successful');
    } catch (error) {
      next(error);
    }
  }
);

// POST /api/auth/login - User login
router.post('/login',
  [
    body('identifier').notEmpty().withMessage('Username or email required'),
    body('password').notEmpty().withMessage('Password required'),
    body('remember').optional().isBoolean().withMessage('Remember must be boolean')
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Login validation failed', errors.array());
      }

      const { identifier, password, remember = false } = req.body;

      // FIXED: Find user by username or email (users not user)
      const user = await prisma.users.findFirst({
        where: {
          OR: [
            { username: identifier },
            { email: identifier }
          ]
        },
        select: {
          id: true,
          username: true,
          email: true,
          password_hash: true,
          role: true,
          created_at: true,
          active_olive_branch_id: true
        }
      });

      if (!user) {
        throw new UnauthorizedError('Invalid credentials');
      }

      // FIXED: Verify password (password_hash not password)
      const isValidPassword = await bcrypt.compare(password, user.password_hash);
      if (!isValidPassword) {
        throw new UnauthorizedError('Invalid credentials');
      }

      // Update user timestamp
      await prisma.users.update({
        where: { id: user.id },
        data: { updated_at: new Date() }
      });

      // Generate tokens
      const tokens = JWTService.generateTokens(user);

      // Store refresh token
      refreshTokenStore.set(tokens.refreshToken, {
        userId: user.id,
        createdAt: new Date(),
        lastUsed: new Date(),
        extended: remember
      });

      // Remove password from response
      const { password_hash: _, ...userResponse } = user;

      return ResponseWrapper.success(res, {
        user: userResponse,
        tokens: {
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken,
          expiresIn: tokens.expiresIn
        },
        session: {
          loginTime: new Date().toISOString(),
          rememberMe: remember
        }
      }, 'Login successful');
    } catch (error) {
      next(error);
    }
  }
);

// POST /api/auth/refresh - Refresh access token
router.post('/refresh',
  [
    body('refreshToken').notEmpty().withMessage('Refresh token required')
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Refresh validation failed', errors.array());
      }

      const { refreshToken } = req.body;

      // Verify refresh token
      let decoded;
      try {
        decoded = JWTService.verifyRefreshToken(refreshToken);
      } catch (error) {
        throw new UnauthorizedError('Invalid refresh token');
      }

      // Check if refresh token is stored and valid
      const storedToken = refreshTokenStore.get(refreshToken);
      if (!storedToken || storedToken.userId !== decoded.userId) {
        throw new UnauthorizedError('Refresh token not found');
      }

      // FIXED: Get fresh user data (users not user)
      const user = await prisma.users.findUnique({
        where: { id: decoded.userId },
        select: {
          id: true,
          username: true,
          role: true,
          active_olive_branch_id: true
        }
      });

      if (!user) {
        throw new UnauthorizedError('User not found or inactive');
      }

      // Generate new tokens
      const newTokens = JWTService.generateTokens(user);

      // Remove old refresh token and store new one
      refreshTokenStore.delete(refreshToken);
      refreshTokenStore.set(newTokens.refreshToken, {
        userId: user.id,
        createdAt: new Date(),
        lastUsed: new Date(),
        extended: storedToken.extended
      });

      return ResponseWrapper.success(res, {
        tokens: {
          accessToken: newTokens.accessToken,
          refreshToken: newTokens.refreshToken,
          expiresIn: newTokens.expiresIn
        },
        user: {
          username: user.username,
          role: user.role
        }
      }, 'Token refreshed successfully');
    } catch (error) {
      next(error);
    }
  }
);

// GET /api/auth/me - Get current user info
router.get('/me',
  AuthMiddleware.requireAuth,
  async (req, res, next) => {
    try {
      // FIXED: users not user
      const user = await prisma.users.findUnique({
        where: { id: req.user.id },
        select: {
          id: true,
          username: true,
          email: true,
          role: true,
          country: true,
          created_at: true,
          active_olive_branch_id: true
        }
      });

      if (!user) {
        throw new UnauthorizedError('User not found');
      }

      return ResponseWrapper.success(res, {
        user: {
          ...user,
          permissions: req.user.permissions
        }
      });
    } catch (error) {
      next(error);
    }
  }
);

// POST /api/auth/logout - User logout
router.post('/logout',
  AuthMiddleware.requireAuth,
  [
    body('refreshToken').optional().isString().withMessage('Refresh token must be string'),
    body('allDevices').optional().isBoolean().withMessage('allDevices must be boolean')
  ],
  async (req, res, next) => {
    try {
      const { refreshToken, allDevices = false } = req.body;
      const userId = req.user.id;

      if (allDevices) {
        // Remove all refresh tokens for this user
        const tokensToDelete = [];
        for (const [token, data] of refreshTokenStore.entries()) {
          if (data.userId === userId) {
            tokensToDelete.push(token);
          }
        }
        tokensToDelete.forEach(token => refreshTokenStore.delete(token));
      } else if (refreshToken) {
        // Remove specific refresh token
        refreshTokenStore.delete(refreshToken);
      }

      return ResponseWrapper.success(res, {
        loggedOut: true,
        allDevices,
        message: allDevices ? 'Logged out from all devices' : 'Logged out successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);

module.exports = router;

// === END src/routes/auth.js ===

// === src/routes/catalog.js ===
// src/routes/catalog.js
// Complete Catalog System Routes with Digital/Physical Tabs
const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult, query } = require('express-validator');
const { requireAuth, requireRole, optionalAuth } = require('../middleware/auth');

const router = express.Router();
const prisma = new PrismaClient();

console.log('🛒 Complete Catalog System routes loaded successfully!');

// Custom error classes
class ValidationError extends Error {
  constructor(message, details = null) {
    super(message);
    this.statusCode = 400;
    this.code = 'VALIDATION_ERROR';
    this.details = details;
  }
}

class NotFoundError extends Error {
  constructor(message = 'Resource not found') {
    super(message);
    this.statusCode = 404;
    this.code = 'NOT_FOUND';
  }
}

class ForbiddenError extends Error {
  constructor(message = 'Access forbidden') {
    super(message);
    this.statusCode = 403;
    this.code = 'FORBIDDEN';
  }
}

// Helper function to calculate commission
const calculateCommission = (priceCents, commissionPercentage = 5.0) => {
  const commissionCents = Math.round(priceCents * (commissionPercentage / 100));
  const sellerEarnsCents = priceCents - commissionCents;
  return { commissionCents, sellerEarnsCents };
};

// =============================================
// DIGITAL CATALOG ROUTES
// =============================================

// GET /api/catalog/digital - Browse all digital items
router.get('/digital', optionalAuth, [
  query('category').optional().isIn(['seeds', 'branches', 'collectibles', 'themes', 'badges']),
  query('subcategory').optional(),
  query('sortBy').optional().isIn(['price', 'name', 'created', 'featured']),
  query('sortOrder').optional().isIn(['asc', 'desc']),
  query('page').optional().isInt({ min: 1 }),
  query('limit').optional().isInt({ min: 1, max: 50 })
], async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      throw new ValidationError('Invalid query parameters', errors.array());
    }

    const {
      category,
      subcategory,
      sortBy = 'featured',
      sortOrder = 'desc',
      page = 1,
      limit = 20
    } = req.query;

    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Build where clause for digital items
    const where = {
      isActive: true,
      itemType: {
        in: ['seed', 'digital_collectible', 'profile_theme', 'badge', 'inventory_expansion', 'generation_boost']
      }
    };

    // Apply category filters
    if (category === 'seeds') {
      where.itemType = 'seed';
    } else if (category === 'collectibles') {
      where.itemType = {
        in: ['digital_collectible', 'profile_theme', 'badge', 'inventory_expansion']
      };
    }

    // Apply availability window
    const now = new Date();
    where.AND = [
      {
        OR: [
          { availableFrom: null },
          { availableFrom: { lte: now } }
        ]
      },
      {
        OR: [
          { availableUntil: null },
          { availableUntil: { gte: now } }
        ]
      }
    ];

    // Check for active generation boosts (affects premium seed availability)
    const activeBoosts = await prisma.generationBoost.findMany({
      where: {
        isActive: true,
        startTime: { lte: now },
        endTime: { gte: now }
      }
    });

    // If no active boosts, hide boost-only premium seeds
    if (activeBoosts.length === 0) {
      where.seedDetails = {
        OR: [
          { isBoostOnly: false },
          { isBoostOnly: null }
        ]
      };
    }

    // Build sort options
    let orderBy = { sortOrder: 'asc' };
    if (sortBy === 'price') {
      orderBy = { priceCents: sortOrder };
    } else if (sortBy === 'name') {
      orderBy = { name: sortOrder };
    } else if (sortBy === 'created') {
      orderBy = { createdAt: sortOrder };
    } else if (sortBy === 'featured') {
      orderBy = [{ isFeatured: 'desc' }, { sortOrder: 'asc' }];
    }

    // Get items with related data
    const [items, total] = await Promise.all([
      prisma.catalogItem.findMany({
        where,
        include: {
          seedDetails: true,
          digitalDetails: true,
          _count: {
            select: {
              orderItems: {
                where: {
                  order: {
                    status: { in: ['pending', 'processing', 'shipped', 'delivered'] }
                  }
                }
              }
            }
          }
        },
        orderBy,
        skip: offset,
        take: parseInt(limit)
      }),
      prisma.catalogItem.count({ where })
    ]);

    // Add computed fields
    const itemsWithExtras = items.map(item => ({
      ...item,
      formattedPrice: `$${(item.priceCents / 100).toFixed(2)}`,
      isAvailable: item.stockQuantity === null || item.stockQuantity > 0,
      soldCount: item._count.orderItems,
      isSeed: item.itemType === 'seed',
      isCollectible: ['digital_collectible', 'profile_theme', 'badge', 'inventory_expansion'].includes(item.itemType),
      isBoostOnly: item.seedDetails?.isBoostOnly || false,
      canPurchase: req.user ? true : false // Guests can view but need to login to purchase
    }));

    const totalPages = Math.ceil(total / parseInt(limit));

    res.json({
      items: itemsWithExtras,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        totalPages,
        hasNext: parseInt(page) < totalPages,
        hasPrev: parseInt(page) > 1
      },
      filters: {
        category,
        subcategory,
        sortBy,
        sortOrder
      },
      activeBoosts: activeBoosts.map(boost => ({
        id: boost.id,
        name: boost.name,
        type: boost.boostType,
        endTime: boost.endTime
      })),
      categories: {
        seeds: {
          name: 'Seeds',
          count: await prisma.catalogItem.count({
            where: { ...where, itemType: 'seed' }
          })
        },
        collectibles: {
          name: 'Digital Collectibles',
          count: await prisma.catalogItem.count({
            where: {
              ...where,
              itemType: {
                in: ['digital_collectible', 'profile_theme', 'badge', 'inventory_expansion']
              }
            }
          })
        }
      }
    });

  } catch (error) {
    console.error('🔴 Error fetching digital catalog:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
        details: error.details
      });
    }
    next(error);
  }
});

// GET /api/catalog/digital/seeds - Dedicated seeds endpoint
router.get('/digital/seeds', optionalAuth, [
  query('category').optional().isIn(['basic', 'premium', 'seasonal', 'vintage_2024', 'new_age_2025']),
  query('onlyAvailable').optional().isBoolean()
], async (req, res, next) => {
  try {
    const { category, onlyAvailable = 'true' } = req.query;

    const where = {
      isActive: true,
      itemType: 'seed',
      seedDetails: { isNot: null }
    };

    if (category) {
      where.seedDetails = { category };
    }

    // Check boost availability for premium seeds
    const now = new Date();
    const activeBoosts = await prisma.generationBoost.findMany({
      where: {
        isActive: true,
        startTime: { lte: now },
        endTime: { gte: now }
      }
    });

    if (onlyAvailable === 'true' && activeBoosts.length === 0) {
      // Hide boost-only seeds when no active boosts
      where.seedDetails = {
        ...where.seedDetails,
        isBoostOnly: false
      };
    }

    const seeds = await prisma.catalogItem.findMany({
      where,
      include: {
        seedDetails: true
      },
      orderBy: [
        { isFeatured: 'desc' },
        { seedDetails: { category: 'asc' } },
        { priceCents: 'asc' }
      ]
    });

    // Group by category
    const categorizedSeeds = {
      basic: [],
      premium: [],
      seasonal: [],
      vintage_2024: [],
      new_age_2025: []
    };

    seeds.forEach(seed => {
      const cat = seed.seedDetails.category;
      if (categorizedSeeds[cat]) {
        categorizedSeeds[cat].push({
          ...seed,
          formattedPrice: `$${(seed.priceCents / 100).toFixed(2)}`,
          isAvailable: !seed.seedDetails.isBoostOnly || activeBoosts.length > 0,
          needsBoost: seed.seedDetails.isBoostOnly && activeBoosts.length === 0,
          rarityBoost: seed.seedDetails.rarityBoostPercentage
        });
      }
    });

    res.json({
      categorizedSeeds,
      activeBoosts,
      seedInfo: {
        basic: {
          name: 'Basic Seeds',
          description: 'Standard olive branch generation with normal rarity rates',
          price: '$2.50',
          always_available: true
        },
        premium: {
          name: 'Premium Seeds',
          description: 'Enhanced rarity chances - only available during generation boosts',
          price: '$2.50',
          boost_only: true
        },
        seasonal: {
          name: 'Seasonal Seeds',
          description: 'Limited-time seeds with special color palettes and themes',
          price: '$10.00',
          limited_time: true
        },
        vintage_2024: {
          name: 'Vintage Collection (2024)',
          description: 'Original style branches documenting the early days',
          year: 2024
        },
        new_age_2025: {
          name: 'New Age Collection (2025)',
          description: 'Updated generation algorithms with modern aesthetics',
          year: 2025
        }
      }
    });

  } catch (error) {
    console.error('🔴 Error fetching seeds:', error);
    next(error);
  }
});

// =============================================
// USER MARKETPLACE ROUTES (Branches)
// =============================================

// GET /api/catalog/digital/branches - Browse user marketplace
router.get('/digital/branches', optionalAuth, [
  query('rarity').optional().isIn(['Common', 'Uncommon', 'Rare', 'Very Rare', 'Legendary']),
  query('oliveType').optional(),
  query('priceMin').optional().isInt({ min: 0 }),
  query('priceMax').optional().isInt({ min: 0 }),
  query('sortBy').optional().isIn(['price', 'created', 'rarity']),
  query('sortOrder').optional().isIn(['asc', 'desc']),
  query('bundlesOnly').optional().isBoolean(),
  query('page').optional().isInt({ min: 1 }),
  query('limit').optional().isInt({ min: 1, max: 50 })
], async (req, res, next) => {
  try {
    const {
      rarity,
      oliveType,
      priceMin,
      priceMax,
      sortBy = 'created',
      sortOrder = 'desc',
      bundlesOnly = 'false',
      page = 1,
      limit = 20
    } = req.query;

    const offset = (parseInt(page) - 1) * parseInt(limit);

    const where = {
      status: 'active',
      expiresAt: { gt: new Date() }
    };

    // Bundle filter
    if (bundlesOnly === 'true') {
      where.isBundle = true;
    }

    // Price filters
    if (priceMin) where.priceCents = { gte: parseInt(priceMin) * 100 };
    if (priceMax) {
      where.priceCents = {
        ...where.priceCents,
        lte: parseInt(priceMax) * 100
      };
    }

    // Rarity and type filters (need to filter through branch relationship)
    const branchWhere = {};
    if (rarity) branchWhere.countRarity = rarity;
    if (oliveType) branchWhere.oliveType = { contains: oliveType, mode: 'insensitive' };

    if (Object.keys(branchWhere).length > 0) {
      where.OR = [
        { branch: branchWhere }, // Individual listings
        { 
          bundleBranches: {
            some: { branch: branchWhere }
          }
        } // Bundle listings containing matching branches
      ];
    }

    // Sort options
    let orderBy = { createdAt: sortOrder };
    if (sortBy === 'price') {
      orderBy = { priceCents: sortOrder };
    }

    const [listings, total] = await Promise.all([
      prisma.branchListing.findMany({
        where,
        include: {
          seller: {
            select: {
              id: true,
              username: true,
              role: true
            }
          },
          branch: {
            select: {
              id: true,
              botanicalId: true,
              oliveCount: true,
              oliveType: true,
              countRarity: true,
              typeRarity: true,
              countRarityPercentage: true,
              typeRarityPercentage: true,
              oliveColor: true,
              branchColor: true,
              leafColor: true
            }
          },
          bundleBranches: {
            include: {
              branch: {
                select: {
                  id: true,
                  botanicalId: true,
                  oliveCount: true,
                  oliveType: true,
                  countRarity: true,
                  typeRarity: true,
                  countRarityPercentage: true,
                  typeRarityPercentage: true,
                  oliveColor: true,
                  branchColor: true,
                  leafColor: true
                }
              }
            }
          }
        },
        orderBy,
        skip: offset,
        take: parseInt(limit)
      }),
      prisma.branchListing.count({ where })
    ]);

    // Add computed fields
    const listingsWithExtras = listings.map(listing => {
      const { commissionCents, sellerEarnsCents } = calculateCommission(
        listing.priceCents,
        listing.commissionPercentage
      );

      return {
        ...listing,
        formattedPrice: `$${(listing.priceCents / 100).toFixed(2)}`,
        sellerEarns: `$${(sellerEarnsCents / 100).toFixed(2)}`,
        platformFee: `$${(commissionCents / 100).toFixed(2)}`,
        bundleSize: listing.isBundle ? listing.bundleBranches.length : 1,
        primaryBranch: listing.isBundle ? listing.bundleBranches[0]?.branch : listing.branch,
        canPurchase: req.user?.id !== listing.sellerId,
        svgUrl: listing.isBundle 
          ? `/api/olive-branches/${listing.bundleBranches[0]?.branch?.id}/svg`
          : `/api/olive-branches/${listing.branch?.id}/svg`
      };
    });

    const totalPages = Math.ceil(total / parseInt(limit));

    res.json({
      listings: listingsWithExtras,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        totalPages,
        hasNext: parseInt(page) < totalPages,
        hasPrev: parseInt(page) > 1
      },
      filters: {
        rarity,
        oliveType,
        priceMin,
        priceMax,
        bundlesOnly,
        sortBy,
        sortOrder
      },
      marketplaceInfo: {
        totalListings: total,
        commission: '5%',
        minPrice: '$1.00',
        maxPrice: '$500.00'
      }
    });

  } catch (error) {
    console.error('🔴 Error fetching branch marketplace:', error);
    next(error);
  }
});

// POST /api/catalog/digital/branches/list - Create new branch listing
router.post('/digital/branches/list', requireAuth, [
  body('branchIds').isArray({ min: 1 }).withMessage('At least one branch required'),
  body('priceCents').isInt({ min: 100, max: 50000 }).withMessage('Price must be between $1.00 and $500.00'),
  body('title').isLength({ min: 3, max: 200 }).withMessage('Title must be 3-200 characters'),
  body('description').optional().isLength({ max: 1000 }).withMessage('Description max 1000 characters'),
  body('isBundle').optional().isBoolean()
], async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      throw new ValidationError('Invalid listing data', errors.array());
    }

    const {
      branchIds,
      priceCents,
      title,
      description,
      isBundle = false
    } = req.body;

    // Validate user owns all branches
    const userBranches = await prisma.oliveBranch.findMany({
      where: {
        id: { in: branchIds },
        userId: req.user.id
      },
      include: {
        inventoryItems: true,
        branchListings: {
          where: {
            status: { in: ['active', 'draft'] }
          }
        }
      }
    });

    if (userBranches.length !== branchIds.length) {
      throw new ForbiddenError('You can only list branches you own');
    }

    // Check that branches aren\'t already listed
    const alreadyListed = userBranches.filter(branch => branch.branchListings.length > 0);
    if (alreadyListed.length > 0) {
      throw new ValidationError(`Some branches are already listed: ${alreadyListed.map(b => b.botanicalId).join(', ')}`);
    }

    // Check platform price limits
    const config = await prisma.siteConfig.findMany({
      where: {
        key: { in: ['marketplace_min_price', 'marketplace_max_price'] }
      }
    });

    const minPrice = config.find(c => c.key === 'marketplace_min_price')?.value || 100;
    const maxPrice = config.find(c => c.key === 'marketplace_max_price')?.value || 50000;

    if (priceCents < minPrice || priceCents > maxPrice) {
      throw new ValidationError(`Price must be between $${minPrice/100} and $${maxPrice/100}`);
    }

    // Create listing
    const result = await prisma.$transaction(async (tx) => {
      // Create the listing
      const listing = await tx.branchListing.create({
        data: {
          sellerId: req.user.id,
          branchId: isBundle ? null : branchIds[0],
          isBundle,
          priceCents,
          title,
          description,
          status: 'active',
          listedAt: new Date(),
          expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
          minPriceCents: minPrice,
          maxPriceCents: maxPrice
        }
      });

      // If bundle, create bundle associations
      if (isBundle && branchIds.length > 1) {
        await tx.branchListingBundle.createMany({
          data: branchIds.map(branchId => ({
            listingId: listing.id,
            branchId
          }))
        });
      }

      return listing;
    });

    console.log('🟢 Branch listing created:', result.id, 'by user:', req.user.id);

    res.status(201).json({
      message: 'Branch listing created successfully!',
      listing: {
        id: result.id,
        title: result.title,
        price: `$${(result.priceCents / 100).toFixed(2)}`,
        isBundle,
        branchCount: branchIds.length,
        status: result.status,
        expiresAt: result.expiresAt
      }
    });

  } catch (error) {
    console.error('🔴 Error creating branch listing:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
        details: error.details
      });
    }
    next(error);
  }
});

// =============================================
// PHYSICAL CATALOG ROUTES
// =============================================

// GET /api/catalog/physical - Browse physical merchandise
router.get('/physical', optionalAuth, [
  query('category').optional().isIn(['apparel', 'accessories', 'collectibles', 'functional', 'premium_limited']),
  query('sortBy').optional().isIn(['price', 'name', 'created', 'featured']),
  query('sortOrder').optional().isIn(['asc', 'desc']),
  query('inStock').optional().isBoolean()
], async (req, res, next) => {
  try {
    const {
      category,
      sortBy = 'featured',
      sortOrder = 'desc',
      inStock = 'true'
    } = req.query;

    const where = {
      isActive: true,
      itemType: 'physical_item',
      physicalDetails: { isNot: null }
    };

    if (category) {
      where.physicalDetails = { category };
    }

    if (inStock === 'true') {
      where.OR = [
        { stockQuantity: null }, // Unlimited stock
        { stockQuantity: { gt: 0 } } // Has stock
      ];
    }

    // Build sort
    let orderBy = [{ isFeatured: 'desc' }, { sortOrder: 'asc' }];
    if (sortBy === 'price') {
      orderBy = { priceCents: sortOrder };
    } else if (sortBy === 'name') {
      orderBy = { name: sortOrder };
    } else if (sortBy === 'created') {
      orderBy = { createdAt: sortOrder };
    }

    const items = await prisma.catalogItem.findMany({
      where,
      include: {
        physicalDetails: true,
        _count: {
          select: {
            orderItems: {
              where: {
                order: {
                  status: { in: ['delivered'] }
                }
              }
            }
          }
        }
      },
      orderBy
    });

    // Group by category
    const categorizedItems = {
      apparel: [],
      accessories: [],
      collectibles: [],
      functional: [],
      premium_limited: []
    };

    items.forEach(item => {
      const cat = item.physicalDetails.category;
      if (categorizedItems[cat]) {
        categorizedItems[cat].push({
          ...item,
          formattedPrice: `$${(item.priceCents / 100).toFixed(2)}`,
          isInStock: item.stockQuantity === null || item.stockQuantity > 0,
          soldCount: item._count.orderItems,
          requiresShipping: item.physicalDetails.requiresShipping,
          hasVariants: item.physicalDetails.hasVariants
        });
      }
    });

    res.json({
      categorizedItems,
      categories: {
        apparel: {
          name: 'Apparel & Clothing',
          description: 'T-shirts, hoodies, and branded clothing',
          icon: '👕'
        },
        accessories: {
          name: 'Accessories',
          description: 'Pins, lanyards, and wearable items',
          icon: '📌'
        },
        collectibles: {
          name: 'Collectibles & Art',
          description: 'Patches, posters, and limited edition items',
          icon: '🎨'
        },
        functional: {
          name: 'Functional Items',
          description: 'Mugs, notebooks, and everyday use items',
          icon: '☕'
        },
        premium_limited: {
          name: 'Premium & Limited',
          description: 'Exclusive items and beta tester rewards',
          icon: '⭐'
        }
      },
      shippingInfo: {
        freeShippingOver: '$50.00',
        internationalShipping: true,
        estimatedDelivery: '5-7 business days'
      }
    });

  } catch (error) {
    console.error('🔴 Error fetching physical catalog:', error);
    next(error);
  }
});

// GET /api/catalog/physical/:id - Get detailed physical item info
router.get('/physical/:id', optionalAuth, async (req, res, next) => {
  try {
    const itemId = parseInt(req.params.id);
    if (isNaN(itemId)) {
      throw new ValidationError('Invalid item ID');
    }

    const item = await prisma.catalogItem.findFirst({
      where: {
        id: itemId,
        isActive: true,
        itemType: 'physical_item'
      },
      include: {
        physicalDetails: true
      }
    });

    if (!item) {
      throw new NotFoundError('Physical item not found');
    }

    res.json({
      item: {
        ...item,
        formattedPrice: `$${(item.priceCents / 100).toFixed(2)}`,
        isInStock: item.stockQuantity === null || item.stockQuantity > 0,
        requiresShipping: item.physicalDetails.requiresShipping,
        variants: item.physicalDetails.variants || [],
        shipping: {
          weight: item.physicalDetails.shippingWeightGrams,
          class: item.physicalDetails.shippingClass,
          dimensions: item.physicalDetails.dimensions
        }
      }
    });

  } catch (error) {
    console.error('🔴 Error fetching physical item:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code
      });
    }
    next(error);
  }
});

// =============================================
// CART & CHECKOUT ROUTES
// =============================================

// GET /api/catalog/cart - Get user's cart
router.get('/cart', requireAuth, async (req, res, next) => {
  try {
    let cart = await prisma.cart.findUnique({
      where: { userId: req.user.id },
      include: {
        items: {
          include: {
            catalogItem: {
              include: {
                seedDetails: true,
                physicalDetails: true,
                digitalDetails: true
              }
            },
            branchListing: {
              include: {
                branch: true,
                bundleBranches: {
                  include: { branch: true }
                },
                seller: {
                  select: { username: true }
                }
              }
            }
          }
        }
      }
    });

    if (!cart) {
      // Create empty cart
      cart = await prisma.cart.create({
        data: { userId: req.user.id },
        include: { items: [] }
      });
    }

    // Calculate totals
    let subtotalCents = 0;
    let shippingCents = 0;
    let hasPhysicalItems = false;

    const itemsWithDetails = cart.items.map(item => {
      const price = item.catalogItem?.priceCents || item.branchListing?.priceCents || 0;
      const itemTotal = price * item.quantity;
      subtotalCents += itemTotal;

      // Check if item requires shipping
      if (item.catalogItem?.physicalDetails?.requiresShipping) {
        hasPhysicalItems = true;
      }

      return {
        ...item,
        unitPrice: `$${(price / 100).toFixed(2)}`,
        totalPrice: `$${(itemTotal / 100).toFixed(2)}`,
        isPhysical: item.catalogItem?.itemType === 'physical_item',
        isMarketplace: !!item.branchListing
      };
    });

    // Calculate shipping for physical items
    if (hasPhysicalItems && subtotalCents < 5000) { // Free shipping over $50
      shippingCents = 500; // $5.00 standard shipping
    }

    const totalCents = subtotalCents + shippingCents;

    res.json({
      cart: {
        id: cart.id,
        items: itemsWithDetails,
        itemCount: cart.items.length,
        subtotal: `$${(subtotalCents / 100).toFixed(2)}`,
        shipping: `$${(shippingCents / 100).toFixed(2)}`,
        total: `$${(totalCents / 100).toFixed(2)}`,
        hasPhysicalItems,
        freeShippingEligible: subtotalCents >= 5000
      }
    });

  } catch (error) {
    console.error('🔴 Error fetching cart:', error);
    next(error);
  }
});

// POST /api/catalog/cart/add - Add item to cart
router.post('/cart/add', requireAuth, [
  body('catalogItemId').optional().isInt(),
  body('branchListingId').optional().isInt(),
  body('quantity').optional().isInt({ min: 1, max: 10 }),
  body('selectedVariant').optional().isObject()
], async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      throw new ValidationError('Invalid cart data', errors.array());
    }

    const { catalogItemId, branchListingId, quantity = 1, selectedVariant } = req.body;

    if (!catalogItemId && !branchListingId) {
      throw new ValidationError('Either catalogItemId or branchListingId required');
    }

    // Get or create cart
    let cart = await prisma.cart.findUnique({
      where: { userId: req.user.id }
    });

    if (!cart) {
      cart = await prisma.cart.create({
        data: { userId: req.user.id }
      });
    }

    let item = null;
    let priceAtTime = 0;

    if (catalogItemId) {
      // Adding catalog item
      item = await prisma.catalogItem.findFirst({
        where: {
          id: catalogItemId,
          isActive: true
        }
      });

      if (!item) {
        throw new NotFoundError('Catalog item not found');
      }

      priceAtTime = item.priceCents;

      // Check stock
      if (item.stockQuantity !== null && item.stockQuantity < quantity) {
        throw new ValidationError('Insufficient stock');
      }

    } else if (branchListingId) {
      // Adding marketplace item
      const listing = await prisma.branchListing.findFirst({
        where: {
          id: branchListingId,
          status: 'active',
          sellerId: { not: req.user.id } // Can't buy your own listing
        }
      });

      if (!listing) {
        throw new NotFoundError('Branch listing not found or unavailable');
      }

      priceAtTime = listing.priceCents;
    }

    // Add to cart
    const cartItem = await prisma.cartItem.create({
      data: {
        cartId: cart.id,
        catalogItemId,
        branchListingId,
        quantity,
        priceAtTime,
        selectedVariant
      }
    });

    console.log('🟢 Item added to cart:', cartItem.id, 'for user:', req.user.id);

    res.status(201).json({
      message: 'Item added to cart successfully!',
      cartItem: {
        id: cartItem.id,
        quantity: cartItem.quantity,
        price: `$${(priceAtTime / 100).toFixed(2)}`
      }
    });

  } catch (error) {
    console.error('🔴 Error adding to cart:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
        details: error.details
      });
    }
    next(error);
  }
});

module.exports = router;

// === END src/routes/catalog.js ===

// === src/routes/checkout.js ===
// src/routes/checkout.js
// Checkout and Payment Processing Routes
const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult } = require('express-validator');
const { requireAuth } = require('../middleware/auth');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

const router = express.Router();
const prisma = new PrismaClient();

console.log('💳 Checkout and Payment routes loaded successfully!');

// Custom error classes
class ValidationError extends Error {
  constructor(message, details = null) {
    super(message);
    this.statusCode = 400;
    this.code = 'VALIDATION_ERROR';
    this.details = details;
  }
}

class PaymentError extends Error {
  constructor(message, details = null) {
    super(message);
    this.statusCode = 402;
    this.code = 'PAYMENT_ERROR';
    this.details = details;
  }
}

// Helper function to generate order number
const generateOrderNumber = () => {
  const timestamp = Date.now().toString().slice(-8);
  const random = Math.random().toString(36).substring(2, 6).toUpperCase();
  return `GRI-${timestamp}-${random}`;
};

// Helper function to calculate shipping
const calculateShipping = (items, shippingAddress) => {
  const physicalItems = items.filter(item => 
    item.catalogItem?.physicalDetails?.requiresShipping
  );

  if (physicalItems.length === 0) return 0;

  // Calculate total weight
  const totalWeight = physicalItems.reduce((weight, item) => {
    const itemWeight = item.catalogItem.physicalDetails.shippingWeightGrams || 100;
    return weight + (itemWeight * item.quantity);
  }, 0);

  // Basic shipping calculation
  let shippingCents = 500; // Base $5.00

  if (totalWeight > 1000) shippingCents += 200; // +$2.00 for over 1kg
  if (totalWeight > 2000) shippingCents += 300; // +$3.00 for over 2kg

  // International shipping
  if (shippingAddress?.country && shippingAddress.country !== 'US') {
    shippingCents += 1000; // +$10.00 international
  }

  return shippingCents;
};

// Helper function to deliver digital items
const deliverDigitalItems = async (order, tx) => {
  const digitalItems = order.items.filter(item => 
    item.catalogItem?.itemType !== 'physical_item'
  );

  for (const item of digitalItems) {
    const catalogItem = item.catalogItem;
    
    if (catalogItem.itemType === 'seed') {
      // Add seeds to user inventory
      const existingSeeds = await tx.inventoryItem.findFirst({
        where: {
          userId: order.userId,
          itemType: 'seed',
          sourceType: 'purchase'
        }
      });

      if (existingSeeds) {
        await tx.inventoryItem.update({
          where: { id: existingSeeds.id },
          data: { quantity: { increment: item.quantity } }
        });
      } else {
        // Get next grid position
        const maxPosition = await tx.inventoryItem.findFirst({
          where: { userId: order.userId },
          orderBy: { gridPosition: 'desc' },
          select: { gridPosition: true }
        });

        const nextPosition = maxPosition?.gridPosition !== null && maxPosition?.gridPosition !== undefined
          ? maxPosition.gridPosition + 1
          : 0;

        await tx.inventoryItem.create({
          data: {
            userId: order.userId,
            itemType: 'seed',
            quantity: item.quantity,
            sourceType: 'purchase',
            sourceReference: `order-${order.orderNumber}`,
            gridPosition: nextPosition
          }
        });
      }
    } else if (catalogItem.itemType === 'digital_collectible') {
      // Handle different types of digital collectibles
      const digitalDetails = catalogItem.digitalDetails;
      
      if (digitalDetails.collectibleType === 'inventory_expansion') {
        // Expand user inventory (implement based on your inventory system)
        console.log(`🎒 Expanding inventory for user ${order.userId} by ${digitalDetails.slotsAdded} slots`);
      
      } else if (digitalDetails.collectibleType === 'generation_boost') {
        // Add generation boost to user
        await tx.userGenerationBoost.create({
          data: {
            userId: order.userId,
            boostId: digitalDetails.boostType, // You'll need to map this properly
            usesRemaining: digitalDetails.boostDurationHours || 24,
            expiresAt: new Date(Date.now() + (digitalDetails.boostDurationHours || 24) * 60 * 60 * 1000)
          }
        });
      
      } else if (digitalDetails.collectibleType === 'profile_theme') {
        // Add theme to user themes
        await tx.userTheme.create({
          data: {
            userId: order.userId,
            name: catalogItem.name,
            themeData: digitalDetails.themeData,
            isActive: false,
            isPublic: false
          }
        });
      }
    }

    // Mark item as delivered
    await tx.orderItem.update({
      where: { id: item.id },
      data: {
        isDelivered: true,
        deliveredAt: new Date(),
        digitalContent: {
          itemType: catalogItem.itemType,
          itemName: catalogItem.name,
          details: catalogItem.digitalDetails || catalogItem.seedDetails
        }
      }
    });
  }
};

// =============================================
// CHECKOUT FLOW
// =============================================

// POST /api/checkout/validate - Validate cart and calculate totals
router.post('/validate', requireAuth, [
  body('shippingAddress').optional().isObject(),
  body('shippingMethod').optional().isString()
], async (req, res, next) => {
  try {
    const { shippingAddress, shippingMethod } = req.body;

    // Get user's cart
    const cart = await prisma.cart.findUnique({
      where: { userId: req.user.id },
      include: {
        items: {
          include: {
            catalogItem: {
              include: {
                seedDetails: true,
                physicalDetails: true,
                digitalDetails: true
              }
            },
            branchListing: {
              include: {
                seller: { select: { username: true } },
                branch: true,
                bundleBranches: { include: { branch: true } }
              }
            }
          }
        }
      }
    });

    if (!cart || cart.items.length === 0) {
      throw new ValidationError('Cart is empty');
    }

    // Validate each item
    const validationErrors = [];
    let subtotalCents = 0;

    for (const item of cart.items) {
      if (item.catalogItem) {
        // Catalog item validation
        if (!item.catalogItem.isActive) {
          validationErrors.push(`Item "${item.catalogItem.name}" is no longer available`);
          continue;
        }

        // Stock check
        if (item.catalogItem.stockQuantity !== null && 
            item.catalogItem.stockQuantity < item.quantity) {
          validationErrors.push(`Insufficient stock for "${item.catalogItem.name}"`);
          continue;
        }

        // Price validation (check for price changes)
        if (item.priceAtTime !== item.catalogItem.priceCents) {
          validationErrors.push(`Price changed for "${item.catalogItem.name}"`);
        }

        subtotalCents += item.catalogItem.priceCents * item.quantity;

      } else if (item.branchListing) {
        // Marketplace item validation
        if (item.branchListing.status !== 'active') {
          validationErrors.push(`Branch listing is no longer available`);
          continue;
        }

        if (item.branchListing.sellerId === req.user.id) {
          validationErrors.push(`Cannot purchase your own listing`);
          continue;
        }

        subtotalCents += item.branchListing.priceCents * item.quantity;
      }
    }

    if (validationErrors.length > 0) {
      throw new ValidationError('Cart validation failed', validationErrors);
    }

    // Calculate shipping
    const shippingCents = calculateShipping(cart.items, shippingAddress);
    
    // Apply free shipping threshold
    const freeShippingThreshold = 5000; // $50.00
    const finalShippingCents = subtotalCents >= freeShippingThreshold ? 0 : shippingCents;

    // Calculate tax (implement based on your tax requirements)
    const taxCents = 0; // Add tax calculation logic

    const totalCents = subtotalCents + finalShippingCents + taxCents;

    // Check minimum order amount
    if (totalCents < 100) { // $1.00 minimum
      throw new ValidationError('Order total must be at least $1.00');
    }

    res.json({
      validation: {
        isValid: true,
        errors: []
      },
      totals: {
        subtotalCents,
        shippingCents: finalShippingCents,
        taxCents,
        totalCents,
        formatted: {
          subtotal: `$${(subtotalCents / 100).toFixed(2)}`,
          shipping: `$${(finalShippingCents / 100).toFixed(2)}`,
          tax: `$${(taxCents / 100).toFixed(2)}`,
          total: `$${(totalCents / 100).toFixed(2)}`
        }
      },
      freeShipping: subtotalCents >= freeShippingThreshold,
      requiresShipping: cart.items.some(item => 
        item.catalogItem?.physicalDetails?.requiresShipping
      )
    });

  } catch (error) {
    console.error('🔴 Error validating checkout:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
        details: error.details
      });
    }
    next(error);
  }
});

// POST /api/checkout/create-payment-intent - Create Stripe payment intent
router.post('/create-payment-intent', requireAuth, [
  body('shippingAddress').optional().isObject(),
  body('saveAddress').optional().isBoolean()
], async (req, res, next) => {
  try {
    const { shippingAddress } = req.body;

    // Validate cart first
    const validationResponse = await fetch(`${req.protocol}://${req.get('host')}/api/checkout/validate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': req.headers.authorization
      },
      body: JSON.stringify({ shippingAddress })
    });

    if (!validationResponse.ok) {
      const error = await validationResponse.json();
      throw new ValidationError('Cart validation failed', error.details);
    }

    const { totals } = await validationResponse.json();

    // Create Stripe payment intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount: totals.totalCents,
      currency: 'usd',
      metadata: {
        userId: req.user.id.toString(),
        orderType: 'catalog_purchase'
      },
      automatic_payment_methods: {
        enabled: true
      }
    });

    // Store payment record
    const payment = await prisma.payment.create({
      data: {
        userId: req.user.id,
        stripePaymentIntentId: paymentIntent.id,
        amountCents: totals.totalCents,
        currency: 'USD',
        paymentType: 'physical_item', // Update based on cart contents
        status: 'pending'
      }
    });

    console.log('🟢 Payment intent created:', paymentIntent.id, 'for user:', req.user.id);

    res.json({
      clientSecret: paymentIntent.client_secret,
      paymentIntentId: paymentIntent.id,
      paymentId: payment.id,
      amount: totals.formatted.total
    });

  } catch (error) {
    console.error('🔴 Error creating payment intent:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
        details: error.details
      });
    }
    next(error);
  }
});

// POST /api/checkout/complete - Complete order after payment
router.post('/complete', requireAuth, [
  body('paymentIntentId').notEmpty().withMessage('Payment intent ID required'),
  body('shippingAddress').optional().isObject()
], async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      throw new ValidationError('Invalid completion data', errors.array());
    }

    const { paymentIntentId, shippingAddress } = req.body;

    // Verify payment with Stripe
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    
    if (paymentIntent.status !== 'succeeded') {
      throw new PaymentError('Payment not completed');
    }

    if (paymentIntent.metadata.userId !== req.user.id.toString()) {
      throw new PaymentError('Payment user mismatch');
    }

    // Get cart and create order
    const result = await prisma.$transaction(async (tx) => {
      const cart = await tx.cart.findUnique({
        where: { userId: req.user.id },
        include: {
          items: {
            include: {
              catalogItem: {
                include: {
                  seedDetails: true,
                  physicalDetails: true,
                  digitalDetails: true
                }
              },
              branchListing: {
                include: {
                  seller: true,
                  branch: true,
                  bundleBranches: { include: { branch: true } }
                }
              }
            }
          }
        }
      });

      if (!cart || cart.items.length === 0) {
        throw new ValidationError('Cart is empty');
      }

      // Calculate totals
      let subtotalCents = 0;
      const orderItems = [];

      for (const item of cart.items) {
        let itemPrice = 0;
        let itemName = '';
        let itemType = 'seed';

        if (item.catalogItem) {
          itemPrice = item.catalogItem.priceCents;
          itemName = item.catalogItem.name;
          itemType = item.catalogItem.itemType;
          
          // Update stock
          if (item.catalogItem.stockQuantity !== null) {
            await tx.catalogItem.update({
              where: { id: item.catalogItem.id },
              data: { stockQuantity: { decrement: item.quantity } }
            });
          }

        } else if (item.branchListing) {
          itemPrice = item.branchListing.priceCents;
          itemName = `Branch: ${item.branchListing.branch?.botanicalId || 'Bundle'}`;
          itemType = 'branch_listing';

          // Handle marketplace purchase
          const { commissionCents, sellerEarnsCents } = calculateCommission(
            item.branchListing.priceCents, 
            item.branchListing.commissionPercentage
          );

          await tx.branchPurchase.create({
            data: {
              listingId: item.branchListing.id,
              buyerId: req.user.id,
              totalCents: itemPrice,
              commissionCents,
              sellerEarnsCents,
              status: 'pending'
            }
          });

          // Mark listing as sold
          await tx.branchListing.update({
            where: { id: item.branchListing.id },
            data: { 
              status: 'sold',
              soldAt: new Date()
            }
          });
        }

        subtotalCents += itemPrice * item.quantity;

        orderItems.push({
          catalogItemId: item.catalogItemId,
          itemName,
          itemType,
          quantity: item.quantity,
          unitPriceCents: itemPrice,
          totalPriceCents: itemPrice * item.quantity,
          selectedVariant: item.selectedVariant
        });
      }

      const shippingCents = calculateShipping(cart.items, shippingAddress);
      const finalShippingCents = subtotalCents >= 5000 ? 0 : shippingCents;
      const totalCents = subtotalCents + finalShippingCents;

      // Create order
      const order = await tx.order.create({
        data: {
          userId: req.user.id,
          orderNumber: generateOrderNumber(),
          status: 'pending',
          subtotalCents,
          shippingCents: finalShippingCents,
          taxCents: 0,
          totalCents,
          currency: 'USD',
          shippingAddress,
          shippingMethod: finalShippingCents > 0 ? 'standard' : 'free'
        }
      });

      // Create order items
      for (const itemData of orderItems) {
        await tx.orderItem.create({
          data: {
            orderId: order.id,
            ...itemData
          }
        });
      }

      // Update payment record
      await tx.payment.update({
        where: { stripePaymentIntentId: paymentIntentId },
        data: {
          status: 'succeeded',
          completedAt: new Date(),
          referenceId: order.id
        }
      });

      // Get complete order for digital delivery
      const completeOrder = await tx.order.findUnique({
        where: { id: order.id },
        include: {
          items: {
            include: {
              catalogItem: {
                include: {
                  seedDetails: true,
                  digitalDetails: true
                }
              }
            }
          }
        }
      });

      // Deliver digital items immediately
      await deliverDigitalItems(completeOrder, tx);

      // Clear cart
      await tx.cartItem.deleteMany({
        where: { cartId: cart.id }
      });

      return order;
    });

    console.log('🟢 Order completed:', result.orderNumber, 'for user:', req.user.id);

    res.json({
      message: 'Order completed successfully!',
      order: {
        id: result.id,
        orderNumber: result.orderNumber,
        total: `$${(result.totalCents / 100).toFixed(2)}`,
        status: result.status
      },
      redirectUrl: `/orders/${result.orderNumber}`
    });

  } catch (error) {
    console.error('🔴 Error completing order:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
        details: error.details
      });
    }
    next(error);
  }
});

// =============================================
// MARKETPLACE PURCHASE ROUTES
// =============================================

// POST /api/checkout/marketplace/purchase - Direct marketplace purchase
router.post('/marketplace/purchase', requireAuth, [
  body('listingId').isInt().withMessage('Valid listing ID required')
], async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      throw new ValidationError('Invalid purchase data', errors.array());
    }

    const { listingId } = req.body;

    const listing = await prisma.branchListing.findFirst({
      where: {
        id: listingId,
        status: 'active',
        sellerId: { not: req.user.id }
      },
      include: {
        seller: { select: { username: true } },
        branch: true,
        bundleBranches: { include: { branch: true } }
      }
    });

    if (!listing) {
      throw new ValidationError('Listing not available for purchase');
    }

    // Create Stripe payment intent for marketplace purchase
    const paymentIntent = await stripe.paymentIntents.create({
      amount: listing.priceCents,
      currency: 'usd',
      metadata: {
        userId: req.user.id.toString(),
        listingId: listingId.toString(),
        orderType: 'marketplace_purchase'
      },
      automatic_payment_methods: {
        enabled: true
      }
    });

    res.json({
      clientSecret: paymentIntent.client_secret,
      paymentIntentId: paymentIntent.id,
      listing: {
        id: listing.id,
        title: listing.title,
        price: `$${(listing.priceCents / 100).toFixed(2)}`,
        seller: listing.seller.username,
        isBundle: listing.isBundle,
        branchCount: listing.isBundle ? listing.bundleBranches.length : 1
      }
    });

  } catch (error) {
    console.error('🔴 Error creating marketplace purchase:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
        details: error.details
      });
    }
    next(error);
  }
});

// Helper function to calculate commission for marketplace
const calculateCommission = (priceCents, commissionPercentage = 5.0) => {
  const commissionCents = Math.round(priceCents * (commissionPercentage / 100));
  const sellerEarnsCents = priceCents - commissionCents;
  return { commissionCents, sellerEarnsCents };
};

module.exports = router;

// === END src/routes/checkout.js ===

// === src/routes/forum.js ===
// routes/forum.js - Complete Forum API Implementation
const express = require('express');
const { body, query, param, validationResult } = require('express-validator');
const { PrismaClient } = require('@prisma/client');
const AuthMiddleware = require('../middleware/auth');
const { ResponseWrapper, ValidationError, NotFoundError, ForbiddenError } = require('../middleware/errorHandler');
const contentModeration = require('../middleware/contentModeration');
const fileUpload = require('../middleware/fileUpload');

const router = express.Router();
const prisma = new PrismaClient();

console.log('💬 Forum API routes loaded!');

// Helper function to create URL-friendly slugs
const createSlug = (title) => {
  return title
    .toLowerCase()
    .replace(/[^\w ]+/g, '')
    .replace(/ +/g, '-')
    .substring(0, 50);
};

// Helper function to check if thread is auto-locked (15 days of inactivity)
const isThreadAutoLocked = (lastActivityAt) => {
  const fifteenDaysAgo = new Date();
  fifteenDaysAgo.setDate(fifteenDaysAgo.getDate() - 15);
  return lastActivityAt < fifteenDaysAgo;
};

// Helper function to get post limits based on role
const getPostLimits = (role) => {
  const limits = {
    operative: 5,
    contributor: 10,
    beta_tester: 15,
    moderator: 999,
    admin: 999
  };
  return limits[role] || limits.operative;
};

// =================================
// CATEGORY ROUTES
// =================================

// GET /api/forum/categories - List all forum categories
router.get('/categories',
  AuthMiddleware.requireAuth,
  async (req, res, next) => {
    try {
      const categories = await prisma.forum_categories.findMany({
        where: { 
          is_active: true,
          min_role_to_view: {
            in: req.user.role === 'admin' ? undefined : 
                ['operative', 'contributor', 'beta_tester', 'moderator', 'admin']
          }
        },
        orderBy: { sort_order: 'asc' },
        select: {
          id: true,
          name: true,
          description: true,
          sort_order: true,
          min_role_to_view: true,
          min_role_to_post: true,
          _count: {
            select: {
              forum_threads: {
                where: { is_deleted: false }
              }
            }
          }
        }
      });

      // Calculate latest activity for each category
      const categoriesWithActivity = await Promise.all(
        categories.map(async (category) => {
          const latestThread = await prisma.forum_threads.findFirst({
            where: {
              category_id: category.id,
              is_deleted: false
            },
            orderBy: { last_activity_at: 'desc' },
            select: {
              id: true,
              title: true,
              last_activity_at: true,
              users_forum_threads_author_idTousers: {
                select: { username: true }
              }
            }
          });

          return {
            ...category,
            thread_count: category._count.forum_threads,
            latest_thread: latestThread,
            can_post: ['moderator', 'admin'].includes(req.user.role) || 
                     req.user.role === category.min_role_to_post ||
                     ['operative', 'contributor', 'beta_tester'].includes(req.user.role)
          };
        })
      );

      delete categoriesWithActivity._count;

      return ResponseWrapper.success(res, {
        categories: categoriesWithActivity,
        user_permissions: {
          can_create_category: ['admin'].includes(req.user.role),
          can_moderate: ['moderator', 'admin'].includes(req.user.role)
        }
      });
    } catch (error) {
      next(error);
    }
  }
);

// POST /api/forum/categories - Create new category (Admin only)
router.post('/categories',
  AuthMiddleware.requireAuth,
  AuthMiddleware.requireRole(['admin']),
  [
    body('name').isLength({ min: 1, max: 100 }).withMessage('Name must be 1-100 characters'),
    body('description').optional().isLength({ max: 500 }).withMessage('Description max 500 characters'),
    body('sort_order').optional().isInt({ min: 0 }).withMessage('Sort order must be non-negative integer'),
    body('min_role_to_view').optional().isIn(['operative', 'contributor', 'beta_tester', 'moderator', 'admin']),
    body('min_role_to_post').optional().isIn(['operative', 'contributor', 'beta_tester', 'moderator', 'admin'])
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Validation failed', errors.array());
      }

      const { name, description, sort_order = 0, min_role_to_view = 'operative', min_role_to_post = 'operative' } = req.body;

      const category = await prisma.forum_categories.create({
        data: {
          name,
          description,
          sort_order,
          min_role_to_view,
          min_role_to_post,
          is_active: true
        }
      });

      return ResponseWrapper.created(res, category, 'Category created successfully');
    } catch (error) {
      next(error);
    }
  }
);

// =================================
// THREAD ROUTES
// =================================

// GET /api/forum/categories/:categoryId/threads - List threads in category
router.get('/categories/:categoryId/threads',
  AuthMiddleware.requireAuth,
  [
    param('categoryId').isInt({ min: 1 }).withMessage('Invalid category ID'),
    query('page').optional().isInt({ min: 1 }).withMessage('Page must be positive integer'),
    query('limit').optional().isInt({ min: 1, max: 50 }).withMessage('Limit must be 1-50'),
    query('sort').optional().isIn(['newest', 'oldest', 'most_replies', 'last_activity']),
    query('search').optional().isLength({ min: 1, max: 100 }).withMessage('Search must be 1-100 characters')
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Validation failed', errors.array());
      }

      const { categoryId } = req.params;
      const { 
        page = 1, 
        limit = 20, 
        sort = 'last_activity',
        search 
      } = req.query;

      // Check if category exists and user can view it
      const category = await prisma.forum_categories.findUnique({
        where: { 
          id: parseInt(categoryId),
          is_active: true
        }
      });

      if (!category) {
        throw new NotFoundError('Category not found');
      }

      // Build where clause for threads
      const where = {
        category_id: parseInt(categoryId),
        is_deleted: false
      };

      if (search) {
        where.title = {
          contains: search,
          mode: 'insensitive'
        };
      }

      // Define sort options
      const sortOptions = {
        newest: { created_at: 'desc' },
        oldest: { created_at: 'asc' },
        most_replies: { reply_count: 'desc' },
        last_activity: { last_activity_at: 'desc' }
      };

      const offset = (parseInt(page) - 1) * parseInt(limit);

      const [threads, total] = await Promise.all([
        prisma.forum_threads.findMany({
          where,
          orderBy: sortOptions[sort] || sortOptions.last_activity,
          skip: offset,
          take: parseInt(limit),
          select: {
            id: true,
            title: true,
            slug: true,
            is_pinned: true,
            is_locked: true,
            reply_count: true,
            last_activity_at: true,
            created_at: true,
            users_forum_threads_author_idTousers: {
              select: {
                username: true,
                role: true
              }
            },
            users_forum_threads_last_reply_byTousers: {
              select: {
                username: true
              }
            }
          }
        }),
        prisma.forum_threads.count({ where })
      ]);

      // Check which threads are auto-locked and add verification status
      const threadsWithStatus = await Promise.all(threads.map(async (thread) => {
        const autoLocked = isThreadAutoLocked(thread.last_activity_at);
        
        // Check if thread is verified study (has star)
        const firstPost = await prisma.forum_posts.findFirst({
          where: {
            thread_id: thread.id,
            is_first_post: true
          },
          select: {
            id: true,
            // We'll add a verified_study field later via admin action
          }
        });

        return {
          ...thread,
          is_auto_locked: autoLocked,
          is_effectively_locked: thread.is_locked || autoLocked,
          is_verified_study: false, // TODO: Add this field to posts table
          author: thread.users_forum_threads_author_idTousers,
          last_reply_by: thread.users_forum_threads_last_reply_byTousers
        };
      }));

      // Remove nested user objects
      threadsWithStatus.forEach(thread => {
        delete thread.users_forum_threads_author_idTousers;
        delete thread.users_forum_threads_last_reply_byTousers;
      });

      return ResponseWrapper.paginated(res, threadsWithStatus, {
        page: parseInt(page),
        limit: parseInt(limit),
        total
      });
    } catch (error) {
      next(error);
    }
  }
);

// POST /api/forum/categories/:categoryId/threads - Create new thread
router.post('/categories/:categoryId/threads',
  AuthMiddleware.requireAuth,
  fileUpload.array('attachments', 3), // Max 3 files
  [
    param('categoryId').isInt({ min: 1 }).withMessage('Invalid category ID'),
    body('title').isLength({ min: 1, max: 200 }).withMessage('Title must be 1-200 characters'),
    body('content').isLength({ min: 1, max: 5000 }).withMessage('Content must be 1-5000 characters')
  ],
  contentModeration.filterContent,
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Validation failed', errors.array());
      }

      const { categoryId } = req.params;
      const { title, content } = req.body;
      const userId = req.user.id;

      // Check daily post limit
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const todaysThreads = await prisma.forum_threads.count({
        where: {
          author_id: userId,
          created_at: { gte: today }
        }
      });

      const postLimit = getPostLimits(req.user.role);
      if (todaysThreads >= postLimit) {
        throw new ForbiddenError(`Daily thread limit reached (${postLimit})`);
      }

      // Check if category exists and user can post
      const category = await prisma.forum_categories.findUnique({
        where: { 
          id: parseInt(categoryId),
          is_active: true
        }
      });

      if (!category) {
        throw new NotFoundError('Category not found');
      }

      // Generate unique slug
      let slug = createSlug(title);
      let slugCount = 0;
      let finalSlug = slug;
      
      while (true) {
        const existingSlug = await prisma.forum_threads.findUnique({
          where: { slug: finalSlug }
        });
        
        if (!existingSlug) break;
        
        slugCount++;
        finalSlug = `${slug}-${slugCount}`;
      }

      // Create thread and first post in transaction
      const result = await prisma.$transaction(async (tx) => {
        // Create thread
        const thread = await tx.forum_threads.create({
          data: {
            category_id: parseInt(categoryId),
            title,
            slug: finalSlug,
            author_id: userId,
            reply_count: 0,
            last_activity_at: new Date(),
            last_reply_by: userId
          }
        });

        // Create first post
        const firstPost = await tx.forum_posts.create({
          data: {
            thread_id: thread.id,
            content: req.filteredContent || content, // Use filtered content
            author_id: userId,
            is_first_post: true
          }
        });

        return { thread, firstPost };
      });

      // Process file attachments if any
      let attachments = [];
      if (req.files && req.files.length > 0) {
        // TODO: Save file info to database and return file URLs
        attachments = req.files.map(file => ({
          filename: file.filename,
          originalName: file.originalname,
          size: file.size,
          mimetype: file.mimetype,
          url: `/uploads/${file.filename}`
        }));
      }

      return ResponseWrapper.created(res, {
        thread: {
          id: result.thread.id,
          title: result.thread.title,
          slug: result.thread.slug,
          category_id: result.thread.category_id,
          created_at: result.thread.created_at,
          url: `/forum/thread/${result.thread.slug}`
        },
        post: {
          id: result.firstPost.id,
          content: result.firstPost.content,
          created_at: result.firstPost.created_at
        },
        attachments,
        moderation: {
          auto_flagged: req.autoFlagged || false,
          filtered_content: !!req.filteredContent
        }
      }, 'Thread created successfully');
    } catch (error) {
      next(error);
    }
  }
);

// =================================
// INDIVIDUAL THREAD ROUTES  
// =================================

// GET /api/forum/thread/:slug - Get thread with posts
router.get('/thread/:slug',
  AuthMiddleware.requireAuth,
  [
    param('slug').isLength({ min: 1, max: 250 }).withMessage('Invalid slug'),
    query('page').optional().isInt({ min: 1 }).withMessage('Page must be positive integer'),
    query('limit').optional().isInt({ min: 1, max: 50 }).withMessage('Limit must be 1-50')
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Validation failed', errors.array());
      }

      const { slug } = req.params;
      const { page = 1, limit = 20 } = req.query;

      // Get thread with category info
      const thread = await prisma.forum_threads.findUnique({
        where: { 
          slug,
          is_deleted: false
        },
        select: {
          id: true,
          title: true,
          slug: true,
          category_id: true,
          is_pinned: true,
          is_locked: true,
          reply_count: true,
          last_activity_at: true,
          created_at: true,
          users_forum_threads_author_idTousers: {
            select: {
              username: true,
              role: true,
              active_olive_branch_id: true
            }
          },
          forum_categories: {
            select: {
              name: true,
              id: true
            }
          }
        }
      });

      if (!thread) {
        throw new NotFoundError('Thread not found');
      }

      // Get posts with pagination
      const offset = (parseInt(page) - 1) * parseInt(limit);
      
      const [posts, totalPosts] = await Promise.all([
        prisma.forum_posts.findMany({
          where: {
            thread_id: thread.id,
            is_deleted: false
          },
          orderBy: { created_at: 'asc' },
          skip: offset,
          take: parseInt(limit),
          select: {
            id: true,
            content: true,
            is_first_post: true,
            created_at: true,
            edited_at: true,
            users_forum_posts_author_idTousers: {
              select: {
                username: true,
                role: true,
                active_olive_branch_id: true,
                created_at: true
              }
            },
            users_forum_posts_edited_byTousers: {
              select: {
                username: true
              }
            }
          }
        }),
        prisma.forum_posts.count({
          where: {
            thread_id: thread.id,
            is_deleted: false
          }
        })
      ]);

      // Get post votes/upvotes for each post
      const postsWithVotes = await Promise.all(posts.map(async (post) => {
        // TODO: Implement upvote system - for now return 0
        const upvotes = 0;
        const userHasUpvoted = false;

        return {
          id: post.id,
          content: post.content,
          is_first_post: post.is_first_post,
          created_at: post.created_at,
          edited_at: post.edited_at,
          upvotes,
          user_has_upvoted: userHasUpvoted,
          author: {
            username: post.users_forum_posts_author_idTousers.username,
            role: post.users_forum_posts_author_idTousers.role,
            member_since: post.users_forum_posts_author_idTousers.created_at,
            has_olive_branch: !!post.users_forum_posts_author_idTousers.active_olive_branch_id
          },
          edited_by: post.users_forum_posts_edited_byTousers?.username || null,
          can_edit: post.users_forum_posts_author_idTousers.username === req.user.username || 
                   ['moderator', 'admin'].includes(req.user.role),
          can_delete: post.users_forum_posts_author_idTousers.username === req.user.username || 
                     ['moderator', 'admin'].includes(req.user.role)
        };
      }));

      // Check if thread is effectively locked
      const autoLocked = isThreadAutoLocked(thread.last_activity_at);
      const effectivelyLocked = thread.is_locked || autoLocked;

      return ResponseWrapper.success(res, {
        thread: {
          id: thread.id,
          title: thread.title,
          slug: thread.slug,
          category: {
            id: thread.forum_categories.id,
            name: thread.forum_categories.name
          },
          is_pinned: thread.is_pinned,
          is_locked: thread.is_locked,
          is_auto_locked: autoLocked,
          is_effectively_locked: effectivelyLocked,
          reply_count: thread.reply_count,
          last_activity_at: thread.last_activity_at,
          created_at: thread.created_at,
          author: {
            username: thread.users_forum_threads_author_idTousers.username,
            role: thread.users_forum_threads_author_idTousers.role,
            has_olive_branch: !!thread.users_forum_threads_author_idTousers.active_olive_branch_id
          }
        },
        posts: postsWithVotes,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: totalPosts,
          totalPages: Math.ceil(totalPosts / parseInt(limit)),
          hasNext: parseInt(page) < Math.ceil(totalPosts / parseInt(limit)),
          hasPrev: parseInt(page) > 1
        },
        permissions: {
          can_reply: !effectivelyLocked,
          can_lock: ['moderator', 'admin'].includes(req.user.role),
          can_pin: ['moderator', 'admin'].includes(req.user.role),
          can_delete: thread.users_forum_threads_author_idTousers.username === req.user.username || 
                     ['moderator', 'admin'].includes(req.user.role),
          can_verify_study: ['moderator', 'admin'].includes(req.user.role)
        }
      });
    } catch (error) {
      next(error);
    }
  }
);

// POST /api/forum/thread/:slug/reply - Add reply to thread
router.post('/thread/:slug/reply',
  AuthMiddleware.requireAuth,
  fileUpload.array('attachments', 3),
  [
    param('slug').isLength({ min: 1, max: 250 }).withMessage('Invalid slug'),
    body('content').isLength({ min: 1, max: 1200 }).withMessage('Content must be 1-1200 characters')
  ],
  contentModeration.filterContent,
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Validation failed', errors.array());
      }

      const { slug } = req.params;
      const { content } = req.body;
      const userId = req.user.id;

      // Get thread and check if it's locked
      const thread = await prisma.forum_threads.findUnique({
        where: { 
          slug,
          is_deleted: false
        }
      });

      if (!thread) {
        throw new NotFoundError('Thread not found');
      }

      const autoLocked = isThreadAutoLocked(thread.last_activity_at);
      if (thread.is_locked || autoLocked) {
        throw new ForbiddenError('Thread is locked');
      }

      // Create reply and update thread in transaction
      const result = await prisma.$transaction(async (tx) => {
        const post = await tx.forum_posts.create({
          data: {
            thread_id: thread.id,
            content: req.filteredContent || content,
            author_id: userId,
            is_first_post: false
          }
        });

        // Update thread stats
        await tx.forum_threads.update({
          where: { id: thread.id },
          data: {
            reply_count: { increment: 1 },
            last_activity_at: new Date(),
            last_reply_by: userId
          }
        });

        return post;
      });

      // Process attachments
      let attachments = [];
      if (req.files && req.files.length > 0) {
        attachments = req.files.map(file => ({
          filename: file.filename,
          originalName: file.originalname,
          size: file.size,
          mimetype: file.mimetype,
          url: `/uploads/${file.filename}`
        }));
      }

      return ResponseWrapper.created(res, {
        post: {
          id: result.id,
          content: result.content,
          created_at: result.created_at,
          author: {
            username: req.user.username,
            role: req.user.role
          }
        },
        attachments,
        moderation: {
          auto_flagged: req.autoFlagged || false,
          filtered_content: !!req.filteredContent
        }
      }, 'Reply posted successfully');
    } catch (error) {
      next(error);
    }
  }
);

// =================================
// POST MANAGEMENT ROUTES
// =================================

// PUT /api/forum/posts/:postId - Edit post
router.put('/posts/:postId',
  AuthMiddleware.requireAuth,
  [
    param('postId').isInt({ min: 1 }).withMessage('Invalid post ID'),
    body('content').isLength({ min: 1, max: 5000 }).withMessage('Content must be 1-5000 characters')
  ],
  contentModeration.filterContent,
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Validation failed', errors.array());
      }

      const { postId } = req.params;
      const { content } = req.body;
      const userId = req.user.id;

      // Get post with author info
      const post = await prisma.forum_posts.findUnique({
        where: { 
          id: parseInt(postId),
          is_deleted: false
        },
        select: {
          id: true,
          thread_id: true,
          content: true,
          author_id: true,
          is_first_post: true,
          users_forum_posts_author_idTousers: {
            select: { username: true }
          }
        }
      });

      if (!post) {
        throw new NotFoundError('Post not found');
      }

      // Check permissions
      const canEdit = post.author_id === userId || ['moderator', 'admin'].includes(req.user.role);
      if (!canEdit) {
        throw new ForbiddenError('Cannot edit this post');
      }

      // Update post
      const updatedPost = await prisma.forum_posts.update({
        where: { id: parseInt(postId) },
        data: {
          content: req.filteredContent || content,
          edited_at: new Date(),
          edited_by: userId
        },
        select: {
          id: true,
          content: true,
          edited_at: true,
          users_forum_posts_edited_byTousers: {
            select: { username: true }
          }
        }
      });

      return ResponseWrapper.updated(res, {
        post: {
          id: updatedPost.id,
          content: updatedPost.content,
          edited_at: updatedPost.edited_at,
          edited_by: updatedPost.users_forum_posts_edited_byTousers.username
        },
        moderation: {
          filtered_content: !!req.filteredContent
        }
      }, 'Post updated successfully');
    } catch (error) {
      next(error);
    }
  }
);

// DELETE /api/forum/posts/:postId - Delete post
router.delete('/posts/:postId',
  AuthMiddleware.requireAuth,
  [param('postId').isInt({ min: 1 }).withMessage('Invalid post ID')],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Validation failed', errors.array());
      }

      const { postId } = req.params;
      const userId = req.user.id;

      const post = await prisma.forum_posts.findUnique({
        where: { 
          id: parseInt(postId),
          is_deleted: false
        },
        select: {
          id: true,
          thread_id: true,
          author_id: true,
          is_first_post: true
        }
      });

      if (!post) {
        throw new NotFoundError('Post not found');
      }

      const canDelete = post.author_id === userId || ['moderator', 'admin'].includes(req.user.role);
      if (!canDelete) {
        throw new ForbiddenError('Cannot delete this post');
      }

      if (post.is_first_post) {
        throw new ForbiddenError('Cannot delete the first post of a thread');
      }

      // Soft delete post and update thread count
      await prisma.$transaction(async (tx) => {
        await tx.forum_posts.update({
          where: { id: parseInt(postId) },
          data: { is_deleted: true }
        });

        await tx.forum_threads.update({
          where: { id: post.thread_id },
          data: { reply_count: { decrement: 1 } }
        });
      });

      return ResponseWrapper.deleted(res, 'Post deleted successfully');
    } catch (error) {
      next(error);
    }
  }
);

// =================================
// UPVOTE SYSTEM ROUTES
// =================================

// POST /api/forum/posts/:postId/upvote - Upvote a post
router.post('/posts/:postId/upvote',
  AuthMiddleware.requireAuth,
  [param('postId').isInt({ min: 1 }).withMessage('Invalid post ID')],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Validation failed', errors.array());
      }

      // TODO: Implement upvote system with post_votes table
      // For now, return placeholder response
      
      return ResponseWrapper.success(res, {
        upvoted: true,
        total_upvotes: 1,
        message: 'Upvote feature coming soon!'
      });
    } catch (error) {
      next(error);
    }
  }
);

// =================================
// MODERATION ROUTES (Mods/Admins)
// =================================

// POST /api/forum/thread/:threadId/verify - Verify study and promote user
router.post('/thread/:threadId/verify',
  AuthMiddleware.requireAuth,
  AuthMiddleware.requireRole(['moderator', 'admin']),
  [param('threadId').isInt({ min: 1 }).withMessage('Invalid thread ID')],
  async (req, res, next) => {
    try {
      const { threadId } = req.params;

      // Get thread with author info
      const thread = await prisma.forum_threads.findUnique({
        where: { id: parseInt(threadId) },
        select: {
          id: true,
          author_id: true,
          title: true,
          users_forum_threads_author_idTousers: {
            select: {
              username: true,
              role: true
            }
          }
        }
      });

      if (!thread) {
        throw new NotFoundError('Thread not found');
      }

      // Update user role to contributor if they're currently operative
      let roleUpdated = false;
      if (thread.users_forum_threads_author_idTousers.role === 'operative') {
        await prisma.users.update({
          where: { id: thread.author_id },
          data: { role: 'contributor' }
        });
        roleUpdated = true;
      }

      // TODO: Add verified_study field to forum_posts table and mark first post as verified

      return ResponseWrapper.success(res, {
        verified: true,
        thread: {
          id: thread.id,
          title: thread.title
        },
        author: {
          username: thread.users_forum_threads_author_idTousers.username,
          old_role: thread.users_forum_threads_author_idTousers.role,
          new_role: roleUpdated ? 'contributor' : thread.users_forum_threads_author_idTousers.role,
          promoted: roleUpdated
        }
      }, `Study verified${roleUpdated ? ' and user promoted to contributor' : ''}`);
    } catch (error) {
      next(error);
    }
  }
);

// PUT /api/forum/thread/:threadId/lock - Lock/unlock thread
router.put('/thread/:threadId/lock',
  AuthMiddleware.requireAuth,
  AuthMiddleware.requireRole(['moderator', 'admin']),
  [
    param('threadId').isInt({ min: 1 }).withMessage('Invalid thread ID'),
    body('locked').isBoolean().withMessage('Locked must be boolean'),
    body('reason').optional().isLength({ max: 200 }).withMessage('Reason max 200 characters')
  ],
  async (req, res, next) => {
    try {
      const { threadId } = req.params;
      const { locked, reason } = req.body;

      const thread = await prisma.forum_threads.update({
        where: { id: parseInt(threadId) },
        data: { is_locked: locked }
      });

      return ResponseWrapper.updated(res, {
        thread: {
          id: thread.id,
          is_locked: thread.is_locked
        },
        action: locked ? 'locked' : 'unlocked',
        reason
      }, `Thread ${locked ? 'locked' : 'unlocked'} successfully`);
    } catch (error) {
      next(error);
    }
  }
);

module.exports = router;

// === END src/routes/forum.js ===

// === src/routes/idCards.js ===
// src/routes/idCards.js
// ID Card Rendering API Routes - Integrates with your existing auth system

const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { requireAuth, requireRole } = require('../middleware/auth');
const router = express.Router();

// Initialize Prisma client with proper error handling
let prisma;
try {
  prisma = new PrismaClient({
    log: ['error'], // Only log errors to reduce noise
  });
  console.log('✅ Prisma client initialized successfully in idCards routes');
} catch (error) {
  console.error('❌ Failed to initialize Prisma client in idCards routes:', error);
  throw error;
}

console.log('🆔 ID Card routes loaded successfully!');

/**
 * Generate SVG ID card based on role specifications from ID-CARD-Design-readme.md
 * Uses your actual database schema with snake_case field names
 */
const generateIdCardSVG = (userData, isPublicView = false) => {
  const {
    username,
    role,
    created_at, // Your schema uses created_at, not createdAt
    id_no,      // Your schema uses id_no, not idNo
    bio,
    activeOliveBranch
  } = userData;

  // Role-specific styling from your design specs
  const roleStyles = {
    guest: {
      primaryColor: '#393939',
      shadowColor: '#000000',
      roleName: 'guest'
    },
    operative: {
      primaryColor: '#DB52F4',
      shadowColor: '#DB52F4',
      roleName: 'operative'
    },
    contributor: {
      primaryColor: '#D5B504',
      shadowColor: '#D5B504',
      roleName: 'contributor'
    },
    beta_tester: {
      primaryColor: '#0D7F10',
      shadowColor: '#0D7F10',
      roleName: 'beta-tester'
    },
    moderator: {
      primaryColor: '#D40684',
      shadowColor: '#D40684',
      roleName: 'moderator'
    },
    admin: {
      primaryColor: '#FF6B35',
      shadowColor: '#FF6B35',
      roleName: 'admin'
    }
  };

  const currentRole = roleStyles[role] || roleStyles.guest;
  
  // Format date as dd/mm/yyyy (using your created_at field)
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
  };

  const formattedOnsetDate = formatDate(created_at);
  const displayBio = isPublicView ? (bio || 'member of galway research') : (bio || 'member of galway research');

  // Create the SVG card (CR80 standard: 3.370" × 2.125" = 243 × 153 pixels at 72 DPI)
  const cardWidth = 243;
  const cardHeight = 153;

  return `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${cardWidth}" height="${cardHeight}" viewBox="0 0 ${cardWidth} ${cardHeight}" 
     xmlns="http://www.w3.org/2000/svg">
  <defs>
    <!-- Drop shadow filter -->
    <filter id="dropShadow" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="0" dy="0" stdDeviation="2" flood-color="${currentRole.shadowColor}" 
                    flood-opacity="0.14" />
    </filter>
    
    <!-- IBM Plex Mono font -->
    <style>
      @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500&amp;display=swap');
      .card-text {
        font-family: 'IBM Plex Mono', monospace;
        font-weight: 400;
      }
      .card-text-bold {
        font-family: 'IBM Plex Mono', monospace;
        font-weight: 500;
      }
    </style>
  </defs>

  <!-- Card background with rounded corners -->
  <rect x="0" y="0" width="${cardWidth}" height="${cardHeight}" 
        rx="8" ry="8" fill="white" filter="url(#dropShadow)" />

  <!-- Role color accent strip (left side) -->
  <rect x="0" y="8" width="4" height="${cardHeight - 16}" 
        rx="2" ry="2" fill="${currentRole.primaryColor}" />

  <!-- Profile photo area (square with rounded corners) -->
  <rect x="15" y="15" width="50" height="50" rx="6" ry="6" 
        fill="#f5f5f5" stroke="#e0e0e0" stroke-width="1"/>
  
  ${activeOliveBranch ? `
  <!-- Olive branch display -->
  <g transform="translate(15, 15)">
    <!-- Olive branch placeholder (you can replace with actual SVG from your oliveBranchGenerator) -->
    <rect width="50" height="50" fill="#f5f5f5" rx="4"/>
    <circle cx="25" cy="25" r="3" fill="#6B8E23"/>
    <circle cx="20" cy="20" r="2" fill="#8B4513"/>
    <circle cx="30" cy="30" r="2.5" fill="#2F2F2F"/>
    <text x="25" y="45" text-anchor="middle" class="card-text" font-size="6" fill="#666">
      ${activeOliveBranch.botanical_id}
    </text>
  </g>
  ` : `
  <!-- Default profile placeholder -->
  <circle cx="40" cy="40" r="15" fill="#ddd"/>
  <text x="40" y="44" text-anchor="middle" class="card-text" font-size="8" fill="#666">
    no branch
  </text>
  `}

  <!-- Username -->
  <text x="75" y="25" class="card-text-bold" font-size="11" fill="${currentRole.primaryColor}">
    ${username}
  </text>

  <!-- Role -->
  <text x="75" y="40" class="card-text" font-size="8" fill="#333">
    ${currentRole.roleName}
  </text>

  <!-- Metadata grid (two-column layout) -->
  <g transform="translate(75, 55)">
    <!-- Role label/value -->
    <text x="0" y="0" class="card-text" font-size="7" fill="#666">role</text>
    <text x="140" y="0" text-anchor="end" class="card-text" font-size="7" fill="#333">
      ${currentRole.roleName}
    </text>

    <!-- Onset date label/value -->
    <text x="0" y="12" class="card-text" font-size="7" fill="#666">onset</text>
    <text x="140" y="12" text-anchor="end" class="card-text" font-size="7" fill="#333">
      ${formattedOnsetDate}
    </text>

    <!-- ID number label/value -->
    <text x="0" y="24" class="card-text" font-size="7" fill="#666">id-no</text>
    <text x="140" y="24" text-anchor="end" class="card-text" font-size="7" fill="#333">
      ${id_no}
    </text>
  </g>

  <!-- Bio box (grey background with text) -->
  <rect x="15" y="110" width="${cardWidth - 30}" height="28" 
        rx="4" ry="4" fill="#D3D3D3"/>
  
  <!-- Bio text -->
  <text x="20" y="125" class="card-text" font-size="6" fill="#333">
    ${displayBio.length > 50 ? displayBio.substring(0, 47) + '...' : displayBio}
  </text>

  <!-- Specimen data (if olive branch exists) -->
  ${activeOliveBranch ? `
  <text x="20" y="133" class="card-text" font-size="5" fill="#666">
    specimen data: ${activeOliveBranch.olive_count} olives • ${activeOliveBranch.botanical_id}
  </text>
  ` : ''}

</svg>`;
};

// GET /api/id-cards/me - Generate current user's ID card
router.get('/me', requireAuth, async (req, res, next) => {
  try {
    // Use your actual database schema with snake_case field names
    const user = await prisma.users.findUnique({
      where: { id: req.user.id },
      select: {
        id: true,
        username: true,
        role: true,
        created_at: true,  // Your schema uses created_at
        id_no: true,       // Your schema uses id_no
        bio: true,
        active_olive_branch_id: true,
        // Include active olive branch if it exists
        olive_branches_users_active_olive_branch_idToolive_branches: {
          select: {
            id: true,
            botanical_id: true,
            olive_count: true,
            olive_type: true
          }
        }
      }
    });

    if (!user) {
      return res.status(404).json({
        error: 'User not found',
        code: 'USER_NOT_FOUND'
      });
    }

    // Check if user has an ID number assigned
    if (!user.id_no) {
      return res.status(400).json({
        error: 'ID number not assigned. Please contact administration.',
        code: 'MISSING_ID_NUMBER'
      });
    }

    // Add olive branch data to user object for SVG generation
    const userData = {
      ...user,
      activeOliveBranch: user.olive_branches_users_active_olive_branch_idToolive_branches
    };

    const svgContent = generateIdCardSVG(userData, false);

    res.set({
      'Content-Type': 'image/svg+xml',
      'Cache-Control': 'private, max-age=3600', // Cache for 1 hour
      'X-Card-Type': 'personal',
      'X-Card-Role': user.role
    });

    res.send(svgContent);

  } catch (error) {
    console.error('🔴 Error generating user ID card:', error);
    next(error);
  }
});

// GET /api/id-cards/user/:id - Get another user's ID card (public view)
router.get('/user/:id', async (req, res, next) => {
  try {
    const userId = parseInt(req.params.id);
    if (isNaN(userId)) {
      return res.status(400).json({
        error: 'Invalid user ID',
        code: 'INVALID_USER_ID'
      });
    }

    const user = await prisma.users.findUnique({
      where: { id: userId },
      select: {
        id: true,
        username: true,
        role: true,
        created_at: true,
        id_no: true,
        bio: true,
        active_olive_branch_id: true,
        olive_branches_users_active_olive_branch_idToolive_branches: {
          select: {
            id: true,
            botanical_id: true,
            olive_count: true,
            olive_type: true
          }
        }
      }
    });

    if (!user) {
      return res.status(404).json({
        error: 'User not found',
        code: 'USER_NOT_FOUND'
      });
    }

    if (!user.id_no) {
      return res.status(400).json({
        error: 'User ID card not available',
        code: 'MISSING_ID_NUMBER'
      });
    }

    // Add olive branch data to user object for SVG generation
    const userData = {
      ...user,
      activeOliveBranch: user.olive_branches_users_active_olive_branch_idToolive_branches
    };

    // Public view - limited bio information
    const svgContent = generateIdCardSVG(userData, true);

    res.set({
      'Content-Type': 'image/svg+xml',
      'Cache-Control': 'public, max-age=1800', // Cache for 30 minutes
      'X-Card-Type': 'public',
      'X-Card-Role': user.role,
      'X-Username': user.username
    });

    res.send(svgContent);

  } catch (error) {
    console.error('🔴 Error generating public ID card:', error);
    next(error);
  }
});

// GET /api/id-cards/preview/:role - Preview ID card for different roles (testing)
router.get('/preview/:role', requireAuth, requireRole(['admin', 'moderator']), (req, res) => {
  const { role } = req.params;
  
  const validRoles = ['guest', 'operative', 'contributor', 'beta_tester', 'moderator', 'admin'];
  if (!validRoles.includes(role)) {
    return res.status(400).json({
      error: 'Invalid role for preview',
      code: 'INVALID_ROLE'
    });
  }

  // Mock user data for preview
  const mockUser = {
    username: 'preview_user',
    role: role,
    created_at: new Date(),
    id_no: '123456',
    bio: 'this is a preview card for testing purposes',
    activeOliveBranch: {
      id: 1,
      botanical_id: 'OLV-ABC123',
      olive_count: 3,
      olive_type: 'Green Olives'
    }
  };

  const svgContent = generateIdCardSVG(mockUser, false);

  res.set({
    'Content-Type': 'image/svg+xml',
    'Cache-Control': 'no-cache',
    'X-Card-Type': 'preview',
    'X-Preview-Role': role
  });

  res.send(svgContent);
});

// GET /api/id-cards/metadata/me - Get current user's card metadata (JSON)
router.get('/metadata/me', requireAuth, async (req, res, next) => {
  try {
    const user = await prisma.users.findUnique({
      where: { id: req.user.id },
      select: {
        id: true,
        username: true,
        role: true,
        created_at: true,
        id_no: true,
        bio: true,
        olive_branches_users_active_olive_branch_idToolive_branches: {
          select: {
            id: true,
            botanical_id: true,
            olive_count: true,
            olive_type: true,
            count_rarity: true,
            type_rarity: true
          }
        }
      }
    });

    if (!user) {
      return res.status(404).json({
        error: 'User not found',
        code: 'USER_NOT_FOUND'
      });
    }

    // Format date as dd/mm/yyyy
    const formatDate = (dateString) => {
      const date = new Date(dateString);
      const day = date.getDate().toString().padStart(2, '0');
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const year = date.getFullYear();
      return `${day}/${month}/${year}`;
    };

    const activeOliveBranch = user.olive_branches_users_active_olive_branch_idToolive_branches;

    res.json({
      cardData: {
        username: user.username,
        role: user.role,
        onsetDate: formatDate(user.created_at),
        idNo: user.id_no,
        bio: user.bio || 'member of galway research',
        memberSince: formatDate(user.created_at)
      },
      oliveBranch: activeOliveBranch ? {
        id: activeOliveBranch.id,
        botanicalId: activeOliveBranch.botanical_id,
        oliveCount: activeOliveBranch.olive_count,
        oliveType: activeOliveBranch.olive_type,
        countRarity: activeOliveBranch.count_rarity,
        typeRarity: activeOliveBranch.type_rarity,
        specimenData: `${activeOliveBranch.olive_count} olives`,
        botanicalIdShort: activeOliveBranch.botanical_id.split('-')[1] // Last part after dash
      } : null,
      urls: {
        cardSvg: '/api/id-cards/me',
        publicView: `/api/id-cards/user/${user.id}`
      }
    });

  } catch (error) {
    console.error('🔴 Error getting card metadata:', error);
    next(error);
  }
});

// GET /api/id-cards/admin/stats - Check ID assignment status (admin only)
router.get('/admin/stats', requireAuth, requireRole(['admin']), async (req, res, next) => {
  try {
    // Get statistics about ID assignment using your actual schema
    const [totalUsers, usersWithIds, usersWithoutIds] = await Promise.all([
      prisma.users.count(),
      prisma.users.count({
        where: { id_no: { not: null } }
      }),
      prisma.users.count({
        where: { id_no: null }
      })
    ]);
    
    res.json({
      message: 'ID assignment statistics',
      stats: {
        totalUsers,
        usersWithIds,
        usersWithoutIds,
        completionPercentage: totalUsers > 0 ? Math.round((usersWithIds / totalUsers) * 100) : 0
      },
      needsMigration: usersWithoutIds > 0,
      note: "Your auth system already handles ID generation for new users!"
    });
    
  } catch (error) {
    console.error('🔴 Stats error:', error);
    next(error);
  }
});

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('🔌 Disconnecting Prisma client from idCards routes...');
  await prisma.$disconnect();
});

process.on('SIGTERM', async () => {
  console.log('🔌 Disconnecting Prisma client from idCards routes...');
  await prisma.$disconnect();
});

module.exports = router;

// === END src/routes/idCards.js ===

// === src/routes/inventory.js ===
// routes/inventory.js - Complete Inventory Management
const express = require('express');
const { body, query, validationResult } = require('express-validator');
const { PrismaClient } = require('@prisma/client');
const AuthMiddleware = require('../middleware/auth');
const { ResponseWrapper, ValidationError, NotFoundError, ForbiddenError } = require('../middleware/errorHandler');

const router = express.Router();
const prisma = new PrismaClient();

console.log('🎒 Complete Inventory Management routes loaded!');

// Inventory configuration
const INVENTORY_CONFIG = {
  MAX_DISPLAY_SLOTS: 4,
  MAX_TOTAL_SLOTS: 100,
  ITEM_TYPES: ['branch', 'seed', 'item', 'achievement', 'tool'],
  RARITY_MULTIPLIERS: {
    'Common': 1,
    'Uncommon': 1.5,
    'Rare': 2,
    'Very Rare': 3,
    'Legendary': 5
  }
};

// Helper functions
const calculateItemValue = (item) => {
  const baseValue = 10;
  const rarityMultiplier = INVENTORY_CONFIG.RARITY_MULTIPLIERS[item.rarity] || 1;
  const quantityBonus = item.quantity > 1 ? Math.log10(item.quantity) : 1;
  return Math.floor(baseValue * rarityMultiplier * quantityBonus);
};

const formatInventoryItem = (item, includePrivateData = false) => {
  const formatted = {
    id: item.id,
    itemType: item.itemType,
    quantity: item.quantity,
    gridPosition: item.gridPosition,
    sourceType: item.sourceType,
    createdAt: item.createdAt
  };

  // Add type-specific data
  if (item.itemType === 'branch' && item.oliveBranch) {
    formatted.branchData = {
      id: item.oliveBranch.id,
      botanicalId: item.oliveBranch.botanicalId,
      oliveType: item.oliveBranch.oliveType,
      oliveCount: item.oliveBranch.oliveCount,
      countRarity: item.oliveBranch.countRarity,
      typeRarity: item.oliveBranch.typeRarity,
      svgUrl: `/api/olive-branches/${item.oliveBranch.id}/svg`
    };
    formatted.displayName = `${item.oliveBranch.botanicalId} (${item.oliveBranch.oliveType})`;
    formatted.rarity = item.oliveBranch.countRarity;
    formatted.icon = '🌿';
  } else if (item.itemType === 'seed') {
    formatted.displayName = 'Olive Seed';
    formatted.rarity = 'Common';
    formatted.icon = '🌰';
  } else if (item.itemType === 'item') {
    formatted.displayName = item.metadata?.name || 'Research Item';
    formatted.rarity = item.metadata?.rarity || 'Common';
    formatted.icon = item.metadata?.icon || '📦';
  } else if (item.itemType === 'achievement') {
    formatted.displayName = item.metadata?.name || 'Achievement';
    formatted.rarity = item.metadata?.rarity || 'Uncommon';
    formatted.icon = item.metadata?.icon || '🏆';
  } else {
    formatted.displayName = 'Unknown Item';
    formatted.rarity = 'Common';
    formatted.icon = '❓';
  }

  // Add value and private data for owner/admin
  if (includePrivateData) {
    formatted.estimatedValue = calculateItemValue(formatted);
    formatted.sourceReference = item.sourceReference;
    formatted.metadata = item.metadata;
  }

  return formatted;
};

// GET /api/inventory/me - Get current user's inventory
router.get('/me',
  AuthMiddleware.requireAuth,
  [
    query('type').optional().isIn(INVENTORY_CONFIG.ITEM_TYPES).withMessage('Invalid item type'),
    query('displayOnly').optional().isBoolean().withMessage('displayOnly must be boolean'),
    query('includeValue').optional().isBoolean().withMessage('includeValue must be boolean')
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Invalid query parameters', errors.array());
      }

      const { type, displayOnly, includeValue } = req.query;
      const userId = req.user.id;

      // Build where clause
      const where = { userId };
      
      if (type) {
        where.itemType = type;
      }

      if (displayOnly === 'true') {
        where.gridPosition = { lt: INVENTORY_CONFIG.MAX_DISPLAY_SLOTS };
      }

      // Get inventory items with related data - handle gracefully if oliveBranch relation doesn't exist
      let inventoryItems;
      try {
        inventoryItems = await prisma.inventoryItem.findMany({
          where,
          orderBy: [
            { gridPosition: 'asc' },
            { createdAt: 'desc' }
          ],
          include: {
            oliveBranch: {
              select: {
                id: true,
                botanicalId: true,
                oliveType: true,
                oliveCount: true,
                countRarity: true,
                typeRarity: true,
                countRarityPercentage: true,
                typeRarityPercentage: true
              }
            }
          }
        });
      } catch (relationError) {
        // If oliveBranch relation doesn't exist, fetch without it
        console.warn('oliveBranch relation not found, fetching inventory without branch data');
        inventoryItems = await prisma.inventoryItem.findMany({
          where,
          orderBy: [
            { gridPosition: 'asc' },
            { createdAt: 'desc' }
          ]
        });
      }

      // Format items for response
      const formattedItems = inventoryItems.map(item => 
        formatInventoryItem(item, includeValue === 'true')
      );

      // Calculate inventory stats
      const stats = {
        totalItems: inventoryItems.length,
        totalQuantity: inventoryItems.reduce((sum, item) => sum + (item.quantity || 1), 0),
        displayedItems: inventoryItems.filter(item => (item.gridPosition || 0) < INVENTORY_CONFIG.MAX_DISPLAY_SLOTS).length,
        availableSlots: INVENTORY_CONFIG.MAX_TOTAL_SLOTS - inventoryItems.length,
        typeBreakdown: inventoryItems.reduce((acc, item) => {
          acc[item.itemType] = (acc[item.itemType] || 0) + 1;
          return acc;
        }, {})
      };

      if (includeValue === 'true') {
        stats.totalValue = formattedItems.reduce((sum, item) => sum + (item.estimatedValue || 0), 0);
        stats.averageValue = stats.totalItems > 0 ? Math.floor(stats.totalValue / stats.totalItems) : 0;
      }

      return ResponseWrapper.success(res, {
        inventory: formattedItems,
        stats,
        config: {
          maxDisplaySlots: INVENTORY_CONFIG.MAX_DISPLAY_SLOTS,
          maxTotalSlots: INVENTORY_CONFIG.MAX_TOTAL_SLOTS
        }
      });

    } catch (error) {
      next(error);
    }
  }
);

// GET /api/inventory/:username - Get another user's displayed inventory
router.get('/:username',
  AuthMiddleware.requireAuth,
  async (req, res, next) => {
    try {
      const { username } = req.params;

      // Get target user
      const targetUser = await prisma.user.findUnique({
        where: { username },
        select: { id: true, username: true, role: true }
      });

      if (!targetUser) {
        throw new NotFoundError('User not found');
      }

      // Check permissions
      const isOwnInventory = req.user.username === username;
      const isAdmin = req.user.role === 'admin';
      const canViewFull = isOwnInventory || isAdmin;

      // Get displayed items only (unless admin/owner)
      const where = { 
        userId: targetUser.id,
        ...(canViewFull ? {} : { gridPosition: { lt: INVENTORY_CONFIG.MAX_DISPLAY_SLOTS } })
      };

      let inventoryItems;
      try {
        inventoryItems = await prisma.inventoryItem.findMany({
          where,
          orderBy: { gridPosition: 'asc' },
          include: {
            oliveBranch: {
              select: {
                id: true,
                botanicalId: true,
                oliveType: true,
                oliveCount: true,
                countRarity: true,
                typeRarity: true
              }
            }
          }
        });
      } catch (relationError) {
        inventoryItems = await prisma.inventoryItem.findMany({
          where,
          orderBy: { gridPosition: 'asc' }
        });
      }

      const formattedItems = inventoryItems.map(item => 
        formatInventoryItem(item, canViewFull)
      );

      return ResponseWrapper.success(res, {
        owner: {
          username: targetUser.username,
          role: targetUser.role
        },
        inventory: formattedItems,
        displayOnly: !canViewFull,
        permissions: {
          canViewFull,
          canEdit: isOwnInventory
        }
      });

    } catch (error) {
      next(error);
    }
  }
);

// NEW - Simple test without database calls:
router.get('/test', (req, res) => {
  ResponseWrapper.success(res, {
    message: 'Inventory system is working!',
    note: 'Database models ready for implementation',
    config: INVENTORY_CONFIG,
    timestamp: new Date().toISOString()
  });
});

module.exports = router;

// === END src/routes/inventory.js ===

// === src/routes/leaderboards.js ===
const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { requireAuth, optionalAuth } = require('../middleware/auth');
const { ResponseWrapper } = require('../middleware/errorHandler');

const router = express.Router();
const prisma = new PrismaClient();

// Test endpoint - keeping the working version
router.get('/test', (req, res) => {
  const testData = {
    system: 'Leaderboards API',
    version: '1.0.0',
    status: 'operational',
    features: [
      'Multi-category leaderboards',
      'Time period filtering', 
      'User ranking system',
      'Score tracking',
      'Real-time leaderboard updates'
    ],
    categories: ['collector', 'trader', 'social', 'forum', 'seasonal'],
    periods: ['daily', 'weekly', 'monthly', 'all_time', 'seasonal']
  };
  
  ResponseWrapper.success(res, testData, 'Leaderboards API fully operational');
});

// GET /api/leaderboards/categories - Get available categories
router.get('/categories', async (req, res, next) => {
  try {
    // Since we might not have leaderboards in DB yet, return the predefined categories
    const categories = [
      {
        name: 'collector',
        count: 0,
        description: 'Rankings based on collecting rare olive branches and building impressive collections'
      },
      {
        name: 'trader', 
        count: 0,
        description: 'Rankings based on trading volume, successful transactions, and market activity'
      },
      {
        name: 'social',
        count: 0, 
        description: 'Rankings based on community engagement, follows, and social interactions'
      },
      {
        name: 'forum',
        count: 0,
        description: 'Rankings based on forum participation, helpful posts, and community contributions'
      },
      {
        name: 'seasonal',
        count: 0,
        description: 'Special seasonal event rankings and limited-time competitions'
      }
    ];

    // Try to get actual counts from database
    try {
      const dbCategories = await prisma.leaderboards.groupBy({
        by: ['category'],
        where: { is_active: true },
        _count: { category: true }
      });

      // Update counts if we have data
      dbCategories.forEach(dbCat => {
        const category = categories.find(c => c.name === dbCat.category);
        if (category) {
          category.count = dbCat._count.category;
        }
      });
    } catch (dbError) {
      console.log('Database not available for categories, using defaults');
    }

    ResponseWrapper.success(res, categories);
  } catch (error) {
    next(error);
  }
});

// GET /api/leaderboards/featured - Get featured leaderboards
router.get('/featured', async (req, res, next) => {
  try {
    let featuredLeaderboards = [];

    try {
      featuredLeaderboards = await prisma.leaderboards.findMany({
        where: { 
          is_active: true, 
          is_featured: true 
        },
        select: {
          id: true,
          name: true,
          description: true,
          category: true,
          time_period: true,
          max_entries: true,
          created_at: true,
          _count: {
            select: { leaderboard_entries: true }
          }
        },
        orderBy: { created_at: 'desc' },
        take: 10
      });
    } catch (dbError) {
      console.log('Database not available for featured leaderboards');
      // Return sample featured leaderboards
      featuredLeaderboards = [
        {
          id: 1,
          name: 'Top Collectors',
          description: 'Users with the most rare olive branches',
          category: 'collector',
          time_period: 'all_time',
          max_entries: 100,
          current_entries: 0,
          created_at: new Date()
        },
        {
          id: 2,
          name: 'Trading Champions',
          description: 'Most successful traders this month',
          category: 'trader',
          time_period: 'monthly', 
          max_entries: 50,
          current_entries: 0,
          created_at: new Date()
        }
      ];
    }

    const formatted = featuredLeaderboards.map(lb => ({
      id: lb.id,
      name: lb.name,
      description: lb.description,
      category: lb.category,
      time_period: lb.time_period,
      max_entries: lb.max_entries,
      current_entries: lb._count?.leaderboard_entries || lb.current_entries || 0,
      created_at: lb.created_at
    }));

    ResponseWrapper.success(res, formatted);
  } catch (error) {
    next(error);
  }
});

// GET /api/leaderboards/user/:userId - Get user's rankings
router.get('/user/:userId', requireAuth, async (req, res, next) => {
  try {
    const { userId } = req.params;
    const { active_only = true, category } = req.query;

    // Check if user exists
    const user = await prisma.user.findUnique({
      where: { id: parseInt(userId) },
      select: {
        id: true,
        username: true,
        role: true
      }
    });

    if (!user) {
      return ResponseWrapper.notFound(res, 'User not found');
    }

    // Authorization check
    if (req.user.id !== parseInt(userId) && !['admin', 'moderator'].includes(req.user.role)) {
      return ResponseWrapper.forbidden(res, 'Access denied');
    }

    let userEntries = [];
    
    try {
      // Build where clause for leaderboards
      let leaderboardsWhere = {};
      if (active_only === 'true') leaderboardsWhere.is_active = true;
      if (category) leaderboardsWhere.category = category;

      // Get user's leaderboard entries
      userEntries = await prisma.leaderboard_entries.findMany({
        where: {
          user_id: parseInt(userId),
          leaderboards: leaderboardsWhere
        },
        select: {
          rank_position: true,
          score: true,
          score_data: true,
          period_start: true,
          period_end: true,
          updated_at: true,
          leaderboards: {
            select: {
              id: true,
              name: true,
              description: true,
              category: true,
              time_period: true,
              max_entries: true
            }
          }
        },
        orderBy: [
          { leaderboards: { category: 'asc' } },
          { rank_position: 'asc' }
        ]
      });
    } catch (dbError) {
      console.log('No leaderboard entries found for user');
    }

    // Format the response
    const rankings = userEntries.map(entry => ({
      leaderboard: entry.leaderboards,
      rank: entry.rank_position,
      score: parseFloat(entry.score),
      score_data: entry.score_data,
      period: {
        start: entry.period_start,
        end: entry.period_end
      },
      updated_at: entry.updated_at
    }));

    // Group by category
    const rankingsByCategory = rankings.reduce((acc, ranking) => {
      const category = ranking.leaderboard.category;
      if (!acc[category]) acc[category] = [];
      acc[category].push(ranking);
      return acc;
    }, {});

    // Calculate summary stats
    const totalRankings = rankings.length;
    const topRankings = rankings.filter(r => r.rank <= 10).length;
    const averageRank = rankings.length > 0 ? 
      Math.round(rankings.reduce((sum, r) => sum + r.rank, 0) / rankings.length) : 0;

    ResponseWrapper.success(res, {
      user: {
        id: user.id,
        username: user.username,
        role: user.role
      },
      rankings: rankingsByCategory,
      summary: {
        total_leaderboards: totalRankings,
        top_10_rankings: topRankings,
        average_rank: averageRank,
        categories_present: Object.keys(rankingsByCategory)
      }
    });
  } catch (error) {
    next(error);
  }
});

// GET /api/leaderboards - List all leaderboards
router.get('/', async (req, res, next) => {
  try {
    const { 
      category, 
      featured_only = false, 
      active_only = true,
      page = 1, 
      limit = 20 
    } = req.query;

    const offset = (parseInt(page) - 1) * parseInt(limit);
    let leaderboards = [];
    let total = 0;

    try {
      const where = {
        ...(active_only === 'true' && { is_active: true }),
        ...(featured_only === 'true' && { is_featured: true }),
        ...(category && { category })
      };

      [leaderboards, total] = await Promise.all([
        prisma.leaderboards.findMany({
          where,
          select: {
            id: true,
            name: true,
            description: true,
            category: true,
            time_period: true,
            max_entries: true,
            is_featured: true,
            created_at: true,
            _count: {
              select: { leaderboard_entries: true }
            }
          },
          orderBy: [
            { is_featured: 'desc' },
            { created_at: 'desc' }
          ],
          skip: offset,
          take: parseInt(limit)
        }),
        prisma.leaderboards.count({ where })
      ]);
    } catch (dbError) {
      console.log('Database not available, returning sample leaderboards');
      // Return sample data if database is not available
      const sampleLeaderboards = [
        {
          id: 1,
          name: 'Top Collectors - All Time',
          description: 'Users with the most impressive olive branch collections',
          category: 'collector',
          time_period: 'all_time',
          max_entries: 100,
          is_featured: true,
          current_entries: 0,
          created_at: new Date()
        },
        {
          id: 2,
          name: 'Monthly Trading Volume',
          description: 'Highest trading volume for this month',
          category: 'trader',
          time_period: 'monthly',
          max_entries: 50,
          is_featured: false,
          current_entries: 0,
          created_at: new Date()
        }
      ];

      // Apply filters to sample data
      leaderboards = sampleLeaderboards.filter(lb => {
        if (active_only === 'true' && !lb.is_featured && lb.id > 2) return false;
        if (featured_only === 'true' && !lb.is_featured) return false;
        if (category && lb.category !== category) return false;
        return true;
      });

      total = leaderboards.length;
      leaderboards = leaderboards.slice(offset, offset + parseInt(limit));
    }

    // Format leaderboards with current entry counts
    const formattedLeaderboards = leaderboards.map(lb => ({
      id: lb.id,
      name: lb.name,
      description: lb.description,
      category: lb.category,
      time_period: lb.time_period,
      max_entries: lb.max_entries,
      is_featured: lb.is_featured,
      current_entries: lb._count?.leaderboard_entries || lb.current_entries || 0,
      created_at: lb.created_at
    }));

    ResponseWrapper.paginated(res, formattedLeaderboards, {
      page: parseInt(page),
      limit: parseInt(limit),
      total
    });
  } catch (error) {
    next(error);
  }
});

// GET /api/leaderboards/:id - Get specific leaderboard with rankings
router.get('/:id', async (req, res, next) => {
  try {
    const { id } = req.params;
    const { 
      period_start,
      period_end,
      page = 1,
      limit = 50
    } = req.query;

    const offset = (parseInt(page) - 1) * parseInt(limit);
    let leaderboard = null;
    let entries = [];
    let totalEntries = 0;

    try {
      // Get leaderboard details
      leaderboard = await prisma.leaderboards.findUnique({
        where: { id: parseInt(id) },
        select: {
          id: true,
          name: true,
          description: true,
          category: true,
          scoring_method: true,
          time_period: true,
          max_entries: true,
          is_active: true,
          is_featured: true,
          created_at: true
        }
      });

      if (!leaderboard) {
        return ResponseWrapper.notFound(res, 'Leaderboard not found');
      }

      // Build where clause for entries
      let entriesWhere = { leaderboard_id: parseInt(id) };
      
      if (period_start || period_end) {
        entriesWhere.period_start = {};
        if (period_start) entriesWhere.period_start.gte = new Date(period_start);
        if (period_end) entriesWhere.period_end = { lte: new Date(period_end) };
      }

      // Get leaderboard entries with user data
      [entries, totalEntries] = await Promise.all([
        prisma.leaderboard_entries.findMany({
          where: entriesWhere,
          select: {
            id: true,
            rank_position: true,
            score: true,
            score_data: true,
            period_start: true,
            period_end: true,
            updated_at: true,
            users: {
              select: {
                id: true,
                username: true,
                role: true,
                created_at: true
              }
            }
          },
          orderBy: { rank_position: 'asc' },
          skip: offset,
          take: parseInt(limit)
        }),
        prisma.leaderboard_entries.count({ where: entriesWhere })
      ]);

    } catch (dbError) {
      console.log('Database error, returning sample leaderboard');
      
      // Return sample leaderboard if database error
      if (parseInt(id) === 1 || parseInt(id) === 2) {
        leaderboard = {
          id: parseInt(id),
          name: parseInt(id) === 1 ? 'Top Collectors' : 'Trading Champions',
          description: parseInt(id) === 1 ? 'Most rare olive branches collected' : 'Highest trading volume',
          category: parseInt(id) === 1 ? 'collector' : 'trader',
          scoring_method: 'count',
          time_period: 'all_time',
          max_entries: 100,
          is_active: true,
          is_featured: true,
          created_at: new Date()
        };
        
        entries = []; // Empty for now
        totalEntries = 0;
      } else {
        return ResponseWrapper.notFound(res, 'Leaderboard not found');
      }
    }

    // Format entries with user information
    const formattedEntries = entries.map(entry => ({
      rank: entry.rank_position,
      score: parseFloat(entry.score),
      score_data: entry.score_data,
      period: {
        start: entry.period_start,
        end: entry.period_end
      },
      updated_at: entry.updated_at,
      user: {
        id: entry.users.id,
        username: entry.users.username,
        role: entry.users.role,
        joined: entry.users.created_at
      }
    }));

    ResponseWrapper.success(res, {
      leaderboard,
      entries: formattedEntries,
      stats: {
        total_entries: totalEntries,
        showing: formattedEntries.length,
        period_filter: period_start || period_end ? { start: period_start, end: period_end } : null
      },
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalEntries,
        pages: Math.ceil(totalEntries / parseInt(limit))
      }
    });
  } catch (error) {
    next(error);
  }
});

module.exports = router;

// === END src/routes/leaderboards.js ===

// === src/routes/oliveBranches.js ===
// src/routes/oliveBranches.js
// Complete Olive Branch Generation and Management Routes
const express = require('express');
const crypto = require('crypto');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult } = require('express-validator');
const { requireAuth } = require('../middleware/auth');
const { generateOliveBranchSVG } = require('../services/oliveBranchGenerator');
const router = express.Router();
const prisma = new PrismaClient();

console.log('🌿 Complete Olive Branch routes loaded successfully!');

// Custom error classes
class ValidationError extends Error {
  constructor(message, details = null) {
    super(message);
    this.statusCode = 400;
    this.code = 'VALIDATION_ERROR';
    this.details = details;
  }
}

class NotFoundError extends Error {
  constructor(message = 'Resource not found') {
    super(message);
    this.statusCode = 404;
    this.code = 'NOT_FOUND';
  }
}

class ForbiddenError extends Error {
  constructor(message = 'Access forbidden') {
    super(message);
    this.statusCode = 403;
    this.code = 'FORBIDDEN';
  }
}

// Helper function to generate unique botanical ID
const generateBotanicalId = async () => {
  let botanicalId;
  let isUnique = false;
  
  while (!isUnique) {
    const prefix = 'OLV';
    const suffix = crypto.randomBytes(3).toString('hex').toUpperCase();
    botanicalId = `${prefix}-${suffix}`;
    
    const existing = await prisma.oliveBranch.findUnique({
      where: { botanicalId },
    });
    isUnique = !existing;
  }
  return botanicalId;
};

// Helper function to calculate rarity (your exact system)
const calculateRarity = (oliveCount, oliveType) => {
  const countRarities = {
    1: { name: 'Common', percentage: 33 },
    2: { name: 'Common', percentage: 28 },
    3: { name: 'Uncommon', percentage: 19 },
    4: { name: 'Rare', percentage: 12 },
    5: { name: 'Very Rare', percentage: 8 }
  };
  
  const typeRarities = {
    'greenOlives': { name: 'Common', percentage: 30 },
    'blackOlives': { name: 'Common', percentage: 25 },
    'brownOlives': { name: 'Uncommon', percentage: 20 },
    'purpleOlives': { name: 'Rare', percentage: 15 },
    'ripeMixed': { name: 'Very Rare', percentage: 10 }
  };
  
  return {
    countRarity: countRarities[oliveCount].name,
    countRarityPercentage: countRarities[oliveCount].percentage,
    typeRarity: typeRarities[oliveType].name,
    typeRarityPercentage: typeRarities[oliveType].percentage
  };
};

// Helper function to calculate trading value
const calculateTradingValue = (branch) => {
  const rarityScores = {
    'Common': 1,
    'Uncommon': 2, 
    'Rare': 3,
    'Very Rare': 4,
    'Legendary': 5
  };
  
  const countScore = rarityScores[branch.countRarity] || 1;
  const typeScore = rarityScores[branch.typeRarity] || 1;
  const totalRarityScore = countScore + typeScore;
  
  return Math.floor(totalRarityScore * 1.5) + Math.floor(branch.oliveCount * 0.5);
};

// Helper function to generate olive branch data (your exact algorithm)
const generateOliveBranchData = () => {
  const seedValue = crypto.randomBytes(16).toString('hex');
  let seed = parseInt(seedValue.substring(0, 8), 16);
  const random = () => {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  };

  // Your exact color palettes
  const oliveColors = {
    greenOlives: ['#6B8E23', '#808000', '#9ACD32', '#7CFC00', '#ADFF2F'],
    blackOlives: ['#2F2F2F', '#404040', '#1C1C1C', '#36454F', '#28282B'],
    brownOlives: ['#8B4513', '#A0522D', '#CD853F', '#D2691E', '#BC9A6A'],
    purpleOlives: ['#663399', '#4B0082', '#800080', '#9932CC', '#8B008B'],
    ripeMixed: ['#6B8E23', '#2F2F2F', '#663399', '#8B4513']
  };

  const branchColors = {
    youngBranch: ['#8FBC8F', '#90EE90', '#98FB98', '#7CFC00'],
    matureBranch: ['#556B2F', '#6B8E23', '#808000', '#9ACD32'],
    brownBranch: ['#8B7355', '#A0522D', '#CD853F', '#DEB887'],
    silverBranch: ['#C0C0C0', '#D3D3D3', '#DCDCDC', '#F5F5F5']
  };

  const leafColors = {
    freshLeaves: ['#228B22', '#32CD32', '#00FF00', '#7CFC00'],
    matureLeaves: ['#006400', '#228B22', '#2E8B57', '#3CB371'],
    silverLeaves: ['#9ACD32', '#C0C0C0', '#D3D3D3', '#E6E6FA'],
    dryLeaves: ['#6B8E23', '#808000', '#BDB76B', '#F0E68C']
  };

  // Weighted random selection (your exact algorithm)
  const weightedSelection = (items) => {
    const totalWeight = Object.values(items).reduce((sum, item) => sum + item.weight, 0);
    let randomValue = random() * totalWeight;
    for (const [key, item] of Object.entries(items)) {
      randomValue -= item.weight;
      if (randomValue <= 0) return key;
    }
    return Object.keys(items)[0];
  };

  // Your exact rarity weights
  const oliveCountWeights = {
    1: { weight: 0.33 },
    2: { weight: 0.28 },
    3: { weight: 0.19 },
    4: { weight: 0.12 },
    5: { weight: 0.08 }
  };

  const oliveTypeWeights = {
    greenOlives: { weight: 0.30, displayName: 'Green Olives' },
    blackOlives: { weight: 0.25, displayName: 'Black Olives' },
    brownOlives: { weight: 0.20, displayName: 'Brown Olives' },
    purpleOlives: { weight: 0.15, displayName: 'Purple Olives' },
    ripeMixed: { weight: 0.10, displayName: 'Mixed Ripe Olives' }
  };

  // Generate using your weighted system
  const oliveCountKey = weightedSelection(oliveCountWeights);
  const oliveCount = parseInt(oliveCountKey);
  const oliveTypeKey = weightedSelection(oliveTypeWeights);
  const oliveType = oliveTypeWeights[oliveTypeKey].displayName;

  // Random color selection
  const getRandomColor = (colorArray) => {
    return colorArray[Math.floor(random() * colorArray.length)];
  };

  const oliveColorPalette = oliveColors[oliveTypeKey];
  const oliveColor = getRandomColor(oliveColorPalette);

  const branchPalettes = Object.values(branchColors);
  const randomBranchPalette = branchPalettes[Math.floor(random() * branchPalettes.length)];
  const branchColor = getRandomColor(randomBranchPalette);

  const leafPalettes = Object.values(leafColors);
  const randomLeafPalette = leafPalettes[Math.floor(random() * leafPalettes.length)];
  const leafColor = getRandomColor(randomLeafPalette);

  // Calculate rarity
  const rarity = calculateRarity(oliveCount, oliveTypeKey);

  return {
    seedValue,
    oliveCount,
    oliveType,
    oliveColor,
    branchColor,
    leafColor,
    ...rarity,
    oliveTypeKey // Store for further processing if needed
  };
};

// POST /api/olive-branches/generate - Generate new olive branch
router.post('/generate', requireAuth, async (req, res, next) => {
  try {
    // Check if user has seeds to plant
    const userSeeds = await prisma.inventoryItem.findFirst({
      where: {
        userId: req.user.id,
        itemType: 'seed',
        quantity: { gt: 0 }
      }
    });

    if (!userSeeds) {
      throw new ForbiddenError('You need at least one seed to generate an olive branch');
    }

    // Generate olive branch data
    const branchData = generateOliveBranchData();
    const botanicalId = await generateBotanicalId();

    // Generate SVG
    const svgContent = generateOliveBranchSVG(branchData);

    // Create olive branch in database with transaction
    const oliveBranch = await prisma.$transaction(async (tx) => {
      // Create the olive branch
      const branch = await tx.oliveBranch.create({
        data: {
          userId: req.user.id,
          seedValue: branchData.seedValue,
          oliveCount: branchData.oliveCount,
          oliveType: branchData.oliveType,
          oliveColor: branchData.oliveColor,
          branchColor: branchData.branchColor,
          leafColor: branchData.leafColor,
          countRarity: branchData.countRarity,
          typeRarity: branchData.typeRarity,
          countRarityPercentage: branchData.countRarityPercentage,
          typeRarityPercentage: branchData.typeRarityPercentage,
          botanicalId,
          svgCache: svgContent,
          isActive: true
        }
      });

      // Get the next available grid position for this user
      const maxPosition = await tx.inventoryItem.findFirst({
        where: { userId: req.user.id },
        orderBy: { gridPosition: 'desc' },
        select: { gridPosition: true }
      });

      const nextPosition = maxPosition?.gridPosition !== null && maxPosition?.gridPosition !== undefined
        ? maxPosition.gridPosition + 1
        : 0;

      // Add to user's inventory
      await tx.inventoryItem.create({
        data: {
          userId: req.user.id,
          itemType: 'branch',
          itemId: branch.id,
          quantity: 1,
          sourceType: 'generated',
          sourceReference: `gen-${Date.now()}`,
          gridPosition: nextPosition
        }
      });

      // Consume one seed
      if (userSeeds.quantity === 1) {
        await tx.inventoryItem.delete({
          where: { id: userSeeds.id }
        });
      } else {
        await tx.inventoryItem.update({
          where: { id: userSeeds.id },
          data: { quantity: { decrement: 1 } }
        });
      }

      return branch;
    });

    console.log('🌿 New olive branch generated:', oliveBranch.id, 'for user:', req.user.id);

    // Calculate trading value for response
    const tradingValue = calculateTradingValue(oliveBranch);

    res.status(201).json({
      message: 'Olive branch generated successfully!',
      oliveBranch: {
        id: oliveBranch.id,
        botanicalId: oliveBranch.botanicalId,
        oliveCount: oliveBranch.oliveCount,
        oliveType: oliveBranch.oliveType,
        countRarity: oliveBranch.countRarity,
        typeRarity: oliveBranch.typeRarity,
        createdAt: oliveBranch.createdAt,
        tradingValue
      },
      viewUrl: `/api/olive-branches/${oliveBranch.id}/svg`,
      rarityInfo: {
        countRarity: `${oliveBranch.countRarity} (${oliveBranch.countRarityPercentage}%)`,
        typeRarity: `${oliveBranch.typeRarity} (${oliveBranch.typeRarityPercentage}%)`
      },
      seedsRemaining: userSeeds.quantity - 1
    });

  } catch (error) {
    console.error('🔴 Error generating olive branch:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
      });
    }
    next(error);
  }
});

// GET /api/olive-branches/:id/svg - Serve SVG content with enhanced caching
router.get('/:id/svg', async (req, res, next) => {
  try {
    const branchId = parseInt(req.params.id);
    
    if (isNaN(branchId)) {
      return res.status(400).json({ 
        error: 'Invalid branch ID',
        code: 'INVALID_BRANCH_ID' 
      });
    }

    const oliveBranch = await prisma.oliveBranch.findUnique({
      where: { id: branchId },
      select: {
        id: true,
        seedValue: true,
        oliveCount: true,
        oliveType: true,
        oliveColor: true,
        branchColor: true,
        leafColor: true,
        svgCache: true,
        botanicalId: true,
        user: {
          select: {
            username: true
          }
        }
      }
    });

    if (!oliveBranch) {
      throw new NotFoundError('Olive branch not found');
    }

    // If no cached SVG, regenerate it
    let svgContent = oliveBranch.svgCache;
    if (!svgContent) {
      const branchData = {
        seedValue: oliveBranch.seedValue,
        oliveCount: oliveBranch.oliveCount,
        oliveType: oliveBranch.oliveType,
        oliveColor: oliveBranch.oliveColor,
        branchColor: oliveBranch.branchColor,
        leafColor: oliveBranch.leafColor,
      };
      svgContent = generateOliveBranchSVG(branchData);
      
      // Cache the regenerated SVG
      await prisma.oliveBranch.update({
        where: { id: branchId },
        data: { svgCache: svgContent }
      });
    }

    // Enhanced headers for better caching and metadata
    res.set({
      'Content-Type': 'image/svg+xml',
      'Cache-Control': 'public, max-age=31536000', // Cache for 1 year
      'ETag': `"${oliveBranch.id}-${oliveBranch.botanicalId}"`,
      'X-Branch-Owner': oliveBranch.user.username,
      'X-Botanical-ID': oliveBranch.botanicalId
    });

    res.send(svgContent);

  } catch (error) {
    console.error('🔴 Error serving SVG:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
      });
    }
    next(error);
  }
});

// GET /api/olive-branches/:id - Get detailed branch information
router.get('/:id', requireAuth, async (req, res, next) => {
  try {
    const branchId = parseInt(req.params.id);
    
    if (isNaN(branchId)) {
      return res.status(400).json({ 
        error: 'Invalid branch ID',
        code: 'INVALID_BRANCH_ID' 
      });
    }

    const oliveBranch = await prisma.oliveBranch.findUnique({
      where: { id: branchId },
      include: {
        user: {
          select: {
            id: true,
            username: true,
            role: true
          }
        },
        inventoryItems: {
          select: {
            id: true,
            gridPosition: true,
            sourceType: true,
            sourceReference: true,
            createdAt: true
          }
        }
      }
    });

    if (!oliveBranch) {
      throw new NotFoundError('Olive branch not found');
    }

    // Check permissions
    const isOwner = oliveBranch.userId === req.user.id;
    const canView = isOwner || req.user.role === 'admin' || req.user.role === 'moderator';

    if (!canView) {
      throw new ForbiddenError('Access forbidden - not your branch');
    }

    // Calculate additional stats
    const tradingValue = calculateTradingValue(oliveBranch);
    const isActiveForUser = req.user.activeOliveBranchId === oliveBranch.id;
    
    // Check if this branch is currently being traded
    const activeTrade = await prisma.trade.findFirst({
      where: {
        inventoryItem: {
          itemId: oliveBranch.id,
          itemType: 'branch'
        },
        status: {
          in: ['pending', 'confirmed', 'shipping']
        }
      },
      select: {
        id: true,
        status: true,
        priceCents: true,
        currency: true,
        seller: {
          select: { username: true }
        },
        buyer: {
          select: { username: true }
        }
      }
    });

    res.json({
      oliveBranch: {
        id: oliveBranch.id,
        botanicalId: oliveBranch.botanicalId,
        seedValue: oliveBranch.seedValue,
        oliveCount: oliveBranch.oliveCount,
        oliveType: oliveBranch.oliveType,
        oliveColor: oliveBranch.oliveColor,
        branchColor: oliveBranch.branchColor,
        leafColor: oliveBranch.leafColor,
        countRarity: oliveBranch.countRarity,
        typeRarity: oliveBranch.typeRarity,
        countRarityPercentage: oliveBranch.countRarityPercentage,
        typeRarityPercentage: oliveBranch.typeRarityPercentage,
        isActive: oliveBranch.isActive,
        createdAt: oliveBranch.createdAt,
        owner: {
          id: oliveBranch.user.id,
          username: oliveBranch.user.username,
          role: oliveBranch.user.role
        }
      },
      stats: {
        tradingValue,
        isActiveForUser,
        isOwner,
        rarityScore: {
          count: { Common: 1, Uncommon: 2, Rare: 3, 'Very Rare': 4, Legendary: 5 }[oliveBranch.countRarity] || 1,
          type: { Common: 1, Uncommon: 2, Rare: 3, 'Very Rare': 4, Legendary: 5 }[oliveBranch.typeRarity] || 1
        },
        rarityInfo: {
          countRarity: `${oliveBranch.countRarity} (${oliveBranch.countRarityPercentage}%)`,
          typeRarity: `${oliveBranch.typeRarity} (${oliveBranch.typeRarityPercentage}%)`
        }
      },
      inventory: oliveBranch.inventoryItems.length > 0 ? oliveBranch.inventoryItems[0] : null,
      activeTrade: activeTrade,
      permissions: {
        canSetActive: isOwner && !isActiveForUser,
        canTrade: isOwner && !activeTrade,
        canView: canView,
        canEdit: isOwner || req.user.role === 'admin'
      },
      svgUrl: `/api/olive-branches/${oliveBranch.id}/svg`
    });

  } catch (error) {
    console.error('🔴 Error fetching branch details:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
      });
    }
    next(error);
  }
});

// GET /api/olive-branches - Enhanced list with filtering and sorting
router.get('/', requireAuth, async (req, res, next) => {
  try {
    const userId = req.user.id;
    const {
      page = 1,
      limit = 20,
      rarity,
      oliveType,
      sortBy = 'createdAt',
      sortOrder = 'desc',
      active
    } = req.query;

    // Validate pagination
    const pageNum = Math.max(1, parseInt(page));
    const limitNum = Math.min(50, Math.max(1, parseInt(limit))); // Max 50 per page
    const offset = (pageNum - 1) * limitNum;

    // Build where clause
    const where = {
      userId,
      isActive: true,
      svgCache: { not: { contains: '<!-- REGISTRATION_PREVIEW -->' } }
    };

    // Apply filters
    if (rarity) {
      where.OR = [
        { countRarity: { contains: rarity, mode: 'insensitive' } },
        { typeRarity: { contains: rarity, mode: 'insensitive' } }
      ];
    }

    if (oliveType) {
      where.oliveType = { contains: oliveType, mode: 'insensitive' };
    }

    if (active !== undefined) {
      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { activeOliveBranchId: true }
      });

      if (active === 'true') {
        where.id = user.activeOliveBranchId;
      } else if (active === 'false') {
        where.id = { not: user.activeOliveBranchId };
      }
    }

    // Validate sort options
    const validSortFields = ['createdAt', 'oliveCount', 'botanicalId', 'countRarity', 'typeRarity'];
    const validSortOrders = ['asc', 'desc'];
    
    const sortField = validSortFields.includes(sortBy) ? sortBy : 'createdAt';
    const sortDirection = validSortOrders.includes(sortOrder) ? sortOrder : 'desc';

    // Get branches with count
    const [oliveBranches, total] = await Promise.all([
      prisma.oliveBranch.findMany({
        where,
        orderBy: { [sortField]: sortDirection },
        skip: offset,
        take: limitNum,
        select: {
          id: true,
          botanicalId: true,
          oliveCount: true,
          oliveType: true,
          oliveColor: true,
          branchColor: true,
          leafColor: true,
          countRarity: true,
          typeRarity: true,
          countRarityPercentage: true,
          typeRarityPercentage: true,
          createdAt: true,
          isActive: true
        }
      }),
      prisma.oliveBranch.count({ where })
    ]);

    // Add computed fields
    const branchesWithExtras = oliveBranches.map(branch => ({
      ...branch,
      svgUrl: `/api/olive-branches/${branch.id}/svg`,
      tradingValue: calculateTradingValue(branch),
      isActiveForUser: req.user.activeOliveBranchId === branch.id,
      rarityInfo: {
        countRarity: `${branch.countRarity} (${branch.countRarityPercentage}%)`,
        typeRarity: `${branch.typeRarity} (${branch.typeRarityPercentage}%)`
      }
    }));

    const totalPages = Math.ceil(total / limitNum);

    res.json({
      oliveBranches: branchesWithExtras,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages,
        hasNext: pageNum < totalPages,
        hasPrev: pageNum > 1
      },
      filters: {
        rarity: rarity || null,
        oliveType: oliveType || null,
        active: active || null,
        sortBy: sortField,
        sortOrder: sortDirection
      },
      summary: {
        totalBranches: total,
        pageCount: branchesWithExtras.length
      }
    });

  } catch (error) {
    console.error('🔴 Error fetching olive branches:', error);
    next(error);
  }
});

// PUT /api/olive-branches/:id/set-active - Set as user's active branch
router.put('/:id/set-active', requireAuth, async (req, res, next) => {
  try {
    const branchId = parseInt(req.params.id);
    
    if (isNaN(branchId)) {
      return res.status(400).json({ 
        error: 'Invalid branch ID',
        code: 'INVALID_BRANCH_ID' 
      });
    }

    // Verify branch exists and belongs to user
    const branch = await prisma.oliveBranch.findFirst({
      where: {
        id: branchId,
        userId: req.user.id,
        isActive: true
      }
    });

    if (!branch) {
      throw new NotFoundError('Olive branch not found or not owned by you');
    }

    // Update user's active branch
    const updatedUser = await prisma.user.update({
      where: { id: req.user.id },
      data: { activeOliveBranchId: branchId },
      select: {
        id: true,
        activeOliveBranchId: true,
        activeOliveBranch: {
          select: {
            id: true,
            botanicalId: true,
            oliveType: true
          }
        }
      }
    });

    res.json({
      message: 'Active olive branch updated successfully',
      activeBranch: {
        id: updatedUser.activeOliveBranch.id,
        botanicalId: updatedUser.activeOliveBranch.botanicalId,
        oliveType: updatedUser.activeOliveBranch.oliveType,
        svgUrl: `/api/olive-branches/${updatedUser.activeOliveBranch.id}/svg`
      }
    });

  } catch (error) {
    console.error('🔴 Error setting active branch:', error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
      });
    }
    next(error);
  }
});

// GET /api/olive-branches/stats/summary - Get user's collection summary
router.get('/stats/summary', requireAuth, async (req, res, next) => {
  try {
    const userId = req.user.id;

    // Get collection statistics
    const [
      totalBranches,
      rarityBreakdown,
      typeBreakdown,
      activeBranch,
      totalSeeds
    ] = await Promise.all([
      prisma.oliveBranch.count({
        where: {
          userId,
          isActive: true,
          svgCache: { not: { contains: '<!-- REGISTRATION_PREVIEW -->' } }
        }
      }),
      prisma.oliveBranch.groupBy({
        by: ['countRarity'],
        where: {
          userId,
          isActive: true,
          svgCache: { not: { contains: '<!-- REGISTRATION_PREVIEW -->' } }
        },
        _count: { countRarity: true }
      }),
      prisma.oliveBranch.groupBy({
        by: ['oliveType'],
        where: {
          userId,
          isActive: true,
          svgCache: { not: { contains: '<!-- REGISTRATION_PREVIEW -->' } }
        },
        _count: { oliveType: true }
      }),
      prisma.user.findUnique({
        where: { id: userId },
        select: {
          activeOliveBranch: {
            select: {
              id: true,
              botanicalId: true,
              oliveType: true,
              countRarity: true,
              typeRarity: true
            }
          }
        }
      }),
      prisma.inventoryItem.aggregate({
        where: {
          userId,
          itemType: 'seed'
        },
        _sum: {
          quantity: true
        }
      })
    ]);

    // Get most valuable branch
    const mostValuableBranch = await prisma.oliveBranch.findFirst({
      where: {
        userId,
        isActive: true,
        svgCache: { not: { contains: '<!-- REGISTRATION_PREVIEW -->' } }
      },
      orderBy: [
        { countRarityPercentage: 'asc' },
        { typeRarityPercentage: 'asc' },
        { oliveCount: 'desc' }
      ],
      select: {
        id: true,
        botanicalId: true,
        oliveType: true,
        countRarity: true,
        typeRarity: true,
        oliveCount: true
      }
    });

    res.json({
      summary: {
        totalBranches,
        totalSeeds: totalSeeds._sum.quantity || 0,
        activeBranch: activeBranch?.activeOliveBranch || null,
        mostValuableBranch: mostValuableBranch ? {
          ...mostValuableBranch,
          tradingValue: calculateTradingValue(mostValuableBranch),
          svgUrl: `/api/olive-branches/${mostValuableBranch.id}/svg`
        } : null
      },
      breakdown: {
        byRarity: rarityBreakdown.map(item => ({
          rarity: item.countRarity,
          count: item._count.countRarity
        })),
        byType: typeBreakdown.map(item => ({
          type: item.oliveType,
          count: item._count.oliveType
        }))
      },
      collectionScore: {
        diversityBonus: typeBreakdown.length * 5,
        quantityScore: totalBranches * 2,
        rarityBonus: rarityBreakdown.reduce((acc, item) => {
          const bonus = { Common: 1, Uncommon: 3, Rare: 5, 'Very Rare': 8, Legendary: 12 }[item.countRarity] || 1;
          return acc + (bonus * item._count.countRarity);
        }, 0)
      },
      canGenerate: totalSeeds._sum.quantity > 0
    });

  } catch (error) {
    console.error('🔴 Error fetching collection summary:', error);
    next(error);
  }
});

module.exports = router;

// === END src/routes/oliveBranches.js ===

// === src/routes/registrationBranches.js ===
// src/routes/registrationBranches.js
// Complete Registration-specific branch generation with personality tracking

const express = require('express');
const crypto = require('crypto');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult } = require('express-validator');

const { requireAuth } = require('../middleware/auth');
const { generateOliveBranchSVG } = require('../services/oliveBranchGenerator');

const router = express.Router();
const prisma = new PrismaClient();

console.log('🔵 Full registration routes loaded successfully!');

// Custom error classes
class ValidationError extends Error {
  constructor(message, details = null) {
    super(message);
    this.statusCode = 400;
    this.code = 'VALIDATION_ERROR';
    this.details = details;
  }
}

class ForbiddenError extends Error {
  constructor(message = 'Access forbidden') {
    super(message);
    this.statusCode = 403;
    this.code = 'FORBIDDEN';
  }
}

// Helper function to generate unique botanical ID
const generateBotanicalId = async () => {
  let botanicalId;
  let isUnique = false;
  
  while (!isUnique) {
    const prefix = 'OLV';
    const suffix = crypto.randomBytes(3).toString('hex').toUpperCase();
    botanicalId = `${prefix}-${suffix}`;
    
    const existing = await prisma.oliveBranch.findUnique({
      where: { botanicalId },
    });
    isUnique = !existing;
  }
  
  return botanicalId;
};

// Weighted random selection matching original system
const weightedSelection = (items, random) => {
  const totalWeight = Object.values(items).reduce((sum, item) => sum + item.weight, 0);
  let randomValue = random() * totalWeight;
  
  for (const [key, item] of Object.entries(items)) {
    randomValue -= item.weight;
    if (randomValue <= 0) return key;
  }
  
  return Object.keys(items)[0];
};

// Generate olive branch data with personality tracking
const generateRegistrationBranchData = () => {
  const seedValue = crypto.randomBytes(16).toString('hex');
  
  let seed = parseInt(seedValue.substring(0, 8), 16);
  const random = () => {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  };

  // Exact color palettes from original
  const oliveColors = {
    greenOlives: ['#6B8E23', '#808000', '#9ACD32', '#7CFC00', '#ADFF2F'],
    blackOlives: ['#2F2F2F', '#404040', '#1C1C1C', '#36454F', '#28282B'],
    brownOlives: ['#8B4513', '#A0522D', '#CD853F', '#D2691E', '#BC9A6A'],
    purpleOlives: ['#663399', '#4B0082', '#800080', '#9932CC', '#8B008B'],
    ripeMixed: ['#6B8E23', '#2F2F2F', '#663399', '#8B4513']
  };

  const branchColors = {
    youngBranch: ['#8FBC8F', '#90EE90', '#98FB98', '#7CFC00'],
    matureBranch: ['#556B2F', '#6B8E23', '#808000', '#9ACD32'],
    brownBranch: ['#8B7355', '#A0522D', '#CD853F', '#DEB887'],
    silverBranch: ['#C0C0C0', '#D3D3D3', '#DCDCDC', '#F5F5F5']
  };

  const leafColors = {
    freshLeaves: ['#228B22', '#32CD32', '#00FF00', '#7CFC00'],
    matureLeaves: ['#006400', '#228B22', '#2E8B57', '#3CB371'],
    silverLeaves: ['#9ACD32', '#C0C0C0', '#D3D3D3', '#E6E6FA'],
    dryLeaves: ['#6B8E23', '#808000', '#BDB76B', '#F0E68C']
  };

  const oliveCountWeights = {
    1: { weight: 0.33 },
    2: { weight: 0.28 },
    3: { weight: 0.19 },
    4: { weight: 0.12 },
    5: { weight: 0.08 }
  };

  const oliveTypeWeights = {
    greenOlives: { weight: 0.30, displayName: 'Green Olives', rarity: 'Common', rarityScore: 1 },
    blackOlives: { weight: 0.25, displayName: 'Black Olives', rarity: 'Common', rarityScore: 2 },
    brownOlives: { weight: 0.20, displayName: 'Brown Olives', rarity: 'Uncommon', rarityScore: 3 },
    purpleOlives: { weight: 0.15, displayName: 'Purple Olives', rarity: 'Rare', rarityScore: 4 },
    ripeMixed: { weight: 0.10, displayName: 'Mixed Ripe Olives', rarity: 'Very Rare', rarityScore: 5 }
  };

  const countRarities = {
    1: { name: 'Common', percentage: 33, rarityScore: 1 },
    2: { name: 'Common', percentage: 28, rarityScore: 2 },
    3: { name: 'Uncommon', percentage: 19, rarityScore: 3 },
    4: { name: 'Rare', percentage: 12, rarityScore: 4 },
    5: { name: 'Very Rare', percentage: 8, rarityScore: 5 }
  };

  const getRandomColor = (colorArray) => {
    return colorArray[Math.floor(random() * colorArray.length)];
  };

  // Generate branch characteristics
  const oliveCountKey = weightedSelection(oliveCountWeights, random);
  const oliveCount = parseInt(oliveCountKey);
  
  const oliveTypeKey = weightedSelection(oliveTypeWeights, random);
  const oliveTypeData = oliveTypeWeights[oliveTypeKey];

  const oliveColorPalette = oliveColors[oliveTypeKey];
  const oliveColor = getRandomColor(oliveColorPalette);

  const branchPalettes = Object.values(branchColors);
  const randomBranchPalette = branchPalettes[Math.floor(random() * branchPalettes.length)];
  const branchColor = getRandomColor(randomBranchPalette);

  const leafPalettes = Object.values(leafColors);
  const randomLeafPalette = leafPalettes[Math.floor(random() * leafPalettes.length)];
  const leafColor = getRandomColor(randomLeafPalette);

  // Calculate rarity scores for personality analysis
  const countRarity = countRarities[oliveCount];
  const totalRarityScore = countRarity.rarityScore + oliveTypeData.rarityScore;

  // Calculate trading value (seeds)
  const baseTradingValue = Math.floor(totalRarityScore * 1.5) + Math.floor(oliveCount * 0.5);

  return {
    seedValue,
    oliveCount,
    oliveType: oliveTypeData.displayName,
    oliveColor,
    branchColor,
    leafColor,
    countRarity: countRarity.name,
    countRarityPercentage: countRarity.percentage,
    typeRarity: oliveTypeData.rarity,
    typeRarityPercentage: Math.round(oliveTypeData.weight * 100),
    totalRarityScore,
    tradingValue: baseTradingValue,
    oliveTypeKey // Store for personality analysis
  };
};

// Test endpoint
router.get('/test', (req, res) => {
  console.log('🟢 Registration test endpoint hit!');
  res.json({ 
    message: 'Registration routes are working!', 
    timestamp: new Date().toISOString() 
  });
});

// Test auth endpoint
router.get('/test-auth', requireAuth, (req, res) => {
  console.log('🟢 Auth test endpoint hit for user:', req.user.id);
  res.json({ 
    message: 'Auth is working', 
    user: req.user,
    timestamp: new Date() 
  });
});

// POST /api/registration/generate-starter-branch - Generate preview branch
router.post('/generate-starter-branch', requireAuth, async (req, res, next) => {
  console.log('🔍 Starting generate-starter-branch for user:', req.user.id);
  
  try {
    // Check if user has already completed registration (has non-preview branches)
    const completedBranches = await prisma.oliveBranch.count({
      where: {
        userId: req.user.id,
        svgCache: { not: { contains: '<!-- REGISTRATION_PREVIEW -->' } }
      }
    });

    if (completedBranches > 0) {
      throw new ForbiddenError('Registration already completed. Use normal branch generation.');
    }

    // Check how many starter branches already generated (burn-as-you-go model allows only 1)
    const existingStarters = await prisma.oliveBranch.count({
      where: {
        userId: req.user.id,
        svgCache: { contains: '<!-- REGISTRATION_PREVIEW -->' }
      }
    });

    if (existingStarters >= 1) {
      throw new ForbiddenError('You can only generate one starter branch. Please confirm or regenerate.');
    }

    // Generate branch data
    console.log('🔍 Generating branch data...');
    const branchData = generateRegistrationBranchData();
    const botanicalId = await generateBotanicalId();

    // Generate SVG with registration preview marker
    let svgContent = generateOliveBranchSVG(branchData);
    svgContent = svgContent.replace('</svg>', '<!-- REGISTRATION_PREVIEW --></svg>');

    console.log('🔍 Creating olive branch in database...');
    
    // Create temporary registration branch
    const oliveBranch = await prisma.oliveBranch.create({
      data: {
        userId: req.user.id,
        seedValue: branchData.seedValue,
        oliveCount: branchData.oliveCount,
        oliveType: branchData.oliveType,
        oliveColor: branchData.oliveColor,
        branchColor: branchData.branchColor,
        leafColor: branchData.leafColor,
        countRarity: branchData.countRarity,
        typeRarity: branchData.typeRarity,
        countRarityPercentage: branchData.countRarityPercentage,
        typeRarityPercentage: branchData.typeRarityPercentage,
        botanicalId,
        svgCache: svgContent,
        isActive: false // Not active until confirmed
      }
    });

    console.log('🟢 Starter branch generated successfully:', oliveBranch.id);

    res.status(201).json({
      message: 'Starter branch generated successfully!',
      oliveBranch: {
        id: oliveBranch.id,
        botanicalId: oliveBranch.botanicalId,
        oliveCount: oliveBranch.oliveCount,
        oliveType: oliveBranch.oliveType,
        countRarity: oliveBranch.countRarity,
        typeRarity: oliveBranch.typeRarity,
        createdAt: oliveBranch.createdAt,
        tradingValue: branchData.tradingValue,
        totalRarityScore: branchData.totalRarityScore
      },
      viewUrl: `/api/olive-branches/${oliveBranch.id}/svg`,
      rarityInfo: {
        countRarity: `${oliveBranch.countRarity} (${oliveBranch.countRarityPercentage}%)`,
        typeRarity: `${oliveBranch.typeRarity} (${oliveBranch.typeRarityPercentage}%)`,
        totalRarityScore: branchData.totalRarityScore,
        tradingValue: `~${branchData.tradingValue} seeds`
      },
      psychologicalTriggers: {
        uniqueness: "This exact olive combination will never exist again",
        burnAsYouGo: "Generate another branch and this one will be lost forever",
        canConfirm: true
      }
    });

  } catch (error) {
    console.error('🔴 Error in confirm-starter-branch:', error);
    console.error('🔴 Error code:', error.code);
    console.error('🔴 Error stack:', error.stack);
    
    if (error.statusCode) {
      return res.status(error.statusCode).json({
        error: error.message,
        code: error.code,
      });
    }
    next(error);
  }
});

// POST /api/registration/confirm-starter-branch - Final selection (BURN AS YOU GO MODEL)
router.post('/confirm-starter-branch', requireAuth, async (req, res, next) => {
    console.log('🔍 Starting confirmation for user:', req.user.id);
    try {
        // Get current starter branch (only one exists in burn-as-you-go model)
        const starterBranch = await prisma.oliveBranch.findFirst({
            where: {
                userId: req.user.id,
                svgCache: { contains: '<!-- REGISTRATION_PREVIEW -->' }
            }
        });

        if (!starterBranch) {
            throw new ForbiddenError('No starter branch found. Generate a branch first.');
        }

        console.log('🔍 Found starter branch:', starterBranch.id);

        // Determine personality based on branch characteristics
        let personalityType = 'balanced';
        let badges = [];
        const rarity = starterBranch.countRarity;
        const typeRarity = starterBranch.typeRarity;

        if ((rarity === 'Very Rare' || typeRarity === 'Very Rare') && starterBranch.oliveCount >= 4) {
            personalityType = 'rarity_seeker';
            badges.push('Collector');
        } else if (rarity === 'Common' && typeRarity === 'Common') {
            personalityType = 'minimalist';
            badges.push('Minimalist');
        } else {
            personalityType = 'aesthetic_focused';
            badges.push('Visionary');
        }

        console.log('🔍 Personality analysis:', personalityType, badges);

        // Transaction: Confirm chosen branch, update user profile
        const result = await prisma.$transaction(async (tx) => {
            // Remove registration preview marker from chosen branch
            const cleanSvg = starterBranch.svgCache.replace('<!-- REGISTRATION_PREVIEW -->', '');
            
            // Update chosen branch to be permanent and active
            const finalBranch = await tx.oliveBranch.update({
                where: { id: starterBranch.id },
                data: {
                    svgCache: cleanSvg,
                    isActive: true
                }
            });

            console.log('🔍 Updated branch to be permanent:', finalBranch.id);

            // Get the next available grid position for this user
            const maxPosition = await tx.inventoryItem.findFirst({
                where: { userId: req.user.id },
                orderBy: { gridPosition: 'desc' },
                select: { gridPosition: true }
            });
            
            const nextPosition = maxPosition?.gridPosition !== null && maxPosition?.gridPosition !== undefined 
                ? maxPosition.gridPosition + 1 
                : 0;

            console.log('🔍 Next grid position:', nextPosition);

            // Add chosen branch to inventory with proper position
            // Add chosen branch to inventory with proper position
              const inventoryItem = await tx.inventoryItem.create({
              data: {
                userId: req.user.id,
                itemType: 'branch',
                itemId: finalBranch.id,
                quantity: 1,
                sourceType: 'registration', // Shortened to fit 20 char limit
                sourceReference: `reg-${finalBranch.id}`, // Short reference
                gridPosition: nextPosition
                }
                });

            console.log('🔍 Created inventory item:', inventoryItem.id);

            // Update user with personality profile and set active branch
            const updatedUser = await tx.user.update({
                where: { id: req.user.id },
                data: {
                    activeOliveBranchId: finalBranch.id,
                    bio: `${badges.join(', ')} • Registration choice: ${personalityType}`
                }
            });

            console.log('🔍 Updated user profile for:', updatedUser.id);

            return { finalBranch, inventoryItem, updatedUser };
        });

        console.log('🟢 Registration completed successfully for user:', req.user.id);

        res.json({
            message: 'Registration completed successfully!',
            chosenBranch: {
                id: result.finalBranch.id,
                botanicalId: result.finalBranch.botanicalId,
                oliveCount: result.finalBranch.oliveCount,
                oliveType: result.finalBranch.oliveType,
                countRarity: result.finalBranch.countRarity,
                typeRarity: result.finalBranch.typeRarity,
                isActive: result.finalBranch.isActive
            },
            inventoryItem: {
                id: result.inventoryItem.id,
                gridPosition: result.inventoryItem.gridPosition,
                sourceType: result.inventoryItem.sourceType
            },
            personalityProfile: {
                type: personalityType,
                badges: badges,
                gamblingStyle: 'burn_as_you_go_model'
            },
            registrationComplete: true,
            nextSteps: {
                exploreMarketplace: true,
                earnMoreSeeds: true,
                viewAchievements: true
            }
        });

    } catch (error) {
        console.error('🔴 Error in confirm-starter-branch:', error);
        console.error('🔴 Error code:', error.code);
        console.error('🔴 Error stack:', error.stack);
        
        if (error.statusCode) {
            return res.status(error.statusCode).json({
                error: error.message,
                code: error.code,
            });
        }
        next(error);
    }
});


// GET /api/registration/starter-branches - View generated starter branches
router.get('/starter-branches', requireAuth, async (req, res, next) => {
  try {
    const starterBranches = await prisma.oliveBranch.findMany({
      where: {
        userId: req.user.id,
        svgCache: { contains: '<!-- REGISTRATION_PREVIEW -->' }
      },
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        botanicalId: true,
        oliveCount: true,
        oliveType: true,
        countRarity: true,
        typeRarity: true,
        countRarityPercentage: true,
        typeRarityPercentage: true,
        createdAt: true,
        oliveColor: true,
        branchColor: true,
        leafColor: true
      }
    });

    res.json({
      branches: starterBranches.map(branch => ({
        ...branch,
        svgUrl: `/api/olive-branches/${branch.id}/svg`
      })),
      canGenerate: starterBranches.length === 0, // Burn-as-you-go: only allow 1
      mustChoose: starterBranches.length > 0
    });

  } catch (error) {
    next(error);
  }
});

// DELETE /api/registration/reset-starter-branches - Reset registration (for testing)
router.delete('/reset-starter-branches', requireAuth, async (req, res, next) => {
  try {
    console.log('🔍 Resetting starter branches for user:', req.user.id);
    
    // Delete all preview branches for this user
    const deleted = await prisma.oliveBranch.deleteMany({
      where: {
        userId: req.user.id,
        svgCache: { contains: '<!-- REGISTRATION_PREVIEW -->' }
      }
    });

    res.json({
      message: 'Starter branches reset successfully',
      deletedCount: deleted.count,
      canGenerateNew: true
    });

  } catch (error) {
    next(error);
  }
});

module.exports = router;

// === END src/routes/registrationBranches.js ===

// === src/routes/search.js ===
// routes/search.js - Clean minimal version
const express = require('express');
const { ResponseWrapper } = require('../middleware/errorHandler');

const router = express.Router();

console.log('🔍 Minimal Search routes loaded!');

router.get('/test', (req, res) => {
  ResponseWrapper.success(res, {
    message: 'Search system is working!',
    timestamp: new Date().toISOString()
  });
});

module.exports = router;

// === END src/routes/search.js ===

// === src/routes/store.js ===
// src/routes/store.js - CORRECTED ResponseWrapper Usage
const express = require('express');
const { PrismaClient } = require('@prisma/client');
const AuthMiddleware = require('../middleware/auth');
// CORRECT import - your ResponseWrapper is a static class
const { ResponseWrapper } = require('../middleware/errorHandler');
const stripeService = require('../services/stripeService');
const crypto = require('crypto');

const router = express.Router();
const prisma = new PrismaClient();

// Helper function to generate order number
const generateOrderNumber = () => {
  const year = new Date().getFullYear();
  const random = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');
  return `ORD-${year}-${random}`;
};

/**
 * @route GET /api/store/test
 * @desc Test endpoint to verify store is working
 * @access Public
 */
router.get('/test', (req, res) => {
  return ResponseWrapper.success(res, {
    message: 'Store API is working!',
    timestamp: new Date().toISOString(),
    features: {
      categories: '/api/store/categories',
      items: '/api/store/items', 
      cart: '/api/store/cart (auth required)',
      checkout: '/api/store/checkout (auth required)'
    }
  }, 'Store API test successful');
});

/**
 * @route GET /api/store/categories
 * @desc Get all store categories
 * @access Public
 */
router.get('/categories', async (req, res) => {
  try {
    const { item_type } = req.query;
    
    const categories = await prisma.store_categories.findMany({
      where: {
        is_active: true,
        ...(item_type && { item_type })
      },
      select: {
        id: true,
        name: true,
        slug: true,
        description: true,
        item_type: true,
        display_order: true,
        parent_id: true,
        _count: {
          select: {
            store_items: {
              where: { is_active: true }
            }
          }
        }
      },
      orderBy: [
        { display_order: 'asc' },
        { name: 'asc' }
      ]
    });

    return ResponseWrapper.success(res, {
      categories,
      total: categories.length,
      filters: { item_type }
    }, 'Categories retrieved successfully');

  } catch (error) {
    console.error('Error fetching categories:', error);
    return ResponseWrapper.error(res, 'Failed to fetch categories', 500, 'FETCH_CATEGORIES_FAILED');
  }
});

/**
 * @route GET /api/store/items
 * @desc Get store items with filtering and pagination
 * @access Public
 */
router.get('/items', async (req, res) => {
  try {
    const {
      category_id,
      item_type,
      featured,
      search,
      sort = 'created_at',
      order = 'desc',
      page = 1,
      limit = 20
    } = req.query;

    const skip = (parseInt(page) - 1) * parseInt(limit);
    const take = parseInt(limit);

    // Build where conditions
    const where = {
      is_active: true,
      published_at: { lte: new Date() },
      ...(category_id && { category_id: parseInt(category_id) }),
      ...(item_type && { item_type }),
      ...(featured && { is_featured: featured === 'true' }),
      ...(search && {
        OR: [
          { name: { contains: search, mode: 'insensitive' } },
          { description: { contains: search, mode: 'insensitive' } },
          { short_description: { contains: search, mode: 'insensitive' } }
        ]
      })
    };

    // Build order by
    const orderBy = {};
    orderBy[sort] = order;

    const [items, totalCount] = await Promise.all([
      prisma.store_items.findMany({
        where,
        include: {
          category: {
            select: { id: true, name: true, slug: true }
          },
          variants: {
            where: { is_active: true },
            select: {
              id: true,
              name: true,
              options: true,
              price_cents: true,
              stock_quantity: true
            }
          },
          _count: {
            select: { variants: true }
          }
        },
        orderBy,
        skip,
        take
      }),
      prisma.store_items.count({ where })
    ]);

    return ResponseWrapper.success(res, {
      items: items.map(item => ({
        ...item,
        price_formatted: `$${(item.price_cents / 100).toFixed(2)}`,
        compare_at_price_formatted: item.compare_at_price_cents 
          ? `$${(item.compare_at_price_cents / 100).toFixed(2)}` 
          : null,
        in_stock: item.manage_inventory ? item.stock_quantity > 0 : true,
        low_stock: item.manage_inventory && item.low_stock_threshold 
          ? item.stock_quantity <= item.low_stock_threshold 
          : false
      })),
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalCount,
        pages: Math.ceil(totalCount / parseInt(limit))
      },
      filters: { category_id, item_type, featured, search, sort, order }
    }, 'Store items retrieved successfully');

  } catch (error) {
    console.error('Error fetching store items:', error);
    return ResponseWrapper.error(res, 'Failed to fetch store items', 500, 'FETCH_ITEMS_FAILED');
  }
});

/**
 * @route GET /api/store/items/:slug
 * @desc Get single store item by slug
 * @access Public
 */
router.get('/items/:slug', async (req, res) => {
  try {
    const { slug } = req.params;

    const item = await prisma.store_items.findUnique({
      where: { 
        slug,
        is_active: true,
        published_at: { lte: new Date() }
      },
      include: {
        category: {
          select: { id: true, name: true, slug: true }
        },
        variants: {
          where: { is_active: true },
          orderBy: { id: 'asc' }
        }
      }
    });

    if (!item) {
      return ResponseWrapper.error(res, 'Store item not found', 404, 'ITEM_NOT_FOUND');
    }

    return ResponseWrapper.success(res, {
      ...item,
      price_formatted: `$${(item.price_cents / 100).toFixed(2)}`,
      compare_at_price_formatted: item.compare_at_price_cents 
        ? `$${(item.compare_at_price_cents / 100).toFixed(2)}` 
        : null,
      in_stock: item.manage_inventory ? item.stock_quantity > 0 : true,
      low_stock: item.manage_inventory && item.low_stock_threshold 
        ? item.stock_quantity <= item.low_stock_threshold 
        : false,
      variants: item.variants.map(variant => ({
        ...variant,
        price_formatted: variant.price_cents 
          ? `$${(variant.price_cents / 100).toFixed(2)}` 
          : `$${(item.price_cents / 100).toFixed(2)}`,
        in_stock: variant.stock_quantity > 0
      }))
    }, 'Store item retrieved successfully');

  } catch (error) {
    console.error('Error fetching store item:', error);
    return ResponseWrapper.error(res, 'Failed to fetch store item', 500, 'FETCH_ITEM_FAILED');
  }
});

/**
 * @route POST /api/store/cart/add
 * @desc Add item to cart
 * @access Private
 */
router.post('/cart/add', AuthMiddleware.requireAuth, async (req, res) => {
  try {
    const { item_id, variant_id, quantity = 1 } = req.body;
    const userId = req.user.id;

    // Validate item exists and is active
    const item = await prisma.store_items.findUnique({
      where: { id: parseInt(item_id), is_active: true },
      include: {
        variants: variant_id ? {
          where: { id: parseInt(variant_id) }
        } : false
      }
    });

    if (!item) {
      return ResponseWrapper.error(res, 'Item not found', 404, 'ITEM_NOT_FOUND');
    }

    // Validate variant if specified
    let variant = null;
    if (variant_id) {
      variant = item.variants?.[0];
      if (!variant) {
        return ResponseWrapper.error(res, 'Variant not found', 404, 'VARIANT_NOT_FOUND');
      }
    }

    // Check inventory
    const currentStock = variant ? variant.stock_quantity : item.stock_quantity;
    if (item.manage_inventory && currentStock < quantity) {
      return ResponseWrapper.error(res, 'Insufficient inventory', 400, 'INSUFFICIENT_INVENTORY');
    }

    // Determine price
    const unitPrice = variant?.price_cents || item.price_cents;

    // Create or update cart item
    const cartItem = await prisma.cart_items.upsert({
      where: {
        user_id_item_id_variant_id: {
          user_id: userId,
          item_id: parseInt(item_id),
          variant_id: variant_id ? parseInt(variant_id) : null
        }
      },
      update: {
        quantity: { increment: parseInt(quantity) },
        unit_price_cents: unitPrice,
        updated_at: new Date()
      },
      create: {
        user_id: userId,
        item_id: parseInt(item_id),
        variant_id: variant_id ? parseInt(variant_id) : null,
        quantity: parseInt(quantity),
        unit_price_cents: unitPrice
      },
      include: {
        item: {
          select: { name: true, slug: true, featured_image: true }
        },
        variant: {
          select: { name: true, options: true }
        }
      }
    });

    return ResponseWrapper.success(res, {
      ...cartItem,
      total_price_cents: cartItem.quantity * cartItem.unit_price_cents,
      total_price_formatted: `$${((cartItem.quantity * cartItem.unit_price_cents) / 100).toFixed(2)}`,
      unit_price_formatted: `$${(cartItem.unit_price_cents / 100).toFixed(2)}`
    }, 'Item added to cart successfully');

  } catch (error) {
    console.error('Error adding to cart:', error);
    return ResponseWrapper.error(res, 'Failed to add item to cart', 500, 'ADD_TO_CART_FAILED');
  }
});

/**
 * @route GET /api/store/cart
 * @desc Get user's cart
 * @access Private
 */
router.get('/cart', AuthMiddleware.requireAuth, async (req, res) => {
  try {
    const userId = req.user.id;

    const cartItems = await prisma.cart_items.findMany({
      where: { user_id: userId },
      include: {
        item: {
          select: {
            id: true,
            name: true,
            slug: true,
            featured_image: true,
            item_type: true,
            manage_inventory: true,
            stock_quantity: true,
            is_active: true
          }
        },
        variant: {
          select: {
            id: true,
            name: true,
            options: true,
            stock_quantity: true,
            is_active: true
          }
        }
      },
      orderBy: { created_at: 'asc' }
    });

    // Filter out inactive items and calculate totals
    const activeCartItems = cartItems.filter(item => 
      item.item.is_active && (!item.variant || item.variant.is_active)
    );

    const cartSummary = {
      subtotal_cents: 0,
      total_items: 0,
      total_quantity: 0
    };

    const formattedItems = activeCartItems.map(cartItem => {
      const totalPrice = cartItem.quantity * cartItem.unit_price_cents;
      cartSummary.subtotal_cents += totalPrice;
      cartSummary.total_items += 1;
      cartSummary.total_quantity += cartItem.quantity;

      // Check current inventory
      const currentStock = cartItem.variant 
        ? cartItem.variant.stock_quantity 
        : cartItem.item.stock_quantity;
      
      const available = !cartItem.item.manage_inventory || currentStock >= cartItem.quantity;

      return {
        ...cartItem,
        total_price_cents: totalPrice,
        total_price_formatted: `$${(totalPrice / 100).toFixed(2)}`,
        unit_price_formatted: `$${(cartItem.unit_price_cents / 100).toFixed(2)}`,
        available,
        max_available: cartItem.item.manage_inventory ? currentStock : 999
      };
    });

    return ResponseWrapper.success(res, {
      items: formattedItems,
      summary: {
        ...cartSummary,
        subtotal_formatted: `$${(cartSummary.subtotal_cents / 100).toFixed(2)}`
      }
    }, 'Cart retrieved successfully');

  } catch (error) {
    console.error('Error fetching cart:', error);
    return ResponseWrapper.error(res, 'Failed to fetch cart', 500, 'FETCH_CART_FAILED');
  }
});

/**
 * @route DELETE /api/store/cart/:id
 * @desc Remove item from cart
 * @access Private
 */
router.delete('/cart/:id', AuthMiddleware.requireAuth, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    await prisma.cart_items.delete({
      where: {
        id: parseInt(id),
        user_id: userId
      }
    });

    return ResponseWrapper.success(res, { 
      removed_item_id: parseInt(id) 
    }, 'Item removed from cart successfully');

  } catch (error) {
    console.error('Error removing cart item:', error);
    return ResponseWrapper.error(res, 'Failed to remove cart item', 500, 'REMOVE_CART_ITEM_FAILED');
  }
});

module.exports = router;

// === END src/routes/store.js ===

// === src/routes/users.js ===
// routes/users.js - Enhanced User Management with Status System
const express = require('express');
const { body, query, validationResult } = require('express-validator');
const { PrismaClient } = require('@prisma/client');
const AuthMiddleware = require('../middleware/auth');
const { ResponseWrapper, ValidationError, NotFoundError, ForbiddenError } = require('../middleware/errorHandler');

const router = express.Router();
const prisma = new PrismaClient();

console.log('👥 Enhanced User Management routes loaded!');

// Helper function to calculate user activity status
const calculateUserStatus = (user) => {
  const now = new Date();
  const lastSeen = new Date(user.lastSeen);
  const minutesSinceLastSeen = (now - lastSeen) / (1000 * 60);

  if (user.isOnline && minutesSinceLastSeen < 5) {
    return 'online';
  } else if (minutesSinceLastSeen < 15) {
    return 'away';
  } else if (minutesSinceLastSeen < 1440) { // 24 hours
    return 'inactive';
  } else if (minutesSinceLastSeen < 10080) { // 7 days
    return 'dormant';
  } else {
    return 'offline';
  }
};

// Helper function to format user for API response
const formatUserForAPI = (user, includePrivateData = false) => {
  const status = calculateUserStatus(user);
  
  const baseUser = {
    username: user.username,
    role: user.role,
    country: user.country,
    status,
    lastSeen: user.lastSeen,
    joinedDate: user.createdAt,
    isOnline: user.isOnline,
    branch: user.branch
  };

  // Add item count from inventory
  if (user.inventoryItems) {
    baseUser.itemCount = user.inventoryItems.length;
  }

  // Add olive branch info if available
  if (user.activeOliveBranch) {
    baseUser.activeOliveBranch = {
      id: user.activeOliveBranch.id,
      botanicalId: user.activeOliveBranch.botanicalId,
      oliveType: user.activeOliveBranch.oliveType,
      svgUrl: `/api/olive-branches/${user.activeOliveBranch.id}/svg`
    };
  }

  // Include private data for own profile or admin access
  if (includePrivateData) {
    baseUser.id = user.id;
    baseUser.idNo = user.idNo;
    baseUser.email = user.email;
    baseUser.botanicalSignature = {
      oliveCount: user.activeOliveBranch?.oliveCount || 0,
      oliveType: user.activeOliveBranch?.oliveType || 'none',
      countRarity: user.activeOliveBranch?.countRarity || 'none',
      typeRarity: user.activeOliveBranch?.typeRarity || 'none'
    };
  }

  return baseUser;
};

// GET /api/users - Enhanced user listing with filtering
router.get('/',
  AuthMiddleware.requireAuth,
  [
    query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),
    query('limit').optional().isInt({ min: 1, max: 50 }).withMessage('Limit must be between 1 and 50'),
    query('role').optional().isIn(['operative', 'contributor', 'moderator', 'beta_tester', 'admin']),
    query('status').optional().isIn(['online', 'away', 'inactive', 'dormant', 'offline']),
    query('search').optional().isLength({ min: 1, max: 50 }).withMessage('Search must be 1-50 characters'),
    query('sortBy').optional().isIn(['username', 'lastSeen', 'createdAt', 'role']),
    query('sortOrder').optional().isIn(['asc', 'desc'])
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Invalid query parameters', errors.array());
      }

      const {
        page = 1,
        limit = 20,
        role,
        status,
        search,
        sortBy = 'lastSeen',
        sortOrder = 'desc'
      } = req.query;

      const pageNum = parseInt(page);
      const limitNum = parseInt(limit);
      const offset = (pageNum - 1) * limitNum;

      // Build where clause
      const where = {
        isActive: true
      };

      if (role) {
        where.role = role;
      }

      if (search) {
        where.username = {
          contains: search,
          mode: 'insensitive'
        };
      }

      // Get users with related data
      const [users, total] = await Promise.all([
        prisma.user.findMany({
          where,
          orderBy: { [sortBy]: sortOrder },
          skip: offset,
          take: limitNum,
          select: {
            id: true,
            username: true,
            role: true,
            country: true,
            lastSeen: true,
            isOnline: true,
            createdAt: true,
            branch: true,
            activeOliveBranch: {
              select: {
                id: true,
                botanicalId: true,
                oliveType: true,
                oliveCount: true,
                countRarity: true,
                typeRarity: true
              }
            },
            inventoryItems: {
              select: {
                id: true
              }
            }
          }
        }),
        prisma.user.count({ where })
      ]);

      // Filter by status if requested (post-query filtering since it's calculated)
      let filteredUsers = users;
      if (status) {
        filteredUsers = users.filter(user => calculateUserStatus(user) === status);
      }

      // Format users for response
      const formattedUsers = filteredUsers.map(user => formatUserForAPI(user));

      // Get available filter options for frontend
      const [roleBreakdown, statusBreakdown] = await Promise.all([
        prisma.user.groupBy({
          by: ['role'],
          where: { isActive: true },
          _count: { role: true }
        }),
        // Status breakdown requires post-processing since it's calculated
        Promise.resolve(users.reduce((acc, user) => {
          const userStatus = calculateUserStatus(user);
          acc[userStatus] = (acc[userStatus] || 0) + 1;
          return acc;
        }, {}))
      ]);

      return ResponseWrapper.success(res, {
        users: formattedUsers,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: status ? filteredUsers.length : total,
          totalPages: Math.ceil((status ? filteredUsers.length : total) / limitNum),
          hasNext: pageNum < Math.ceil((status ? filteredUsers.length : total) / limitNum),
          hasPrev: pageNum > 1
        },
        filters: {
          roles: roleBreakdown.map(r => ({ role: r.role, count: r._count.role })),
          statuses: Object.entries(statusBreakdown).map(([status, count]) => ({ status, count })),
          currentFilters: {
            role: role || null,
            status: status || null,
            search: search || null,
            sortBy,
            sortOrder
          }
        }
      });

    } catch (error) {
      next(error);
    }
  }
);

// GET /api/users/:username - Get specific user profile
router.get('/:username',
  AuthMiddleware.requireAuth,
  async (req, res, next) => {
    try {
      const { username } = req.params;

      const user = await prisma.user.findUnique({
        where: { username },
        select: {
          id: true,
          username: true,
          role: true,
          country: true,
          lastSeen: true,
          isOnline: true,
          createdAt: true,
          branch: true,
          idNo: true,
          email: true,
          activeOliveBranch: {
            select: {
              id: true,
              botanicalId: true,
              oliveType: true,
              oliveCount: true,
              countRarity: true,
              typeRarity: true,
              countRarityPercentage: true,
              typeRarityPercentage: true
            }
          },
          inventoryItems: {
            where: {
              itemType: { in: ['branch', 'item', 'achievement'] }
            },
            orderBy: { gridPosition: 'asc' },
            take: 4, // Display slots
            select: {
              id: true,
              itemType: true,
              itemId: true,
              quantity: true,
              gridPosition: true,
              oliveBranch: {
                select: {
                  id: true,
                  botanicalId: true,
                  oliveType: true,
                  countRarity: true,
                  typeRarity: true
                }
              }
            }
          },
          _count: {
            select: {
              inventoryItems: true,
              oliveBranches: {
                where: { isActive: true }
              }
            }
          }
        }
      });

      if (!user) {
        throw new NotFoundError('User not found');
      }

      // Check permissions for private data
      const isOwnProfile = req.user.username === username;
      const isAdmin = req.user.role === 'admin';
      const canViewPrivateData = isOwnProfile || isAdmin;

      const formattedUser = formatUserForAPI(user, canViewPrivateData);

      // Add detailed inventory and stats for profile view
      const profileData = {
        profile: formattedUser,
        stats: {
          totalItems: user._count.inventoryItems,
          totalBranches: user._count.oliveBranches,
          itemsDisplayed: user.inventoryItems.filter(item => item.gridPosition < 4).length,
          collectionValue: user.inventoryItems.length * 10 // Simplified calculation
        },
        displayInventory: user.inventoryItems.map(item => ({
          id: item.id,
          type: item.itemType,
          quantity: item.quantity,
          gridPosition: item.gridPosition,
          // Add specific data based on item type
          ...(item.itemType === 'branch' && item.oliveBranch ? {
            botanicalId: item.oliveBranch.botanicalId,
            oliveType: item.oliveBranch.oliveType,
            rarity: `${item.oliveBranch.countRarity} / ${item.oliveBranch.typeRarity}`,
            icon: '🌿'
          } : {
            icon: item.itemType === 'item' ? '📦' : '🏆'
          })
        })),
        permissions: {
          canEdit: isOwnProfile,
          canViewInventory: canViewPrivateData,
          canMessage: !isOwnProfile && req.user.role !== 'guest'
        }
      };

      return ResponseWrapper.success(res, profileData);

    } catch (error) {
      next(error);
    }
  }
);

// PUT /api/users/:username/status - Update user status (admin only)
router.put('/:username/status',
  AuthMiddleware.requireAuth,
  AuthMiddleware.requireRole(['admin', 'moderator']),
  [
    body('isActive').isBoolean().withMessage('isActive must be a boolean'),
    body('reason').optional().isLength({ min: 1, max: 200 }).withMessage('Reason must be 1-200 characters')
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Invalid request data', errors.array());
      }

      const { username } = req.params;
      const { isActive, reason } = req.body;

      const user = await prisma.user.findUnique({
        where: { username },
        select: { id: true, username: true, role: true, isActive: true }
      });

      if (!user) {
        throw new NotFoundError('User not found');
      }

      // Prevent non-admin from modifying admin accounts
      if (user.role === 'admin' && req.user.role !== 'admin') {
        throw new ForbiddenError('Cannot modify administrator accounts');
      }

      const updatedUser = await prisma.user.update({
        where: { username },
        data: { 
          isActive,
          // Add audit log entry
          auditLog: {
            create: {
              action: isActive ? 'account_activated' : 'account_suspended',
              performedBy: req.user.id,
              reason: reason || 'No reason provided',
              timestamp: new Date()
            }
          }
        },
        select: {
          username: true,
          role: true,
          isActive: true,
          lastSeen: true
        }
      });

      return ResponseWrapper.success(res, {
        user: updatedUser,
        action: isActive ? 'activated' : 'suspended'
      }, `User ${username} ${isActive ? 'activated' : 'suspended'} successfully`);

    } catch (error) {
      next(error);
    }
  }
);

// GET /api/users/stats/overview - System user statistics
router.get('/stats/overview',
  AuthMiddleware.requireAuth,
  AuthMiddleware.requireRole(['admin', 'moderator']),
  async (req, res, next) => {
    try {
      const [
        totalUsers,
        activeUsers,
        onlineUsers,
        newUsersThisWeek,
        roleBreakdown
      ] = await Promise.all([
        prisma.user.count(),
        prisma.user.count({ where: { isActive: true } }),
        prisma.user.count({ 
          where: { 
            isOnline: true,
            lastSeen: { gte: new Date(Date.now() - 15 * 60 * 1000) } // Last 15 minutes
          } 
        }),
        prisma.user.count({ 
          where: { 
            createdAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }
          } 
        }),
        prisma.user.groupBy({
          by: ['role'],
          _count: { role: true }
        })
      ]);

      // Get activity trends for the last 7 days
      const activityTrends = await Promise.all(
        Array.from({ length: 7 }, (_, i) => {
          const date = new Date();
          date.setDate(date.getDate() - i);
          const startOfDay = new Date(date.setHours(0, 0, 0, 0));
          const endOfDay = new Date(date.setHours(23, 59, 59, 999));
          
          return prisma.user.count({
            where: {
              lastSeen: {
                gte: startOfDay,
                lte: endOfDay
              }
            }
          }).then(count => ({
            date: startOfDay.toISOString().split('T')[0],
            activeUsers: count
          }));
        })
      );

      return ResponseWrapper.success(res, {
        overview: {
          totalUsers,
          activeUsers,
          onlineUsers,
          newUsersThisWeek,
          activityRate: totalUsers > 0 ? Math.round((activeUsers / totalUsers) * 100) : 0
        },
        breakdown: {
          byRole: roleBreakdown.map(r => ({ role: r.role, count: r._count.role })),
          byStatus: {
            active: activeUsers,
            suspended: totalUsers - activeUsers,
            online: onlineUsers
          }
        },
        trends: {
          dailyActivity: activityTrends.reverse() // Most recent first
        }
      });

    } catch (error) {
      next(error);
    }
  }
);

// POST /api/users/batch - Bulk user operations (admin only)
router.post('/batch',
  AuthMiddleware.requireAuth,
  AuthMiddleware.requireRole(['admin']),
  [
    body('action').isIn(['activate', 'suspend', 'delete', 'update_role']).withMessage('Invalid action'),
    body('userIds').isArray({ min: 1 }).withMessage('userIds must be a non-empty array'),
    body('userIds.*').isInt({ min: 1 }).withMessage('Each userId must be a positive integer'),
    body('data').optional().isObject().withMessage('data must be an object'),
    body('reason').optional().isLength({ min: 1, max: 200 }).withMessage('Reason must be 1-200 characters')
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        throw new ValidationError('Invalid request data', errors.array());
      }

      const { action, userIds, data, reason } = req.body;

      // Verify all users exist
      const users = await prisma.user.findMany({
        where: { id: { in: userIds } },
        select: { id: true, username: true, role: true }
      });

      if (users.length !== userIds.length) {
        throw new NotFoundError('One or more users not found');
      }

      let updateData = {};
      let auditAction = action;

      switch (action) {
        case 'activate':
          updateData = { isActive: true };
          break;
        case 'suspend':
          updateData = { isActive: false };
          break;
        case 'update_role':
          if (!data?.role) {
            throw new ValidationError('Role is required for update_role action');
          }
          updateData = { role: data.role };
          auditAction = `role_changed_to_${data.role}`;
          break;
        case 'delete':
          // Soft delete - mark as inactive and scramble username
          updateData = { 
            isActive: false, 
            username: (username) => `deleted_${username}_${Date.now()}`
          };
          break;
      }

      // Perform bulk update
      const results = await prisma.$transaction(
        userIds.map(userId => 
          prisma.user.update({
            where: { id: userId },
            data: updateData,
            select: { id: true, username: true, role: true, isActive: true }
          })
        )
      );

      // Create audit log entries
      await prisma.auditLog.createMany({
        data: userIds.map(userId => ({
          userId,
          action: auditAction,
          performedBy: req.user.id,
          reason: reason || `Bulk ${action}`,
          timestamp: new Date()
        }))
      });

      return ResponseWrapper.success(res, {
        action,
        affected: results.length,
        users: results
      }, `Bulk ${action} completed successfully`);

    } catch (error) {
      next(error);
    }
  }
);

module.exports = router;

// === END src/routes/users.js ===

// === src/routes/webhooks.js ===
// src/routes/webhooks.js
const express = require('express');
const stripeService = require('../services/stripeService');
const { PrismaClient } = require('@prisma/client');

const router = express.Router();
const prisma = new PrismaClient();

// Stripe requires raw body for webhook signature verification
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

/**
 * @route POST /api/webhooks/stripe
 * @desc Handle Stripe webhook events
 * @access Public (but authenticated via Stripe signature)
 */
router.post('/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;

  let event;

  try {
    event = stripe.webhooks.constructEvent(req.body, sig, endpointSecret);
  } catch (err) {
    console.error('Webhook signature verification failed:', err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  console.log(`Received Stripe webhook: ${event.type}`);

  try {
    switch (event.type) {
      case 'payment_intent.succeeded':
        await handlePaymentIntentSucceeded(event.data.object);
        break;

      case 'payment_intent.payment_failed':
        await handlePaymentIntentFailed(event.data.object);
        break;

      case 'payment_intent.canceled':
        await handlePaymentIntentCanceled(event.data.object);
        break;

      case 'invoice.payment_succeeded':
        await handleInvoicePaymentSucceeded(event.data.object);
        break;

      case 'invoice.payment_failed':
        await handleInvoicePaymentFailed(event.data.object);
        break;

      case 'customer.subscription.created':
        await handleSubscriptionCreated(event.data.object);
        break;

      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object);
        break;

      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object);
        break;

      case 'charge.dispute.created':
        await handleChargeDisputeCreated(event.data.object);
        break;

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    res.json({ received: true });
  } catch (error) {
    console.error('Error handling webhook:', error);
    res.status(500).json({ error: 'Webhook handling failed' });
  }
});

/**
 * Handle successful payment intent
 */
async function handlePaymentIntentSucceeded(paymentIntent) {
  try {
    await stripeService.handlePaymentSuccess(paymentIntent);
    
    // Send confirmation notifications
    if (paymentIntent.metadata.order_id) {
      await sendOrderConfirmationNotification(parseInt(paymentIntent.metadata.order_id));
    }
    
    console.log(`Payment intent succeeded: ${paymentIntent.id}`);
  } catch (error) {
    console.error('Error handling payment success:', error);
  }
}

/**
 * Handle failed payment intent
 */
async function handlePaymentIntentFailed(paymentIntent) {
  try {
    await stripeService.handlePaymentFailure(paymentIntent);
    
    // Send failure notifications
    if (paymentIntent.metadata.order_id) {
      await sendPaymentFailureNotification(parseInt(paymentIntent.metadata.order_id));
    }
    
    console.log(`Payment intent failed: ${paymentIntent.id}`);
  } catch (error) {
    console.error('Error handling payment failure:', error);
  }
}

/**
 * Handle canceled payment intent
 */
async function handlePaymentIntentCanceled(paymentIntent) {
  try {
    const orderId = parseInt(paymentIntent.metadata.order_id);
    
    await prisma.orders.update({
      where: { id: orderId },
      data: {
        status: 'cancelled',
        payment_status: 'cancelled',
        cancelled_at: new Date()
      }
    });

    await prisma.payments.update({
      where: { stripe_payment_intent_id: paymentIntent.id },
      data: { status: 'cancelled' }
    });

    // Add status history
    await prisma.order_status_history.create({
      data: {
        order_id: orderId,
        from_status: 'pending',
        to_status: 'cancelled',
        notes: 'Payment intent was canceled'
      }
    });

    console.log(`Payment intent canceled: ${paymentIntent.id}`);
  } catch (error) {
    console.error('Error handling payment cancellation:', error);
  }
}

/**
 * Handle successful invoice payment (subscriptions)
 */
async function handleInvoicePaymentSucceeded(invoice) {
  try {
    if (invoice.subscription) {
      const subscription = await stripe.subscriptions.retrieve(invoice.subscription);
      
      // Update subscription payment record
      await prisma.payments.upsert({
        where: { stripe_payment_intent_id: invoice.payment_intent },
        update: {
          status: 'succeeded',
          completed_at: new Date()
        },
        create: {
          user_id: parseInt(subscription.metadata.user_id),
          stripe_payment_intent_id: invoice.payment_intent,
          amount_cents: invoice.amount_paid,
          currency: 'CAD',
          payment_type: 'subscription_donation',
          status: 'succeeded',
          completed_at: new Date()
        }
      });

      // Send subscription confirmation notification
      await sendSubscriptionConfirmationNotification(parseInt(subscription.metadata.user_id));
    }

    console.log(`Invoice payment succeeded: ${invoice.id}`);
  } catch (error) {
    console.error('Error handling invoice payment success:', error);
  }
}

/**
 * Handle failed invoice payment (subscriptions)
 */
async function handleInvoicePaymentFailed(invoice) {
  try {
    if (invoice.subscription) {
      const subscription = await stripe.subscriptions.retrieve(invoice.subscription);
      
      // Update payment record
      await prisma.payments.update({
        where: { stripe_payment_intent_id: invoice.payment_intent },
        data: {
          status: 'failed',
          failure_reason: 'Invoice payment failed'
        }
      });

      // Send payment failure notification
      await sendSubscriptionFailureNotification(parseInt(subscription.metadata.user_id));
    }

    console.log(`Invoice payment failed: ${invoice.id}`);
  } catch (error) {
    console.error('Error handling invoice payment failure:', error);
  }
}

/**
 * Handle subscription creation
 */
async function handleSubscriptionCreated(subscription) {
  try {
    const userId = parseInt(subscription.metadata.user_id);
    
    // Update user subscription status if needed
    // This would depend on your user subscription model
    
    console.log(`Subscription created: ${subscription.id} for user ${userId}`);
  } catch (error) {
    console.error('Error handling subscription creation:', error);
  }
}

/**
 * Handle subscription update
 */
async function handleSubscriptionUpdated(subscription) {
  try {
    const userId = parseInt(subscription.metadata.user_id);
    
    // Handle subscription changes (upgrades, downgrades, etc.)
    
    console.log(`Subscription updated: ${subscription.id} for user ${userId}`);
  } catch (error) {
    console.error('Error handling subscription update:', error);
  }
}

/**
 * Handle subscription deletion/cancellation
 */
async function handleSubscriptionDeleted(subscription) {
  try {
    const userId = parseInt(subscription.metadata.user_id);
    
    // Handle subscription cancellation
    await sendSubscriptionCancellationNotification(userId);
    
    console.log(`Subscription deleted: ${subscription.id} for user ${userId}`);
  } catch (error) {
    console.error('Error handling subscription deletion:', error);
  }
}

/**
 * Handle charge dispute
 */
async function handleChargeDisputeCreated(dispute) {
  try {
    const charge = await stripe.charges.retrieve(dispute.charge);
    const paymentIntent = await stripe.paymentIntents.retrieve(charge.payment_intent);
    
    if (paymentIntent.metadata.order_id) {
      const orderId = parseInt(paymentIntent.metadata.order_id);
      
      // Update order with dispute status
      await prisma.orders.update({
        where: { id: orderId },
        data: {
          admin_notes: `Dispute created: ${dispute.reason}`,
          status: 'disputed'
        }
      });

      // Add status history
      await prisma.order_status_history.create({
        data: {
          order_id: orderId,
          to_status: 'disputed',
          notes: `Charge disputed: ${dispute.reason}`
        }
      });

      // Notify admin
      await sendDisputeNotificationToAdmin(orderId, dispute);
    }
    
    console.log(`Charge dispute created: ${dispute.id}`);
  } catch (error) {
    console.error('Error handling charge dispute:', error);
  }
}

/**
 * Send order confirmation notification
 */
async function sendOrderConfirmationNotification(orderId) {
  try {
    const order = await prisma.orders.findUnique({
      where: { id: orderId },
      include: {
        user: {
          select: { id: true, username: true, email: true }
        },
        order_items: {
          include: {
            item: {
              select: { name: true, item_type: true }
            }
          }
        }
      }
    });

    if (!order) return;

    // Create notification for user
    await prisma.notifications.create({
      data: {
        user_id: order.user_id,
        type: 'payment_received',
        title: 'Order Confirmed!',
        message: `Your order ${order.order_number} has been confirmed and payment received.`,
        action_url: `/orders/${order.order_number}`,
        reference_type: 'order',
        reference_id: order.id
      }
    });

    console.log(`Order confirmation notification sent for order ${orderId}`);
  } catch (error) {
    console.error('Error sending order confirmation:', error);
  }
}

/**
 * Send payment failure notification
 */
async function sendPaymentFailureNotification(orderId) {
  try {
    const order = await prisma.orders.findUnique({
      where: { id: orderId },
      include: {
        user: {
          select: { id: true, username: true, email: true }
        }
      }
    });

    if (!order) return;

    await prisma.notifications.create({
      data: {
        user_id: order.user_id,
        type: 'payment_failed',
        title: 'Payment Failed',
        message: `Payment for order ${order.order_number} has failed. Please try again.`,
        action_url: `/orders/${order.order_number}`,
        reference_type: 'order',
        reference_id: order.id
      }
    });

    console.log(`Payment failure notification sent for order ${orderId}`);
  } catch (error) {
    console.error('Error sending payment failure notification:', error);
  }
}

/**
 * Send subscription confirmation notification
 */
async function sendSubscriptionConfirmationNotification(userId) {
  try {
    await prisma.notifications.create({
      data: {
        user_id: userId,
        type: 'payment_received',
        title: 'Subscription Payment Confirmed',
        message: 'Your subscription payment has been processed successfully.',
        action_url: '/account/subscriptions'
      }
    });

    console.log(`Subscription confirmation notification sent for user ${userId}`);
  } catch (error) {
    console.error('Error sending subscription confirmation:', error);
  }
}

/**
 * Send subscription failure notification
 */
async function sendSubscriptionFailureNotification(userId) {
  try {
    await prisma.notifications.create({
      data: {
        user_id: userId,
        type: 'payment_failed',
        title: 'Subscription Payment Failed',
        message: 'Your subscription payment has failed. Please update your payment method.',
        action_url: '/account/subscriptions'
      }
    });

    console.log(`Subscription failure notification sent for user ${userId}`);
  } catch (error) {
    console.error('Error sending subscription failure notification:', error);
  }
}

/**
 * Send subscription cancellation notification
 */
async function sendSubscriptionCancellationNotification(userId) {
  try {
    await prisma.notifications.create({
      data: {
        user_id: userId,
        type: 'admin_announcement',
        title: 'Subscription Cancelled',
        message: 'Your subscription has been cancelled. You can reactivate it anytime.',
        action_url: '/account/subscriptions'
      }
    });

    console.log(`Subscription cancellation notification sent for user ${userId}`);
  } catch (error) {
    console.error('Error sending subscription cancellation notification:', error);
  }
}

/**
 * Send dispute notification to admin
 */
async function sendDisputeNotificationToAdmin(orderId, dispute) {
  try {
    // Get all admin users
    const adminUsers = await prisma.users.findMany({
      where: {
        role: { in: ['admin', 'moderator'] }
      },
      select: { id: true }
    });

    // Create notification for each admin
    const notifications = adminUsers.map(admin => ({
      user_id: admin.id,
      type: 'admin_announcement',
      title: 'Charge Dispute Created',
      message: `Order #${orderId} has a charge dispute: ${dispute.reason}`,
      action_url: `/admin/orders/${orderId}`,
      reference_type: 'order',
      reference_id: orderId
    }));

    await prisma.notifications.createMany({
      data: notifications
    });

    console.log(`Dispute notification sent to ${adminUsers.length} admins`);
  } catch (error) {
    console.error('Error sending dispute notification to admin:', error);
  }
}

module.exports = router;

// === END src/routes/webhooks.js ===


============================================================
DIRECTORY: src/routes/admin
============================================================

// === src/routes/admin/store.js ===
// src/routes/admin/store.js
const express = require('express');
const { PrismaClient } = require('@prisma/client');
const AuthMiddleware = require('../../middleware/auth');
const ResponseWrapper = require('../../middleware/errorHandler').ResponseWrapper;
const stripeService = require('../../services/stripeService');

const router = express.Router();
const prisma = new PrismaClient();

// Apply admin authentication to all routes
router.use(AuthMiddleware.requireAdmin);

// Helper function to generate slug
const generateSlug = (name) => {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .trim();
};

/**
 * @route GET /api/admin/store/dashboard
 * @desc Get store dashboard analytics
 * @access Admin
 */
router.get('/dashboard', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'retrieve', 'store dashboard');

  try {
    const { period = '30' } = req.query; // days
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - parseInt(period));

    const [
      totalOrders,
      totalRevenue,
      recentOrders,
      topProducts,
      orderStatusCounts,
      dailyStats
    ] = await Promise.all([
      // Total orders count
      prisma.orders.count({
        where: {
          created_at: { gte: startDate }
        }
      }),
      
      // Total revenue
      prisma.orders.aggregate({
        where: {
          created_at: { gte: startDate },
          payment_status: 'succeeded'
        },
        _sum: { total_cents: true }
      }),
      
      // Recent orders
      prisma.orders.findMany({
        take: 10,
        orderBy: { created_at: 'desc' },
        include: {
          user: {
            select: { username: true, email: true }
          },
          order_items: {
            select: { quantity: true }
          }
        }
      }),
      
      // Top selling products
      prisma.order_items.groupBy({
        by: ['item_id'],
        _sum: { quantity: true },
        _count: { id: true },
        orderBy: { _sum: { quantity: 'desc' } },
        take: 5,
        where: {
          order: {
            created_at: { gte: startDate },
            payment_status: 'succeeded'
          }
        }
      }),
      
      // Order status distribution
      prisma.orders.groupBy({
        by: ['status'],
        _count: { id: true },
        where: {
          created_at: { gte: startDate }
        }
      }),
      
      // Daily sales stats
      prisma.$queryRaw`
        SELECT 
          DATE(created_at) as date,
          COUNT(*) as orders,
          SUM(total_cents) as revenue_cents
        FROM orders 
        WHERE created_at >= ${startDate}
          AND payment_status = 'succeeded'
        GROUP BY DATE(created_at)
        ORDER BY date ASC
      `
    ]);

    // Fetch product details for top products
    const topProductIds = topProducts.map(p => p.item_id);
    const productDetails = await prisma.store_items.findMany({
      where: { id: { in: topProductIds } },
      select: { id: true, name: true, price_cents: true, featured_image: true }
    });

    const topProductsWithDetails = topProducts.map(stat => {
      const product = productDetails.find(p => p.id === stat.item_id);
      return {
        ...product,
        total_sold: stat._sum.quantity,
        total_orders: stat._count.id,
        revenue_cents: stat._sum.quantity * (product?.price_cents || 0)
      };
    });

    return responseWrapper.success({
      overview: {
        total_orders: totalOrders,
        total_revenue_cents: totalRevenue._sum.total_cents || 0,
        total_revenue_formatted: `$${((totalRevenue._sum.total_cents || 0) / 100).toFixed(2)}`,
        period_days: parseInt(period)
      },
      recent_orders: recentOrders.map(order => ({
        ...order,
        total_formatted: `$${(order.total_cents / 100).toFixed(2)}`,
        item_count: order.order_items.reduce((sum, item) => sum + item.quantity, 0)
      })),
      top_products: topProductsWithDetails,
      order_status_counts,
      daily_stats: dailyStats.map(stat => ({
        date: stat.date,
        orders: Number(stat.orders),
        revenue_cents: Number(stat.revenue_cents),
        revenue_formatted: `$${(Number(stat.revenue_cents) / 100).toFixed(2)}`
      }))
    });
  } catch (error) {
    console.error('Error fetching store dashboard:', error);
    return responseWrapper.error('Failed to fetch dashboard data', 500, 'DASHBOARD_FETCH_FAILED');
  }
});

/**
 * @route GET /api/admin/store/categories
 * @desc Get all categories for admin
 * @access Admin
 */
router.get('/categories', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'retrieve', 'categories');

  try {
    const categories = await prisma.store_categories.findMany({
      include: {
        _count: {
          select: { store_items: true }
        },
        parent_category: {
          select: { id: true, name: true }
        }
      },
      orderBy: [
        { display_order: 'asc' },
        { name: 'asc' }
      ]
    });

    return responseWrapper.success({ categories });
  } catch (error) {
    console.error('Error fetching categories:', error);
    return responseWrapper.error('Failed to fetch categories', 500, 'FETCH_CATEGORIES_FAILED');
  }
});

/**
 * @route POST /api/admin/store/categories
 * @desc Create new category
 * @access Admin
 */
router.post('/categories', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'create', 'category');

  try {
    const { name, description, parent_id, item_type, display_order } = req.body;

    if (!name) {
      return responseWrapper.error('Category name is required', 400, 'MISSING_NAME');
    }

    const slug = generateSlug(name);

    // Check if slug already exists
    const existingCategory = await prisma.store_categories.findUnique({
      where: { slug }
    });

    if (existingCategory) {
      return responseWrapper.error('Category with this name already exists', 400, 'DUPLICATE_CATEGORY');
    }

    const category = await prisma.store_categories.create({
      data: {
        name,
        slug,
        description,
        parent_id: parent_id ? parseInt(parent_id) : null,
        item_type: item_type || 'physical',
        display_order: display_order ? parseInt(display_order) : 0
      },
      include: {
        parent_category: {
          select: { id: true, name: true }
        }
      }
    });

    return responseWrapper.success(category);
  } catch (error) {
    console.error('Error creating category:', error);
    return responseWrapper.error('Failed to create category', 500, 'CREATE_CATEGORY_FAILED');
  }
});

/**
 * @route PUT /api/admin/store/categories/:id
 * @desc Update category
 * @access Admin
 */
router.put('/categories/:id', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'update', 'category');

  try {
    const { id } = req.params;
    const { name, description, parent_id, item_type, display_order, is_active } = req.body;

    const updateData = {};
    if (name) {
      updateData.name = name;
      updateData.slug = generateSlug(name);
    }
    if (description !== undefined) updateData.description = description;
    if (parent_id !== undefined) updateData.parent_id = parent_id ? parseInt(parent_id) : null;
    if (item_type) updateData.item_type = item_type;
    if (display_order !== undefined) updateData.display_order = parseInt(display_order);
    if (is_active !== undefined) updateData.is_active = is_active;
    updateData.updated_at = new Date();

    const category = await prisma.store_categories.update({
      where: { id: parseInt(id) },
      data: updateData,
      include: {
        parent_category: {
          select: { id: true, name: true }
        }
      }
    });

    return responseWrapper.success(category);
  } catch (error) {
    console.error('Error updating category:', error);
    return responseWrapper.error('Failed to update category', 500, 'UPDATE_CATEGORY_FAILED');
  }
});

/**
 * @route GET /api/admin/store/items
 * @desc Get all store items for admin
 * @access Admin
 */
router.get('/items', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'retrieve', 'store items');

  try {
    const {
      category_id,
      item_type,
      is_active,
      search,
      sort = 'created_at',
      order = 'desc',
      page = 1,
      limit = 20
    } = req.query;

    const skip = (parseInt(page) - 1) * parseInt(limit);
    const take = parseInt(limit);

    const where = {
      ...(category_id && { category_id: parseInt(category_id) }),
      ...(item_type && { item_type }),
      ...(is_active !== undefined && { is_active: is_active === 'true' }),
      ...(search && {
        OR: [
          { name: { contains: search, mode: 'insensitive' } },
          { description: { contains: search, mode: 'insensitive' } }
        ]
      })
    };

    const orderBy = {};
    orderBy[sort] = order;

    const [items, totalCount] = await Promise.all([
      prisma.store_items.findMany({
        where,
        include: {
          category: {
            select: { id: true, name: true }
          },
          variants: {
            select: { id: true, name: true, stock_quantity: true }
          },
          _count: {
            select: {
              variants: true,
              order_items: true
            }
          }
        },
        orderBy,
        skip,
        take
      }),
      prisma.store_items.count({ where })
    ]);

    return responseWrapper.success({
      items: items.map(item => ({
        ...item,
        price_formatted: `$${(item.price_cents / 100).toFixed(2)}`,
        total_sold: item._count.order_items,
        low_stock: item.manage_inventory && item.low_stock_threshold 
          ? item.stock_quantity <= item.low_stock_threshold 
          : false
      })),
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalCount,
        pages: Math.ceil(totalCount / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Error fetching store items:', error);
    return responseWrapper.error('Failed to fetch store items', 500, 'FETCH_ITEMS_FAILED');
  }
});

/**
 * @route POST /api/admin/store/items
 * @desc Create new store item
 * @access Admin
 */
router.post('/items', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'create', 'store item');

  try {
    const {
      name,
      description,
      short_description,
      category_id,
      item_type,
      price_cents,
      compare_at_price_cents,
      weight_grams,
      requires_shipping = true,
      download_url,
      download_limit,
      access_duration_days,
      manage_inventory = false,
      stock_quantity = 0,
      low_stock_threshold,
      allow_backorder = false,
      meta_title,
      meta_description,
      images,
      featured_image,
      is_featured = false,
      variants = []
    } = req.body;

    if (!name || !category_id || !price_cents) {
      return responseWrapper.error('Name, category, and price are required', 400, 'MISSING_REQUIRED_FIELDS');
    }

    const slug = generateSlug(name);

    // Check if slug already exists
    const existingItem = await prisma.store_items.findUnique({
      where: { slug }
    });

    if (existingItem) {
      return responseWrapper.error('Item with this name already exists', 400, 'DUPLICATE_ITEM');
    }

    const item = await prisma.store_items.create({
      data: {
        name,
        slug,
        description,
        short_description,
        category_id: parseInt(category_id),
        item_type,
        price_cents: parseInt(price_cents),
        compare_at_price_cents: compare_at_price_cents ? parseInt(compare_at_price_cents) : null,
        weight_grams: weight_grams ? parseInt(weight_grams) : null,
        requires_shipping: item_type === 'physical' ? requires_shipping : false,
        download_url: item_type === 'digital' ? download_url : null,
        download_limit: item_type === 'digital' && download_limit ? parseInt(download_limit) : null,
        access_duration_days: item_type === 'digital' && access_duration_days ? parseInt(access_duration_days) : null,
        manage_inventory,
        stock_quantity: parseInt(stock_quantity),
        low_stock_threshold: low_stock_threshold ? parseInt(low_stock_threshold) : null,
        allow_backorder,
        meta_title,
        meta_description,
        images,
        featured_image,
        is_featured,
        published_at: new Date(),
        variants: {
          create: variants.map(variant => ({
            name: variant.name,
            sku: variant.sku,
            price_cents: variant.price_cents ? parseInt(variant.price_cents) : null,
            options: variant.options,
            stock_quantity: variant.stock_quantity ? parseInt(variant.stock_quantity) : 0,
            weight_grams: variant.weight_grams ? parseInt(variant.weight_grams) : null
          }))
        }
      },
      include: {
        category: {
          select: { id: true, name: true }
        },
        variants: true
      }
    });

    return responseWrapper.success(item);
  } catch (error) {
    console.error('Error creating store item:', error);
    return responseWrapper.error('Failed to create store item', 500, 'CREATE_ITEM_FAILED');
  }
});

/**
 * @route PUT /api/admin/store/items/:id
 * @desc Update store item
 * @access Admin
 */
router.put('/items/:id', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'update', 'store item');

  try {
    const { id } = req.params;
    const updateData = { ...req.body };
    delete updateData.variants; // Handle variants separately

    if (updateData.name) {
      updateData.slug = generateSlug(updateData.name);
    }

    // Convert string numbers to integers
    const numericFields = ['price_cents', 'compare_at_price_cents', 'weight_grams', 'download_limit', 'access_duration_days', 'stock_quantity', 'low_stock_threshold'];
    numericFields.forEach(field => {
      if (updateData[field] !== undefined && updateData[field] !== null) {
        updateData[field] = parseInt(updateData[field]);
      }
    });

    updateData.updated_at = new Date();

    const item = await prisma.store_items.update({
      where: { id: parseInt(id) },
      data: updateData,
      include: {
        category: {
          select: { id: true, name: true }
        },
        variants: true
      }
    });

    return responseWrapper.success(item);
  } catch (error) {
    console.error('Error updating store item:', error);
    return responseWrapper.error('Failed to update store item', 500, 'UPDATE_ITEM_FAILED');
  }
});

/**
 * @route GET /api/admin/store/orders
 * @desc Get all orders for admin
 * @access Admin
 */
router.get('/orders', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'retrieve', 'orders');

  try {
    const {
      status,
      payment_status,
      fulfillment_status,
      search,
      start_date,
      end_date,
      page = 1,
      limit = 20
    } = req.query;

    const skip = (parseInt(page) - 1) * parseInt(limit);
    const take = parseInt(limit);

    const where = {
      ...(status && { status }),
      ...(payment_status && { payment_status }),
      ...(fulfillment_status && { fulfillment_status }),
      ...(start_date && end_date && {
        created_at: {
          gte: new Date(start_date),
          lte: new Date(end_date)
        }
      }),
      ...(search && {
        OR: [
          { order_number: { contains: search, mode: 'insensitive' } },
          { user: { username: { contains: search, mode: 'insensitive' } } },
          { user: { email: { contains: search, mode: 'insensitive' } } }
        ]
      })
    };

    const [orders, totalCount] = await Promise.all([
      prisma.orders.findMany({
        where,
        include: {
          user: {
            select: { id: true, username: true, email: true }
          },
          order_items: {
            include: {
              item: {
                select: { name: true, featured_image: true }
              }
            }
          },
          coupon: {
            select: { code: true, discount_type: true, discount_value: true }
          }
        },
        orderBy: { created_at: 'desc' },
        skip,
        take
      }),
      prisma.orders.count({ where })
    ]);

    return responseWrapper.success({
      orders: orders.map(order => ({
        ...order,
        total_formatted: `$${(order.total_cents / 100).toFixed(2)}`,
        item_count: order.order_items.reduce((sum, item) => sum + item.quantity, 0)
      })),
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalCount,
        pages: Math.ceil(totalCount / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Error fetching orders:', error);
    return responseWrapper.error('Failed to fetch orders', 500, 'FETCH_ORDERS_FAILED');
  }
});

/**
 * @route PUT /api/admin/store/orders/:id/status
 * @desc Update order status
 * @access Admin
 */
router.put('/orders/:id/status', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'update', 'order status');

  try {
    const { id } = req.params;
    const { status, fulfillment_status, tracking_number, tracking_url, notes } = req.body;

    const order = await prisma.orders.findUnique({
      where: { id: parseInt(id) }
    });

    if (!order) {
      return responseWrapper.error('Order not found', 404, 'ORDER_NOT_FOUND');
    }

    const updateData = {
      updated_at: new Date()
    };

    if (status) updateData.status = status;
    if (fulfillment_status) updateData.fulfillment_status = fulfillment_status;
    if (tracking_number) updateData.tracking_number = tracking_number;
    if (tracking_url) updateData.tracking_url = tracking_url;
    if (notes) updateData.admin_notes = notes;

    // Set timestamps based on status
    if (status === 'shipped' && !order.shipped_at) {
      updateData.shipped_at = new Date();
    }
    if (status === 'delivered' && !order.delivered_at) {
      updateData.delivered_at = new Date();
    }
    if (status === 'cancelled' && !order.cancelled_at) {
      updateData.cancelled_at = new Date();
    }

    const updatedOrder = await prisma.orders.update({
      where: { id: parseInt(id) },
      data: updateData,
      include: {
        user: {
          select: { id: true, username: true, email: true }
        },
        order_items: {
          include: {
            item: {
              select: { name: true }
            }
          }
        }
      }
    });

    // Add status history
    await prisma.order_status_history.create({
      data: {
        order_id: parseInt(id),
        from_status: order.status,
        to_status: status || order.status,
        notes,
        created_by: req.user.id
      }
    });

    // Send notification to customer
    if (status) {
      await prisma.notifications.create({
        data: {
          user_id: order.user_id,
          type: status === 'shipped' ? 'trade_confirmed' : 'admin_announcement',
          title: `Order ${status}`,
          message: `Your order ${order.order_number} is now ${status}.`,
          action_url: `/orders/${order.order_number}`
        }
      });
    }

    return responseWrapper.success({
      ...updatedOrder,
      total_formatted: `$${(updatedOrder.total_cents / 100).toFixed(2)}`
    });
  } catch (error) {
    console.error('Error updating order status:', error);
    return responseWrapper.error('Failed to update order status', 500, 'UPDATE_ORDER_STATUS_FAILED');
  }
});

/**
 * @route POST /api/admin/store/orders/:id/refund
 * @desc Process order refund
 * @access Admin
 */
router.post('/orders/:id/refund', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'create', 'refund');

  try {
    const { id } = req.params;
    const { amount_cents, reason = 'requested_by_customer' } = req.body;

    const refund = await stripeService.refundOrder(parseInt(id), amount_cents, reason);

    return responseWrapper.success({
      refund: {
        id: refund.id,
        amount: refund.amount,
        status: refund.status,
        reason: refund.reason
      },
      message: 'Refund processed successfully'
    });
  } catch (error) {
    console.error('Error processing refund:', error);
    return responseWrapper.error('Failed to process refund', 500, 'REFUND_FAILED');
  }
});

/**
 * @route GET /api/admin/store/coupons
 * @desc Get all coupons
 * @access Admin
 */
router.get('/coupons', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'retrieve', 'coupons');

  try {
    const { is_active, search, page = 1, limit = 20 } = req.query;
    const skip = (parseInt(page) - 1) * parseInt(limit);
    const take = parseInt(limit);

    const where = {
      ...(is_active !== undefined && { is_active: is_active === 'true' }),
      ...(search && {
        OR: [
          { code: { contains: search, mode: 'insensitive' } },
          { name: { contains: search, mode: 'insensitive' } }
        ]
      })
    };

    const [coupons, totalCount] = await Promise.all([
      prisma.coupons.findMany({
        where,
        include: {
          admin: {
            select: { username: true }
          },
          _count: {
            select: { usage_log: true }
          }
        },
        orderBy: { created_at: 'desc' },
        skip,
        take
      }),
      prisma.coupons.count({ where })
    ]);

    return responseWrapper.success({
      coupons: coupons.map(coupon => ({
        ...coupon,
        usage_percentage: coupon.usage_limit 
          ? Math.round((coupon.current_uses / coupon.usage_limit) * 100)
          : 0,
        discount_formatted: coupon.discount_type === 'percentage' 
          ? `${coupon.discount_value}%` 
          : `$${(coupon.discount_value / 100).toFixed(2)}`
      })),
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalCount,
        pages: Math.ceil(totalCount / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Error fetching coupons:', error);
    return responseWrapper.error('Failed to fetch coupons', 500, 'FETCH_COUPONS_FAILED');
  }
});

/**
 * @route POST /api/admin/store/coupons
 * @desc Create new coupon
 * @access Admin
 */
router.post('/coupons', async (req, res) => {
  const responseWrapper = new ResponseWrapper(req, res, 'create', 'coupon');

  try {
    const {
      code,
      name,
      description,
      discount_type,
      discount_value,
      usage_limit,
      usage_limit_per_customer,
      minimum_amount_cents,
      maximum_discount_cents,
      starts_at,
      expires_at,
      applicable_item_ids = []
    } = req.body;

    if (!code || !name || !discount_type || !discount_value) {
      return responseWrapper.error('Code, name, discount type, and discount value are required', 400, 'MISSING_REQUIRED_FIELDS');
    }

    // Check if code already exists
    const existingCoupon = await prisma.coupons.findUnique({
      where: { code: code.toUpperCase() }
    });

    if (existingCoupon) {
      return responseWrapper.error('Coupon code already exists', 400, 'DUPLICATE_CODE');
    }

    const coupon = await prisma.coupons.create({
      data: {
        code: code.toUpperCase(),
        name,
        description,
        discount_type,
        discount_value: parseInt(discount_value),
        usage_limit: usage_limit ? parseInt(usage_limit) : null,
        usage_limit_per_customer: usage_limit_per_customer ? parseInt(usage_limit_per_customer) : null,
        minimum_amount_cents: minimum_amount_cents ? parseInt(minimum_amount_cents) : null,
        maximum_discount_cents: maximum_discount_cents ? parseInt(maximum_discount_cents) : null,
        starts_at: starts_at ? new Date(starts_at) : null,
        expires_at: expires_at ? new Date(expires_at) : null,
        created_by: req.user.id,
        applicable_items: applicable_item_ids.length > 0 ? {
          create: applicable_item_ids.map(itemId => ({
            item_id: parseInt(itemId)
          }))
        } : undefined
      },
      include: {
        admin: {
          select: { username: true }
        },
        applicable_items: {
          include: {
            item: {
              select: { name: true }
            }
          }
        }
      }
    });

    return responseWrapper.success(coupon);
  } catch (error) {
    console.error('Error creating coupon:', error);
    return responseWrapper.error('Failed to create coupon', 500, 'CREATE_COUPON_FAILED');
  }
});

module.exports = router;

// === END src/routes/admin/store.js ===


============================================================
DIRECTORY: src/services
============================================================

// === src/services/oliveBranchGenerator.js ===
// src/services/oliveBranchGenerator.js
// Enhanced Olive Branch Generator with boost support
const crypto = require('crypto');

// Background color constant
const OLIVE_BRANCH_BG_COLOR = '#F5F5DC'; // Beige background

// Enhanced color palettes with boost variations
const COLOR_PALETTES = {
  // Standard palettes
  oliveColors: {
    greenOlives: ['#6B8E23', '#808000', '#9ACD32', '#7CFC00', '#ADFF2F'],
    blackOlives: ['#2F2F2F', '#404040', '#1C1C1C', '#36454F', '#28282B'],
    brownOlives: ['#8B4513', '#A0522D', '#CD853F', '#D2691E', '#BC9A6A'],
    purpleOlives: ['#663399', '#4B0082', '#800080', '#9932CC', '#8B008B'],
    ripeMixed: ['#6B8E23', '#2F2F2F', '#663399', '#8B4513']
  },
  
  branchColors: {
    youngBranch: ['#8FBC8F', '#90EE90', '#98FB98', '#7CFC00'],
    matureBranch: ['#556B2F', '#6B8E23', '#808000', '#9ACD32'],
    brownBranch: ['#8B7355', '#A0522D', '#CD853F', '#DEB887'],
    silverBranch: ['#C0C0C0', '#D3D3D3', '#DCDCDC', '#F5F5F5']
  },
  
  leafColors: {
    freshLeaves: ['#228B22', '#32CD32', '#00FF00', '#7CFC00'],
    matureLeaves: ['#006400', '#228B22', '#2E8B57', '#3CB371'],
    silverLeaves: ['#9ACD32', '#C0C0C0', '#D3D3D3', '#E6E6FA'],
    dryLeaves: ['#6B8E23', '#808000', '#BDB76B', '#F0E68C']
  },

  // Seasonal/Boost palettes
  seasonalColors: {
    winterFrost: {
      olives: ['#B0E0E6', '#87CEEB', '#4682B4', '#5F9EA0'],
      branches: ['#708090', '#778899', '#2F4F4F', '#696969'],
      leaves: ['#F0F8FF', '#E6E6FA', '#D3D3D3', '#C0C0C0']
    },
    autumnGold: {
      olives: ['#DAA520', '#B8860B', '#CD853F', '#D2691E'],
      branches: ['#8B4513', '#A0522D', '#CD853F', '#DEB887'],
      leaves: ['#FF8C00', '#FFA500', '#FFD700', '#F0E68C']
    },
    springBloom: {
      olives: ['#98FB98', '#90EE90', '#7CFC00', '#ADFF2F'],
      branches: ['#8FBC8F', '#9ACD32', '#6B8E23', '#556B2F'],
      leaves: ['#00FF7F', '#00FA9A', '#32CD32', '#228B22']
    },
    mysticPurple: {
      olives: ['#9370DB', '#8A2BE2', '#9932CC', '#BA55D3'],
      branches: ['#4B0082', '#483D8B', '#6A5ACD', '#7B68EE'],
      leaves: ['#DDA0DD', '#DA70D6', '#EE82EE', '#FF69B4']
    }
  }
};

// Rarity configurations
const RARITY_CONFIG = {
  countRarities: {
    1: { name: 'Common', percentage: 33, weight: 0.33, score: 1 },
    2: { name: 'Common', percentage: 28, weight: 0.28, score: 2 },
    3: { name: 'Uncommon', percentage: 19, weight: 0.19, score: 3 },
    4: { name: 'Rare', percentage: 12, weight: 0.12, score: 4 },
    5: { name: 'Very Rare', percentage: 8, weight: 0.08, score: 5 }
  },
  
  typeRarities: {
    greenOlives: { name: 'Common', percentage: 30, weight: 0.30, score: 1 },
    blackOlives: { name: 'Common', percentage: 25, weight: 0.25, score: 2 },
    brownOlives: { name: 'Uncommon', percentage: 20, weight: 0.20, score: 3 },
    purpleOlives: { name: 'Rare', percentage: 15, weight: 0.15, score: 4 },
    ripeMixed: { name: 'Very Rare', percentage: 10, weight: 0.10, score: 5 }
  }
};

// Generation boost effects
const applyGenerationBoost = (baseWeights, boostConfig) => {
  if (!boostConfig || !boostConfig.isActive) {
    return baseWeights;
  }

  const boostedWeights = { ...baseWeights };
  
  // Apply rarity boost
  if (boostConfig.type === 'rarity_increase') {
    // Increase weights for rare items
    Object.keys(boostedWeights).forEach(key => {
      const rarity = RARITY_CONFIG.typeRarities[key] || RARITY_CONFIG.countRarities[key];
      if (rarity && rarity.score >= 4) { // Boost rare and very rare
        boostedWeights[key].weight *= (boostConfig.multiplier || 1.5);
      }
    });
  }
  
  // Normalize weights
  const totalWeight = Object.values(boostedWeights).reduce((sum, item) => sum + item.weight, 0);
  Object.keys(boostedWeights).forEach(key => {
    boostedWeights[key].weight = boostedWeights[key].weight / totalWeight;
  });

  return boostedWeights;
};

// Weighted random selection
const weightedSelection = (items, random) => {
  const totalWeight = Object.values(items).reduce((sum, item) => sum + (item.weight || 0), 0);
  let randomValue = random() * totalWeight;
  
  for (const [key, item] of Object.entries(items)) {
    randomValue -= (item.weight || 0);
    if (randomValue <= 0) return key;
  }
  
  return Object.keys(items)[0];
};

// Enhanced random color selection with seasonal support
const getRandomColor = (colorArray, random, seasonalPalette = null) => {
  if (seasonalPalette && Array.isArray(seasonalPalette)) {
    // Use seasonal colors if available
    return seasonalPalette[Math.floor(random() * seasonalPalette.length)];
  }
  return colorArray[Math.floor(random() * colorArray.length)];
};

// Main generation function with boost support
const generateOliveBranchData = (boostConfig = null, seedCategory = 'basic') => {
  const seedValue = crypto.randomBytes(16).toString('hex');
  let seed = parseInt(seedValue.substring(0, 8), 16);
  
  const random = () => {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  };

  // Apply generation boosts to weights
  let oliveCountWeights = { ...RARITY_CONFIG.countRarities };
  let oliveTypeWeights = { ...RARITY_CONFIG.typeRarities };

  if (boostConfig) {
    oliveCountWeights = applyGenerationBoost(oliveCountWeights, boostConfig);
    oliveTypeWeights = applyGenerationBoost(oliveTypeWeights, boostConfig);
  }

  // Premium seeds get inherent rarity boost
  if (seedCategory === 'premium') {
    Object.keys(oliveCountWeights).forEach(key => {
      const rarity = oliveCountWeights[key];
      if (rarity.score >= 3) { // Boost uncommon and above
        oliveCountWeights[key].weight *= 1.3;
      }
    });
    
    Object.keys(oliveTypeWeights).forEach(key => {
      const rarity = oliveTypeWeights[key];
      if (rarity.score >= 3) {
        oliveTypeWeights[key].weight *= 1.3;
      }
    });
  }

  // Generate branch characteristics
  const oliveCountKey = weightedSelection(oliveCountWeights, random);
  const oliveCount = parseInt(oliveCountKey);
  const oliveTypeKey = weightedSelection(oliveTypeWeights, random);

  // Get type info
  const typeInfo = RARITY_CONFIG.typeRarities[oliveTypeKey];
  const countInfo = RARITY_CONFIG.countRarities[oliveCount];

  // Determine color palette (seasonal vs standard)
  let activePalette = COLOR_PALETTES;
  let seasonalEffect = null;

  if (boostConfig && boostConfig.seasonalColors) {
    const seasonKeys = Object.keys(COLOR_PALETTES.seasonalColors);
    const randomSeason = seasonKeys[Math.floor(random() * seasonKeys.length)];
    seasonalEffect = COLOR_PALETTES.seasonalColors[randomSeason];
  }

  // Special handling for seasonal seeds
  if (seedCategory === 'seasonal' && !seasonalEffect) {
    const seasonKeys = Object.keys(COLOR_PALETTES.seasonalColors);
    const randomSeason = seasonKeys[Math.floor(random() * seasonKeys.length)];
    seasonalEffect = COLOR_PALETTES.seasonalColors[randomSeason];
  }

  // Generate colors
  let oliveColor, branchColor, leafColor;

  if (seasonalEffect) {
    oliveColor = getRandomColor(null, random, seasonalEffect.olives);
    branchColor = getRandomColor(null, random, seasonalEffect.branches);
    leafColor = getRandomColor(null, random, seasonalEffect.leaves);
  } else {
    // Standard color generation
    const oliveColorPalette = activePalette.oliveColors[oliveTypeKey];
    oliveColor = getRandomColor(oliveColorPalette, random);

    const branchPalettes = Object.values(activePalette.branchColors);
    const randomBranchPalette = branchPalettes[Math.floor(random() * branchPalettes.length)];
    branchColor = getRandomColor(randomBranchPalette, random);

    const leafPalettes = Object.values(activePalette.leafColors);
    const randomLeafPalette = leafPalettes[Math.floor(random() * leafPalettes.length)];
    leafColor = getRandomColor(randomLeafPalette, random);
  }

  // Calculate final rarity score
  const totalRarityScore = countInfo.score + typeInfo.score;
  const tradingValue = Math.floor(totalRarityScore * 1.5) + Math.floor(oliveCount * 0.5);

  return {
    seedValue,
    oliveCount,
    oliveType: typeInfo.displayName || 'Unknown Type',
    oliveTypeKey,
    oliveColor,
    branchColor,
    leafColor,
    countRarity: countInfo.name,
    typeRarity: typeInfo.name,
    countRarityPercentage: countInfo.percentage,
    typeRarityPercentage: typeInfo.percentage,
    totalRarityScore,
    tradingValue,
    seasonalEffect: seasonalEffect ? true : false,
    boostApplied: boostConfig ? true : false,
    seedCategory
  };
};

// Enhanced SVG generation with improved visuals
const generateOliveBranchSVG = (branchData) => {
  const { oliveCount, oliveColor, branchColor, leafColor, seedValue } = branchData;
  
  // Use seed for consistent positioning
  let seed = parseInt(seedValue.substring(0, 8), 16);
  const seededRandom = () => {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  };

  // Enhanced SVG with better styling
  let svg = `<svg width="100%" height="100%" viewBox="0 0 70 70" fill="none" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <filter id="softShadow" x="-20%" y="-20%" width="140%" height="140%">
        <feDropShadow dx="1" dy="1" stdDeviation="0.5" flood-color="rgba(0,0,0,0.1)"/>
      </filter>
      <linearGradient id="branchGradient" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop offset="0%" style="stop-color:${branchColor};stop-opacity:1" />
        <stop offset="100%" style="stop-color:${adjustBrightness(branchColor, -20)};stop-opacity:1" />
      </linearGradient>
      <radialGradient id="oliveGradient" cx="30%" cy="30%" r="70%">
        <stop offset="0%" style="stop-color:${adjustBrightness(oliveColor, 20)};stop-opacity:1" />
        <stop offset="100%" style="stop-color:${oliveColor};stop-opacity:1" />
      </radialGradient>
    </defs>
    
    <!-- Background -->
    <rect width="70" height="70" fill="${OLIVE_BRANCH_BG_COLOR}"/>
    
    <!-- Main stem with gradient -->
    <rect x="33" y="20" width="4" height="30" fill="url(#branchGradient)" filter="url(#softShadow)" rx="1"/>`;

  // Generate branches and elements based on olive count
  const positions = [];
  
  // Create natural branch distribution
  for (let i = 0; i < Math.min(oliveCount, 5); i++) {
    const progress = i / Math.max(oliveCount - 1, 1);
    const baseY = 25 + (progress * 20);
    const side = i % 2 === 0 ? -1 : 1;
    const branchLength = 8 + seededRandom() * 6;
    
    positions.push({
      branchX: 35 + (side * 2),
      branchY: baseY,
      branchEndX: 35 + (side * branchLength),
      branchEndY: baseY + (seededRandom() - 0.5) * 4,
      oliveX: 35 + (side * (branchLength - 2)),
      oliveY: baseY - 1,
      leafX: 35 + (side * (branchLength + 2)),
      leafY: baseY - 2,
      side
    });
  }

  // Draw branches
  positions.forEach(pos => {
    svg += `<line x1="${pos.branchX}" y1="${pos.branchY}" x2="${pos.branchEndX}" y2="${pos.branchEndY}" 
            stroke="url(#branchGradient)" stroke-width="2" stroke-linecap="round" filter="url(#softShadow)"/>`;
  });

  // Draw leaves
  positions.forEach(pos => {
    const leafWidth = 4 + seededRandom() * 2;
    const leafHeight = 6 + seededRandom() * 2;
    svg += `<ellipse cx="${pos.leafX}" cy="${pos.leafY}" rx="${leafWidth/2}" ry="${leafHeight/2}" 
            fill="${leafColor}" opacity="0.9" filter="url(#softShadow)"/>`;
  });

  // Draw olives with enhanced styling
  positions.slice(0, oliveCount).forEach(pos => {
    const oliveSize = 3 + seededRandom() * 1.5;
    svg += `<ellipse cx="${pos.oliveX}" cy="${pos.oliveY}" rx="${oliveSize/2}" ry="${oliveSize}" 
            fill="url(#oliveGradient)" filter="url(#softShadow)"/>`;
    
    // Add highlight
    svg += `<ellipse cx="${pos.oliveX - 0.5}" cy="${pos.oliveY - 0.5}" rx="${oliveSize/4}" ry="${oliveSize/2}" 
            fill="rgba(255,255,255,0.3)"/>`;
  });

  svg += `</svg>`;
  return svg;
};

// Helper function to adjust color brightness
const adjustBrightness = (hex, percent) => {
  const num = parseInt(hex.replace("#", ""), 16);
  const amt = Math.round(2.55 * percent);
  const R = (num >> 16) + amt;
  const G = (num >> 8 & 0x00FF) + amt;
  const B = (num & 0x0000FF) + amt;
  return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
};

// Function to get active generation boosts
const getActiveBoosts = async (prisma) => {
  const now = new Date();
  return await prisma.generationBoost.findMany({
    where: {
      isActive: true,
      startTime: { lte: now },
      endTime: { gte: now }
    }
  });
};

// Function to check if user has boost available
const getUserBoost = async (prisma, userId, boostId) => {
  return await prisma.userGenerationBoost.findFirst({
    where: {
      userId,
      boostId,
      usesRemaining: { gt: 0 },
      expiresAt: { gt: new Date() }
    }
  });
};

// Enhanced generation with boost integration
const generateWithBoosts = async (prisma, userId, seedCategory = 'basic') => {
  // Get active boosts
  const activeBoosts = await getActiveBoosts(prisma);
  
  let bestBoost = null;
  let userBoost = null;

  // Check if user has any personal boosts
  for (const boost of activeBoosts) {
    const userBoostData = await getUserBoost(prisma, userId, boost.id);
    if (userBoostData) {
      bestBoost = {
        isActive: true,
        type: boost.boostType,
        multiplier: boost.rarityMultiplier,
        seasonalColors: boost.colorPalettes,
        boostId: boost.id
      };
      userBoost = userBoostData;
      break; // Use first available boost
    }
  }

  // If no personal boost, check for global boosts
  if (!bestBoost && activeBoosts.length > 0) {
    const globalBoost = activeBoosts[0]; // Use first active global boost
    bestBoost = {
      isActive: true,
      type: globalBoost.boostType,
      multiplier: globalBoost.rarityMultiplier,
      seasonalColors: globalBoost.colorPalettes
    };
  }

  // Generate branch with boost
  const branchData = generateOliveBranchData(bestBoost, seedCategory);

  // If user had a personal boost, consume one use
  if (userBoost) {
    await prisma.userGenerationBoost.update({
      where: { id: userBoost.id },
      data: { usesRemaining: { decrement: 1 } }
    });
  }

  return branchData;
};

// Function to create preview branch (for registration)
const generatePreviewBranch = () => {
  return generateOliveBranchData(null, 'basic');
};

// Function to generate themed branches for special events
const generateThemedBranch = (theme, seedCategory = 'seasonal') => {
  const themeBoost = {
    isActive: true,
    type: 'seasonal_colors',
    multiplier: 1.2,
    seasonalColors: theme
  };
  
  return generateOliveBranchData(themeBoost, seedCategory);
};

// Rarity calculation helper
const calculateRarityScore = (branchData) => {
  const countScore = RARITY_CONFIG.countRarities[branchData.oliveCount]?.score || 1;
  const typeScore = RARITY_CONFIG.typeRarities[branchData.oliveTypeKey]?.score || 1;
  return countScore + typeScore;
};

// Trading value calculation
const calculateTradingValue = (branchData) => {
  const rarityScore = calculateRarityScore(branchData);
  let baseValue = Math.floor(rarityScore * 1.5) + Math.floor(branchData.oliveCount * 0.5);
  
  // Boost multipliers
  if (branchData.boostApplied) baseValue *= 1.1;
  if (branchData.seasonalEffect) baseValue *= 1.2;
  if (branchData.seedCategory === 'premium') baseValue *= 1.15;
  if (branchData.seedCategory === 'seasonal') baseValue *= 1.3;
  
  return Math.floor(baseValue);
};

// Export functions
module.exports = {
  // Core generation
  generateOliveBranchData,
  generateOliveBranchSVG,
  generateWithBoosts,
  generatePreviewBranch,
  generateThemedBranch,
  
  // Utility functions
  calculateRarityScore,
  calculateTradingValue,
  getActiveBoosts,
  getUserBoost,
  
  // Constants
  OLIVE_BRANCH_BG_COLOR,
  COLOR_PALETTES,
  RARITY_CONFIG
};

// === END src/services/oliveBranchGenerator.js ===

// === src/services/stripeService.js ===
// src/services/stripeService.js
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

class StripeService {
  constructor() {
    this.stripe = stripe;
  }

  async createOrGetCustomer(user) {
    try {
      const existingUser = await prisma.users.findUnique({
        where: { id: user.id },
        select: { stripe_customer_id: true }
      });

      if (existingUser?.stripe_customer_id) {
        try {
          const customer = await this.stripe.customers.retrieve(existingUser.stripe_customer_id);
          return customer;
        } catch (error) {
          console.log('Stripe customer not found, creating new one');
        }
      }

      const customer = await this.stripe.customers.create({
        email: user.email,
        name: user.username,
        metadata: {
          user_id: user.id.toString(),
          id_no: user.id_no
        }
      });

      await prisma.users.update({
        where: { id: user.id },
        data: { stripe_customer_id: customer.id }
      });

      return customer;
    } catch (error) {
      console.error('Error creating/getting Stripe customer:', error);
      throw new Error('Failed to create customer');
    }
  }

  async createPaymentIntent(order, user) {
    try {
      const customer = await this.createOrGetCustomer(user);

      const paymentIntent = await this.stripe.paymentIntents.create({
        amount: order.total_cents,
        currency: 'cad',
        customer: customer.id,
        metadata: {
          order_id: order.id.toString(),
          order_number: order.order_number,
          user_id: user.id.toString()
        },
        description: `Order ${order.order_number}`,
        automatic_payment_methods: {
          enabled: true,
        }
      });

      await prisma.orders.update({
        where: { id: order.id },
        data: { 
          stripe_payment_intent_id: paymentIntent.id,
          stripe_customer_id: customer.id
        }
      });

      await prisma.payments.create({
        data: {
          user_id: user.id,
          stripe_payment_intent_id: paymentIntent.id,
          amount_cents: order.total_cents,
          currency: 'CAD',
          payment_type: 'store_purchase',
          status: 'pending',
          reference_id: order.id
        }
      });

      return paymentIntent;
    } catch (error) {
      console.error('Error creating payment intent:', error);
      throw new Error('Failed to create payment intent');
    }
  }

  async handlePaymentSuccess(paymentIntent) {
    try {
      const orderId = parseInt(paymentIntent.metadata.order_id);
      
      await prisma.orders.update({
        where: { id: orderId },
        data: {
          payment_status: 'succeeded',
          status: 'confirmed'
        }
      });

      await prisma.payments.update({
        where: { stripe_payment_intent_id: paymentIntent.id },
        data: {
          status: 'succeeded',
          completed_at: new Date()
        }
      });

      return true;
    } catch (error) {
      console.error('Error handling payment success:', error);
      throw error;
    }
  }

  async handlePaymentFailure(paymentIntent) {
    try {
      const orderId = parseInt(paymentIntent.metadata.order_id);
      
      await prisma.orders.update({
        where: { id: orderId },
        data: {
          payment_status: 'failed',
          status: 'cancelled'
        }
      });

      await prisma.payments.update({
        where: { stripe_payment_intent_id: paymentIntent.id },
        data: {
          status: 'failed',
          failure_reason: paymentIntent.last_payment_error?.message || 'Payment failed'
        }
      });

      return true;
    } catch (error) {
      console.error('Error handling payment failure:', error);
      throw error;
    }
  }
}

module.exports = new StripeService();

// === END src/services/stripeService.js ===


============================================================
DIRECTORY: src/utils
============================================================

// === src/utils/jwt.js ===
// utils/jwt.js - JWT Token Utilities
const jwt = require('jsonwebtoken');
const crypto = require('crypto');

class JWTService {
  constructor() {
    this.secret = process.env.JWT_SECRET || crypto.randomBytes(64).toString('hex');
    this.refreshSecret = process.env.JWT_REFRESH_SECRET || crypto.randomBytes(64).toString('hex');
    this.accessTokenExpiry = process.env.JWT_ACCESS_EXPIRY || '15m';
    this.refreshTokenExpiry = process.env.JWT_REFRESH_EXPIRY || '7d';
  }

  generateTokens(user) {
    const payload = {
      userId: user.id,
      username: user.username,
      role: user.role,
      branch: user.branch || null,
      permissions: this.getUserPermissions(user.role),
      activeOliveBranchId: user.activeOliveBranchId || null
    };

    const accessToken = jwt.sign(payload, this.secret, {
      expiresIn: this.accessTokenExpiry,
      issuer: 'galway-research',
      subject: user.id.toString()
    });

    const refreshToken = jwt.sign(
      { userId: user.id, type: 'refresh' },
      this.refreshSecret,
      {
        expiresIn: this.refreshTokenExpiry,
        issuer: 'galway-research',
        subject: user.id.toString()
      }
    );

    return {
      accessToken,
      refreshToken,
      expiresIn: this.getExpirySeconds(this.accessTokenExpiry)
    };
  }

  verifyAccessToken(token) {
    try {
      return jwt.verify(token, this.secret);
    } catch (error) {
      throw new Error(`Invalid access token: ${error.message}`);
    }
  }

  verifyRefreshToken(token) {
    try {
      return jwt.verify(token, this.refreshSecret);
    } catch (error) {
      throw new Error(`Invalid refresh token: ${error.message}`);
    }
  }

  getUserPermissions(role) {
    const permissions = {
      guest: ['read_public'],
      operative: [
        'read_users',
        'update_own_profile',
        'generate_branches',
        'view_inventory',
        'update_inventory',
        'basic_trading'
      ],
      contributor: [
        'read_users',
        'update_own_profile',
        'generate_branches',
        'view_inventory',
        'update_inventory',
        'advanced_trading',
        'create_research_data'
      ],
      beta_tester: [
        'read_users',
        'update_own_profile',
        'generate_branches',
        'view_inventory',
        'update_inventory',
        'advanced_trading',
        'beta_features',
        'submit_feedback'
      ],
      moderator: [
        'read_users',
        'read_all_profiles',
        'update_own_profile',
        'generate_branches',
        'view_inventory',
        'update_inventory',
        'advanced_trading',
        'moderate_content',
        'view_reports'
      ],
      admin: ['*'] // All permissions
    };

    return permissions[role] || permissions.guest;
  }

  getExpirySeconds(expiryString) {
    const unit = expiryString.slice(-1);
    const value = parseInt(expiryString.slice(0, -1));
    
    switch (unit) {
      case 's': return value;
      case 'm': return value * 60;
      case 'h': return value * 60 * 60;
      case 'd': return value * 24 * 60 * 60;
      default: return 900; // 15 minutes default
    }
  }

  extractTokenFromHeader(authHeader) {
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return null;
    }
    return authHeader.substring(7);
  }
}

module.exports = new JWTService();

// === END src/utils/jwt.js ===

// === src/utils/responseWrapper.js ===
// utils/responseWrapper.js - Standardized API Responses
const { v4: uuidv4 } = require('uuid');

class ResponseWrapper {
  static success(res, data, message = 'Operation completed successfully', statusCode = 200) {
    const response = {
      success: true,
      data,
      message,
      timestamp: new Date().toISOString(),
      requestId: res.locals.requestId || uuidv4()
    };

    // Add pagination if present
    if (data && data.pagination) {
      response.pagination = data.pagination;
      response.data = data.data || data;
      delete response.data.pagination;
    }

    return res.status(statusCode).json(response);
  }

  static error(res, error, statusCode = 500, code = 'INTERNAL_SERVER_ERROR') {
    const response = {
      success: false,
      error: {
        code,
        message: error.message || error,
        details: error.details || {}
      },
      timestamp: new Date().toISOString(),
      requestId: res.locals.requestId || uuidv4()
    };

    // Add stack trace in development
    if (process.env.NODE_ENV === 'development' && error.stack) {
      response.error.stack = error.stack;
    }

    return res.status(statusCode).json(response);
  }

  static paginated(res, data, pagination, message = 'Data retrieved successfully') {
    return ResponseWrapper.success(res, {
      items: data,
      pagination: {
        page: pagination.page,
        limit: pagination.limit,
        total: pagination.total,
        totalPages: Math.ceil(pagination.total / pagination.limit),
        hasNext: pagination.page < Math.ceil(pagination.total / pagination.limit),
        hasPrev: pagination.page > 1
      }
    }, message);
  }

  static created(res, data, message = 'Resource created successfully') {
    return ResponseWrapper.success(res, data, message, 201);
  }

  static updated(res, data, message = 'Resource updated successfully') {
    return ResponseWrapper.success(res, data, message, 200);
  }

  static deleted(res, message = 'Resource deleted successfully') {
    return ResponseWrapper.success(res, null, message, 200);
  }

  static notFound(res, message = 'Resource not found') {
    return ResponseWrapper.error(res, new Error(message), 404, 'NOT_FOUND');
  }

  static forbidden(res, message = 'Access forbidden') {
    return ResponseWrapper.error(res, new Error(message), 403, 'FORBIDDEN');
  }

  static unauthorized(res, message = 'Authentication required') {
    return ResponseWrapper.error(res, new Error(message), 401, 'UNAUTHORIZED');
  }

  static badRequest(res, message = 'Invalid request', details = {}) {
    const error = new Error(message);
    error.details = details;
    return ResponseWrapper.error(res, error, 400, 'BAD_REQUEST');
  }

  static validationError(res, validationErrors) {
    const error = new Error('Validation failed');
    error.details = validationErrors;
    return ResponseWrapper.error(res, error, 422, 'VALIDATION_ERROR');
  }

  static rateLimit(res, message = 'Too many requests') {
    return ResponseWrapper.error(res, new Error(message), 429, 'RATE_LIMIT_EXCEEDED');
  }
}

// middleware/errorHandler.js - Enhanced Error Handler
const ResponseWrapper = require('./responseWrapper');

class AppError extends Error {
  constructor(message, statusCode = 500, code = 'INTERNAL_SERVER_ERROR', details = {}) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.details = details;
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

const errorHandler = (error, req, res, next) => {
  // Set request ID for tracking
  if (!res.locals.requestId) {
    res.locals.requestId = req.headers['x-request-id'] || require('uuid').v4();
  }

  console.error(`[${res.locals.requestId}] Error:`, {
    message: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    user: req.user?.username || 'anonymous',
    timestamp: new Date().toISOString()
  });

  // Handle known operational errors
  if (error.isOperational) {
    return ResponseWrapper.error(res, error, error.statusCode, error.code);
  }

  // Handle JWT errors
  if (error.name === 'JsonWebTokenError') {
    return ResponseWrapper.unauthorized(res, 'Invalid token');
  }

  if (error.name === 'TokenExpiredError') {
    return ResponseWrapper.unauthorized(res, 'Token expired');
  }

  // Handle Prisma errors
  if (error.code === 'P2002') {
    return ResponseWrapper.error(res, 
      new Error('Duplicate entry - resource already exists'), 
      409, 
      'DUPLICATE_ENTRY'
    );
  }

  if (error.code === 'P2025') {
    return ResponseWrapper.notFound(res, 'Resource not found');
  }

  if (error.code && error.code.startsWith('P')) {
    return ResponseWrapper.error(res, 
      new Error('Database operation failed'), 
      500, 
      'DATABASE_ERROR'
    );
  }

  // Handle validation errors
  if (error.name === 'ValidationError') {
    const validationErrors = Object.values(error.errors).map(err => ({
      field: err.path,
      message: err.message,
      value: err.value
    }));
    return ResponseWrapper.validationError(res, validationErrors);
  }

  // Handle rate limiting
  if (error.code === 'RATE_LIMIT_EXCEEDED') {
    return ResponseWrapper.rateLimit(res, error.message);
  }

  // Handle unexpected errors
  return ResponseWrapper.error(res, 
    new Error(process.env.NODE_ENV === 'production' 
      ? 'An unexpected error occurred' 
      : error.message
    ), 
    500, 
    'INTERNAL_SERVER_ERROR'
  );
};

// Custom error classes for common scenarios
class ValidationError extends AppError {
  constructor(message, details = {}) {
    super(message, 422, 'VALIDATION_ERROR', details);
  }
}

class NotFoundError extends AppError {
  constructor(message = 'Resource not found') {
    super(message, 404, 'NOT_FOUND');
  }
}

class ForbiddenError extends AppError {
  constructor(message = 'Access forbidden') {
    super(message, 403, 'FORBIDDEN');
  }
}

class UnauthorizedError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 401, 'UNAUTHORIZED');
  }
}

class ConflictError extends AppError {
  constructor(message = 'Resource conflict') {
    super(message, 409, 'CONFLICT');
  }
}

// Request ID middleware
const requestIdMiddleware = (req, res, next) => {
  const requestId = req.headers['x-request-id'] || require('uuid').v4();
  res.locals.requestId = requestId;
  res.set('X-Request-ID', requestId);
  next();
};

module.exports = {
  ResponseWrapper,
  errorHandler,
  requestIdMiddleware,
  AppError,
  ValidationError,
  NotFoundError,
  ForbiddenError,
  UnauthorizedError,
  ConflictError
};

// === END src/utils/responseWrapper.js ===

